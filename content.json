[{"title":"Redis快速入门","date":"2019-09-22T13:26:15.000Z","path":"2019/09/22/Redis快速入门/","text":"什么是Redis？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis是Remote Dictionary Severy(远程字典服务器)的缩写，它是一个基于C语言编写的完全开源免费，并且遵循BSD协议的一个高性能的key-value型分布式内存数据库。Redis使用key-value的形式保存值，常用的数据类型有String、list、hash、set、zset等数据结构，因此也被人们称为数据结构服务器。当然他也是NoSQL的一种典型产品。 Redis的特性 1、Redis支持数据的持久化，可以将内存中的数据保存到磁盘上，重启后可已再次加载数据 2、Redis不仅仅支持简单的key-value类型的数据，同时还支持list、set、zset、hash等存储数据结构 3、Redis支持数据的备份，即master-slave模式的数据备份。 4、Redis的性能极高-官方宣称Redis的读速度可以达到110000次/s，写的速度是81000次/s. 5、原子操作—Redis的所有操作都是原子的，即要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务。 在Linux（CentOS 7）安装Redis首先去Redis的官方网站下载需要redisredis官网的镜像网址：http://download.redis.io/releases/，在这里有redis的各个版本： 在Liunx上使用wget命令下载（我这个下载它当前的最新的镜像redis-5.0.5-tar.gz版本）：wget http://download.redis.io/releases/redis-5.0.5.tar.gz 下载好后解压tar -zxvf redis-5.0.5.tar.gz 安装使用make命令编译解压完成后，cd 到解压后文件中，执行make命令，这一步可能会报错（在较低版本的Linux发行系统中可能会报错提示没有GCC环境，那就去安装一下GCC,然后执行make destclean命令清除失败的安装产生的文件，之后再次执行nake命令） make install PREFIX=/usr/local/redismake执行成功后文件夹找就会多一个src文件夹，进入src文件夹，执行 make install PREFIX=/usr/local/redis命令，把redis安装到/usr/local/redis/ 有关的配置把redis配置文件copy到安装目录下 配置redis为后台启动将刚在复制到安装目录的那个redis.conf打开，并把其中的daemonize no改成daemonize yes 设置redis开机自动启动打开/etc/rc.local 在里面添加：/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf(rc.local这个脚本会在开机的时候执行） 启动redis服务使用redis-server /usr/local/redis/redis.conf启动redis服务。注意：如果按照上面的正常的流程安装下来，但是在执行redis-server启动redis的时候提示redis-server不是命令，不要慌张，这是由于这个redis-server不是全局的命令不能在每一个目录下使用，当在别的目录下使用的时候系统在/usr/bin/找不到这个命令，因此我们需要把安装目录下的redis-server移动到到/usr/bin目录下就可以了。比如我的安装目录是/home/myredis/redis/redis-5.0.5/src/redis-server，那就可以执行下面的命令：ln -s /home/myredis/redis/redis-5.0.5/src/redis-server /usr/bin/redis-server 解决问题后再来执行上面那个命令启动redis服务,启动后我们可以使用ps -ef | grep redis来查看服务有没有启动： redis启动成功了，之后执行redis-cli -p 6379 进入redis的客户端 redis-benchmarkredis自带了一个性能测试工具redis-benchmark，他有丰富的模拟组件和指令可以使用。中文链接如下： http://www.redis.cn/topics/benchmarks.html 。redis-benchmark 程序模拟 N 个客户端同时发出 M 个请求来测试在本机上redis可以达到的吞吐量从而间接的对给定硬件条件下面的机器计算出性能参数。 表现为Response time和完成request的数量等等。 redis-benchmark可以使用到的参数： 12345-t 选择你想测试的命令，比如redis-benchmark -t set -p 指定port redis-benchmark -p 6379 -l 一直循环 -c 指定客户端数量 -n 指定request数量 redis常识性知识点redis的默认端口是6379redis的常用五大数据类型Redis的五大常用数据类型是：String（字符串）、List（列表）、Hash（散列表）、Set（集合）、ZSet（sorted Set，有序集合） redis是单进程的来处理客户端的请求。对读写等事件的响应式通过对epoll函数的包装来实现到的。Redis的实际处理速度完全依靠主进程的执行效率。epoll是Linux内科为处理大批量文件描述符伟做了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 默认有16个数据库。默认的数据库从DB0开始（一进入redis客户端默认使用的也是0号库），切换可以使用select &lt;dbid&gt;,这些在redis.conf这个文件中有详细的说明： SELECT 命令切换数据库使用select &lt;dbid&gt;，比如select 1就可以切换到1号库： DBSIZE 命令查看数据库key的数量 KEYS 命令查看数据库中的key123456789101112131415127.0.0.1:6379&gt; DBSIZE(integer) 7 #7个key127.0.0.1:6379&gt; keys * #查看本库中的所有key1) \"mylist\"2) \"k3\"3) \"myset:__rand_int__\"4) \"key:__rand_int__\"5) \"k2\"6) \"counter:__rand_int__\"7) \"k1\"127.0.0.1:6379&gt; keys k? #查看以`k`打头的key1) \"k3\"2) \"k2\"3) \"k1\"127.0.0.1:6379&gt; 但我们不想要数据库中的key的时候可以使用FLUSHDB清空当前数据库的所有key，FLUSHALL清空所有数据库中所有key","tags":[{"name":"Redis","slug":"Redis","permalink":"http://easyblog.top/tags/Redis/"}]},{"title":"Docker进阶之Dockerfile和容器数据卷（Volume）","date":"2019-09-20T10:47:43.000Z","path":"2019/09/20/docker进阶之数据卷/","text":"什么是数据卷？什么是容器数据卷？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷就是一个文件或者文件夹。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker的理念之一是将应用与其运行的环境打包，docker容器的生命周期是与其运行的程序一致的，而对数据的要求是持久化，docker容器之间也需要有共享数据的渠道。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷是特殊的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的是数据的持久化，是完全独立于容器的生命周期，不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷存在于宿主机中，独立于容器，和容器的生命周期是分离的，数据卷存在于宿主机的文件系统中，数据卷可以是目录也可以是文件，容器可以利用数据卷与宿主机进行数据共享，实现了容器间的数据共享和交换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通俗地来说，docker容器数据卷可以看成使我们生活中常用的u盘，它存在于一个或多个的容器中，由docker挂载到容器，但不属于联合文件系统，Docker不会在容器删除时删除其挂载的数据卷。 Docker添加数据的两种方式使用命令的方式添加数据卷在使用docker run的时候我们可以通过 -v 来创建一个数据卷并挂载到容器上，在一次run中多次使用可以挂载多个容器。命令语法：docker run -it -v /宿主机绝对路径:/容器绝对路径 镜像名 打开命令行终端，使用docker命令以交互式的方式来运行centos 1234567[root@localhost /]# docker run --name centos -it -v /home/huangxin/hostdata/:/dataVolmeContainer --privileged=true 67fa590cfc1c /bin/bash [root@aa29e3790769 /]# lsanaconda-post.log bin dataVolmeContainer dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@aa29e3790769 /]# cd dataVolmeCOntainer[root@localhost /]# docker run -it -v /home/huangxin/hostdata:/dataVolmeContainer centos [root@0504f3b67b95 /]# ls #进入到容器内部，容器内部的目录创建好了anaconda-post.log bin dataVolmeContainer dev etc home lib lib64 如果发现挂载在容器中的目录没有访问权限，可以加上--privileged=true这个参数。启动成功后我们可以用前面我们学过一个命令docker inspect 容器名/容器ID来查看关于一个容器的有关细节，打开我们发现主机和容器之间的共享已经建立起来了，而且默认都是可读可写的： 接下来测试一下容器和主机之间互相共享数据：打开另一个终端中，来到/home/huangxin/hostdata目录下，新建text1.txt,然后在里面写点东西： 12345[huangxin@localhost ~]$ cd /home/huangxin/hostdata[root@localhost hostdata]# touch text1.txt[root@localhost hostdata]# lstext1.txt[root@localhost hostdata]# vim text1.txt 随便写点东西： 然后来到容器里，就可以看到主机在主机端的共享文件夹中写的数据在容器中可以看到了： 接着我们反向操作看看在容器中写的数据能不能在主机可以共享到。 1234[root@aa29e3790769 dataVolmeContainer]# touch Demo1.txt[root@aa29e3790769 dataVolmeContainer]# vi Demo1.txt[root@aa29e3790769 dataVolmeContainer]# lsDemo1.txt text1.txt 还是随便写了点东西在新建的Demo1.text中，然后在主机端去看看有没有。 1234[root@localhost hostdata]# lsDemo1.txt text1.txt[root@localhost hostdata]# cat Demo1.txtHere is container!!!Hello Host. 可以看到主机和容器之间可以相互共享文件了；而且对这些文件都具有读写的权限。而且即使容器停止后，这些共享的数据还是同步的。然而有时我们不需要让容器写数据，那么我们就可以用带权限的命令：docker run -it -v /宿主机绝对路径:/容器绝对路径:ro 镜像名 ，ro表示read only。 使用DockerFile添加数据卷（这里先大概了解一下，下面会有Dockerfile详细的介绍）编写自定义的Dockerfile，可以使用VOLUME []命令可以挂载任意多个共享目录，以json的格式，多个目录逗号隔开。 1234FROM centosVOLUME [\"/data1\",\"/data2\"]CMD echo \"finished-----SUCCESS\"CMD /bin/bash 使用docker build命令通过Dockerfile构建一个镜像docker build的基本语法：docker build [OPTIONS] PATH | URL | - -f,--file 指定Dockerfile的路径名 -t,--tag 指定镜像的REPOSITORY 和标签 常用的写法：docker build -f /Dcokerfile文件的路径 -t 仓库:标签 123456789101112131415161718192021[root@localhost docker]# docker build -f /home/huangxin/docker/Dockerfile -t xust-hx/centos .Sending build context to Docker daemon 2.048 kBStep 1/4 : FROM centos ---&gt; 67fa590cfc1cStep 2/4 : VOLUME /data1 /data2 ---&gt; Running in 296561fadbc5 ---&gt; da4cfb9f98d5Removing intermediate container 296561fadbc5Step 3/4 : CMD echo \"finished-----SUCCESS\" ---&gt; Running in 668697ef3ba4 ---&gt; ec2bf3c54a54Removing intermediate container 668697ef3ba4Step 4/4 : CMD /bin/bash ---&gt; Running in 5b3d43b5114a ---&gt; e61c27683817Removing intermediate container 5b3d43b5114aSuccessfully built e61c27683817[root@localhost docker]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZExust-hx/centos latest e61c27683817 13 seconds ago 202 MBxust/tomcat 1.0.0 71a1320815f5 19 hours ago 506 MB 可以看到我们的镜像构建成功了，下来我们来启动基于我们构建镜像的一个容器。 1[root@localhost docker]# docker run -it e61c27683817 /bin/bash 使用ls查看，发现容器中自动就挂载了两个文件夹data1,data2 但是这两个文件夹对应在主机上的什么地方呢？使用docker inspect来看看这个运行中的容器的详细信息 可以看到，docker对于使用VOLUME挂载的共享目录，在主机中会有一个默认的文件夹——&quot;/var/lib/docker/volumes/。在这个文件夹下你有挂载几个，docker就默认给你生成几个对应的共享目录。 1234[root@localhost huangxin]# cd /var/lib/docker/volumes/402caff5bb629320e524e8239b4ca121be7d11ce4df4b55b657bdcfdc549b543/_data[root@localhost _data]# pwd/var/lib/docker/volumes/402caff5bb629320e524e8239b4ca121be7d11ce4df4b55b657bdcfdc549b543/_data[root@localhost _data]# vim Demo1.txt 还是一样随便写点东西，然后去容器中的data1目录看看有没有Demo1.txt以及内容。 12345[root@6f062b92cccb /]# cd data1[root@6f062b92cccb data1]# lsDemo1.txt[root@6f062b92cccb data1]# cat Demo1.txtHello,this is host of data1! 容器之间共享数据让容器之间共享数据首先启动一个父容器(启动我们刚才制作的那个镜像) 12345[root@localhost docker]# docker run -it --name centos01 e61c27683817 [root@a5c471c5b738 /]# lsanaconda-post.log bin data1 data2 dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var//在data1目录下新建centos01.txt[root@a5c471c5b738 /]# vi centos01.txt 在centos01.txt中随便写点东西，然后在启动同样容器时候使用命令参数：--volumes-from来和父容器共享数据: 1234567891011121314[root@localhost docker]# docker run -it --name centos02 --volumes-from centos01 e61c27683817 [root@fec297cd7c00 /]# ls anaconda-post.log bin data1 data2 dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@fec297cd7c00 /]# cd data1[root@fec297cd7c00 data1]# vim centos02.txt//在centos02.txt中随便写点东西//再启动另一个容器挂载到centos01上[root@fec297cd7c00 data1]# [root@localhost docker]# docker run -it --name centos03 --volumes-from centos01 e61c27683817 [root@1a8862870583 /]# cd data1[root@1a8862870583 data1]# lscentos01.txt centos02.txt[root@1a8862870583 data1]# vi centos03.txt//同样在centos03.txt中随便写点东西 最终达到的效果：父子容器都可以互相共享各自的数据： 那么如果我们删除了父容器，父容器以前共享的数据还在吗？子容器之间的共享还会有吗？来，一张图回答这个问题： Volume的作用/特点最后通过这几个示例可以终结出docker提供的数据卷的特点如下： 通过数据卷可以在容器之间实现数据的共享和重用 对数据卷的修改会立马生效(非常适合作为开发环境) 对数据卷的更新,不会影响镜像 数据卷会一直存在,直到没有容器使用才会被清除 Dockerfile基础Dockerfile是什么？Dockerfile是一个包含用于创建镜像的命令的文本文档。Docker通过读取Dockerfile中的指令自动生成镜像。Docker build命令用于从Dockerfile构建镜像。可以在docker build命令中使用-f参数指向文件系统中任何位置的Dockerfile。 Dockerfile的解析过程？1.Dockerfile中第一条指令必须是FROM 指令，它的作用是指定将要生成的镜像的基础镜像，类似于java中的继承。因此Dockerfile执行的第一步就是加载基础镜像；2.加载完基础镜像后，后面的指令按照定义的顺序从上到下依次执行，每执行一条指令都会对容器做一些修改；3.执行类似docker commit的操作提交一个新的镜像层；4.docker再基于刚提交的镜像运行一个新容器；5.执行Dockerfile中的下一条指令直到所有指令都执行完成； Dockerfile、Docker镜像、Docker容器三者的关系 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段： Dockerfile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态。 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。 Dockerfile保留字指令FROM &nbsp;&nbsp;指定基础镜像,要建立的新镜像是基于那个镜像的,必须是Dockerfile中的第一个命令 12345格式： FROM &lt;image&gt;[:&lt;tag&gt;] FROM &lt;image&gt;[@&lt;digest&gt;]示例： FROM tomcat:8.5.3 MAINTAINER &nbsp;&nbsp;镜像维护者的信息 12345格式： MAINTAINTER &lt;info&gt;示例： MAINTAINTER zhangsan@163.com MAINTAINTER 张三 RUN &nbsp;&nbsp;容器构建是需要运行的命令 12345格式： RUN &lt;command&gt; #shell执行 RUN [\"executable\", \"param1\", \"param2\"] #exec执行示例： RUN yum install -y vim EXPOSE &nbsp;&nbsp;容器运行后对外暴露的端口 1234格式： EXPOSE &lt;port&gt; [&lt;port&gt;...]示例： EXPOSE 8080 3306 WORKDIR &nbsp;&nbsp; 指定容器创建后，终端默认登录进来的工作目录,类似于cd命令 123456格式： WORKDIR /path示例： WORKDIR / #此时工作目录为容器的根目录 WORKDIR /tmp #此时工作目录为容器的/tmp目录 WORKDIR /aaa #此时工作目录为容器的/tmp/aaa ENV &nbsp;&nbsp;用来在构建镜像的过程中设置环境变量 123456格式： ENV &lt;key&gt; &lt;value&gt; #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量 ENV &lt;key&gt;=&lt;value&gt; ... #可以设置多个变量，每个变量为一个\"&lt;key&gt;=&lt;value&gt;\"的键值对，如果&lt;key&gt;中包含空格，可以使用\\来进行转义，也可以通过\"\"来进行标示；另外，反斜线也可以用于续行示例： ENV JAVA_HOME /usr/local/jdk1.8.0_171 ENV CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ADD &nbsp;&nbsp;该命令将复制指定本地目录(src)中的文件到容器中的指定目录(det)中，src可以是是一个绝对路径，也可以是一个URL或一个tar文件，tar文件会自动解压为目录。 123456格式： ADD &lt;src&gt; &lt;dest&gt; ADD [\"&lt;src&gt;\",\"&lt;dest&gt;\"] #用于支持包含空格的路径示例： ADD jdk-8u171-linux-x64.tar.gz /usr/local #ADD [\"jdk-8u171-linux-x64.tar.gz\",\"/usr/local\"] 和上面的作用一样 COPY &nbsp;&nbsp;功能类似ADD，但是是不会自动解压文件，也不能访问网络资源VOLUME &nbsp;&nbsp;容器数据卷，用于数据保存和持久化，不多说上面有详细的介绍 1234格式： VOLUME [\"/path/to/dir\"] #可以写多个挂载目录，中间用逗号隔开示例： VOLUME [\"dataVolume1\",\"dataVolume2\"] CMD &nbsp;&nbsp;指定一个容器启动时要执行的命令 ，Dockerfile中可以有多个CMD指令，但是只有最后一个CMD命令会生效，并且Dockerfile中的CMD命令会被docker run命令之后的参数替换 12345678格式： CMD [\"executable\",\"param1\",\"param2\"] (执行可执行文件，优先) CMD [\"param1\",\"param2\"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数) CMD command param1 param2 (执行shell内部命令)示例： CMD [\"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh\",\"run\"] CMD [\"/bin/bash\"] CMD cd /bin/bash ENTRYPOINT &nbsp;&nbsp;指定一个容器启动时要执行的命令，和CMD一样，都是在指定容器动程序以及参数，但是他和CMD的区别是他会追加docker run后面的命令而不是覆盖。 123456格式： ENTRYPOINT [\"executable\", \"param1\", \"param2\"] (可执行文件, 优先) ENTRYPOINT command param1 param2 (shell内部命令)示例： ENTRYPOINT [\"/usr/local/apache-tomcat-9.0.8/bin/catalina.sh\",\"run\"] ENTRYPOINT /bin/bash ONBUILD &nbsp;&nbsp;用于设置镜像触发器 1234格式： ONBUILD [INSTRUCTION]示例： ONBUILD ADD . /app/src/ 小试牛刀：使用Dockerfile的保留字构建一个可以构建tomcat的镜像的Dockerfile 12345678910111213141516171819202122232425262728293031#加载基础镜像FROM centos#维护者的信息MAINTAINER Huangxin#赋值jdk和tomcat到目标路径ADD jdk-8u212-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.37.tar.gz /usr/local/#在容器中安装vimRUN yum -y install vim#设置工作路径，就是登陆目录ENV workspace /usr/localWORKDIR $workspace#设置tomcat的环境ENV JAVA_HOME /usr/local/java/jdk1.8.0_212ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINTA_HOME /usr/local/tomcat_home/apache-tomcat-8.5.37ENV CATALINTA_BASE /usr/local/tomcat_home/apache-tomcat-8.5.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#端口号默认为8080EXPOSE 8080#构建成功后打印成功信息CMD echo \"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Successful!&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"#最后启动tomcatENTRYPOINT [\"/usr/local/apache-tomcat-8.5.37/bin/catalina.sh\"] 编写好后使用dcoker命令：docker build -t xust/tomcat:8.5.37 .来构建镜像(docker build默认使用当前目录下的Dockerfile来构建镜像，命令中最后那个点表示当前目录)： 中间经过很多个步骤，一层一层的叠加，最后构建成功了： 使用docker images查看我们构建的镜像：","tags":[{"name":"Docker","slug":"Docker","permalink":"http://easyblog.top/tags/Docker/"}]},{"title":"Docker核心技术（基础篇）","date":"2019-09-18T13:51:30.000Z","path":"2019/09/18/CentOS7配置Docker/","text":"&nbsp;&nbsp; 什么是Docker?&nbsp;&nbsp;&nbsp;&nbsp;Docker是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&nbsp;&nbsp;&nbsp;&nbsp;Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&nbsp;&nbsp;&nbsp;&nbsp;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。&nbsp;&nbsp;&nbsp;&nbsp;简单的说，Docker就是一个开源的应用容器引擎；是一个轻量级的容器技术。使用Docker我们可以把软件打包成一个镜像，在镜像中做好软件的相关配置，然后把镜像发布出去，其他使用者就可以直接使用我们的这个镜像而不需要其他的配置就可是我们的应用跑起来。 &nbsp;&nbsp; Docker三大组成Docker的三大基本组成（要素）：镜像（images）,容器（container）和仓库（repository）。 镜像（Images）Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以重复创建多个容器。用java中的有关概念来解释就是：镜像类似于java中的类，而容器就是这个类的具体的实例。 容器（Container）Docker利用容器独立运行一个或一组应用。容器是用镜像创建的运行实例。它可以被启动、开始、停止、甚至删除，每个容器都是相互隔离的。我们可以把容器看作是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序。 仓库（Repository）仓库是集中存放镜像文件的场所。仓库和仓库组成服务器是有区别的。仓库组成服务器上往往存放着多个仓库，每个仓库中有包含了多个镜像，每个镜像又有不同的标签（tag）.仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是Docker Hub,这里面存放了数量庞大的的镜像。 镜像/容器/仓库三者的关系总结起来就是：Docker本身是一个容器运行载体（管理引擎）。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。images文件可以看做是容器的模板。Docker根据image文件生成容器的实例。至于仓库，就是存放了一堆镜像的地方，我们可以把镜像发布到仓库存储起来，需要的时候从仓库拉取下拉就可以使用了。 &nbsp;&nbsp; CentOS 7安装配置Docker1、在安装前一定要先检查一下你对CentOS的版本：Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。查看的命令如下： 12345[root@localhost huangxin]# uname -r3.10.0-862.el7.x86_64[root@localhost huangxin]# cat /etc/redhat-releaseCentOS Linux release 7.5.1804 (Core) 2、使用yum命令安装docker 1[root@localhost huangxin]# yum install docker 期间会有一个确认提示，直接输入y确认。3、启动Docker,并设置以后开机自动启动 12[root@localhost huangxin]# systemctl start docker #启动[root@localhost huangxin]# systemctl enable docker #设置开始自动启动 4、这时我们可以查看一下docker的有关配置 12[root@localhost huangxin]# docker -v #查看docker的版本[root@localhost huangxin]# docker info #查看docker的详细信息 5、配置阿里云的镜像源这个配置不是必须的，只是配置一下以后使用的时候下载的速度会快很多，而且有时候如果直接使用国外的镜像会导致下载失败的情况也可以这么来配置。具体的方法是：&nbsp;&nbsp;&nbsp;&nbsp;1）、到阿里云的官网直接搜索容器镜像服务&nbsp;&nbsp;&nbsp;&nbsp;2）、点开后一顿注册设置后点击最下面的镜像加速器，然后复制加速器地址&nbsp;&nbsp;&nbsp;&nbsp;3）、复制后来到虚拟机使用命令vim /etc/docker/daemon.json添加刚才阿里云上的加速地址，格式如下： 123&#123; \"registry-mirrors\": [\"https://xxxxxx.mirror.aliyuncs.com\"]&#125; 注意：这里格式一定要正确，标准的json格式,不然服务不能启动 配置后保存并退出vim界面，输入以下命令重新加载配置并重启Docker 12[root@localhost huangxin]# systemctl daemon-reload[root@localhost huangxin]# systemctl restart docker 6、停止docker如果我们想停止docker，可以使用命令systemctl stop docker 1[root@localhost huangxin]# systemctl stop docker &nbsp;&nbsp; Docker常用命令和操作Docker常用的帮助命令docker version &nbsp;&nbsp;&nbsp;&nbsp;查看Docker的版本信息12345678910111213141516171819[root@localhost huangxin]# docker versionClient: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64 Experimental: false docker info &nbsp;&nbsp;&nbsp;&nbsp;显示系统范围的信息123456789101112131415161718192021222324252627282930[root@localhost huangxin]# docker infoContainers: 5 Running: 5 Paused: 0 Stopped: 0Images: 8Server Version: 1.13.1Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: trueLogging Driver: journaldCgroup Driver: systemdPlugins: Volume: local Network: bridge host macvlan null overlaySwarm: inactiveRuntimes: docker-runc runcDefault Runtime: docker-runcInit Binary: /usr/libexec/docker/docker-init-currentcontainerd version: (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)runc version: 9c3c5f853ebf0ffac0d087e94daef462133b69c7 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)Security Options: seccomp WARNING: You're not using the default seccomp profile Profile: /etc/docker/seccomp.json selinuxKernel Version: 3.10.0-862.el7.x86_64....... docker -&nbsp;-help &nbsp;&nbsp;&nbsp;&nbsp;docker的命令帮助123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost huangxin]# docker --helpUsage: docker COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default \"/root/.docker\") -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to (default []) -l, --log-level string Set the logging level (\"debug\", \"info\", \"warn\", \"error\", \"fatal\") (default \"info\") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"/root/.docker/ca.pem\") --tlscert string Path to TLS certificate file (default \"/root/.docker/cert.pem\") --tlskey string Path to TLS key file (default \"/root/.docker/key.pem\") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumesCommands: attach Attach to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes on a container's filesystem events Get real time events from the server exec Run a command in a running ........ ...... 包括我们还可以在具体的命令后面使用--help参数,来获得关于这个命令的详细帮助例如我们可使用docker info -&nbsp;-help来查看关于docker info的命令帮助： 123456789[root@localhost huangxin]# docker info --helpUsage: docker info [OPTIONS]Display system-wide informationOptions: -f, --format string Format the output using the given Go template --help Print usage 可以看到docker info 还可以带-f/-format 和–help参数 镜像操作检索关键字（镜像）使用docker search命令后docker会去Docker Hub去查找镜像，并罗列出在Docker Hub上所有有关的镜像。 12345678910111213141516171819202122232425262728[root@localhost huangxin]# docker search mysqlINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/mysql MySQL is a widely used, open-source relati... 8596 [OK] docker.io docker.io/mariadb MariaDB is a community-developed fork of M... 2985 [OK] docker.io docker.io/mysql/mysql-server Optimized MySQL Server Docker images. Crea... 632 [OK]docker.io docker.io/centos/mysql-57-centos7 MySQL 5.7 SQL database server 62 docker.io docker.io/centurylink/mysql Image containing mysql. Optimized to be li... 61 [OK]docker.io docker.io/mysql/mysql-cluster Experimental MySQL Cluster Docker images. ... 51 docker.io docker.io/deitch/mysql-backup REPLACED! Please use http://hub.docker.com... 41 [OK]docker.io docker.io/tutum/mysql Base docker image to run a MySQL database ... 34 docker.io docker.io/bitnami/mysql Bitnami MySQL Docker Image 33 [OK]docker.io docker.io/schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic back... 28 [OK]docker.io docker.io/prom/mysqld-exporter 22 [OK]docker.io docker.io/linuxserver/mysql A Mysql container, brought to you by Linux... 21 docker.io docker.io/centos/mysql-56-centos7 MySQL 5.6 SQL database server 16 docker.io docker.io/circleci/mysql MySQL is a widely used, open-source relati... 14 docker.io docker.io/mysql/mysql-router MySQL Router provides transparent routing ... 12 docker.io docker.io/arey/mysql-client Run a MySQL client from a docker container 11 [OK]docker.io docker.io/imega/mysql-client Size: 36 MB, alpine:3.5, Mysql client: 10.... 7 [OK]docker.io docker.io/openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 ima... 6 docker.io docker.io/yloeffler/mysql-backup This image runs mysqldump to backup data u... 6 [OK]docker.io docker.io/fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron t... 4 [OK]docker.io docker.io/genschsa/mysql-employees MySQL Employee Sample Database 2 [OK]docker.io docker.io/ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 1 [OK]docker.io docker.io/jelastic/mysql An image of the MySQL database server main... 1 docker.io docker.io/monasca/mysql-init A minimal decoupled init container for mysql 0 docker.io docker.io/widdpim/mysql-client Dockerized MySQL Client (5.7) including Cu... 0 [OK][root@localhost huangxin]# docker search命令可以使用-s参数筛选出STARS数不小于指定数的镜像 123456[root@localhost huangxin]# docker search -s 100 mysqlFlag --stars has been deprecated, use --filter=stars=3 insteadINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/mysql MySQL is a widely used, open-source relati... 8596 [OK] docker.io docker.io/mariadb MariaDB is a community-developed fork of M... 2985 [OK] docker.io docker.io/mysql/mysql-server Optimized MySQL Server Docker images. Crea... 632 [OK] 可以看到，下面那些小于100START的镜像就不会显示出来 拉取镜像命令的基本语法是：docker pull [参数] 镜像名[:标签|@DIGEST] 1[root@localhost huangxin]# docker pull redis 这个命令中的tag缺省，在缺省情况下默认下载最新版本的镜像。 查看本地所有的镜像基本的语法：docker images [参数] [REPOSITORY[:TAG]] 1234[root@localhost huangxin]# docker imagesREPOSITORY（仓库） TAG(标签名) IMAGE ID（镜像ID） CREATED（创建日期） SIZE（镜像的大小）docker.io/tomcat latest 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 4 weeks ago 98.2 MB docker images命令后面还可以跟一些参数: -a 查看本地的所有的镜像（包含中间层镜像） -q 只显示镜像ID --digest 显示镜像的摘要信息 12345678910111213[root@localhost huangxin]# docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 4 weeks ago 98.2 MB[root@localhost huangxin]# docker images -qeb0a013292232fb79bc1163c[root@localhost huangxin]# docker images --digestsREPOSITORY TAG DIGEST IMAGE ID CREATED SIZEdocker.io/tomcat latest sha256:80db17f3efd9cdcd9af7c799097fe0d223bbee8f25aa36234ab56292e3d8bd7b 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest sha256:9755880356c4ced4ff7745bafe620f0b63dd17747caedba72504ef7bac882089 f7302e4ab3a8 4 weeks ago 98.2 MB 删除指定的本地镜像基本的命令语法：docker rmi [参数] 镜像名1/镜像ID1 [镜像名2/镜像ID2...] 1[root@localhost huangxin]# docker rmi tomcat 一次删除多个镜像：docker rmi -f 多个镜像名/镜像ID ,其中-f表示强制删除，多个镜像之间空格隔开。 123456789101112[root@localhost huangxin]# docker rmi -f a00bc560660a 2fb79bc1163cUntagged: docker.io/rabbitmq:latestUntagged: docker.io/rabbitmq@sha256:dc853667e768ad1f35625f0337eede5de81ddcca452cf85436c9be2da8657723Deleted: sha256:a00bc560660a5519eee2356f87b76091f39c27ae2d3e595169b4ef97bec4c9fbUntagged: docker.io/rabbitmq:managementUntagged: docker.io/rabbitmq@sha256:f20a3a019241e53aaf98d4133f7781b6d9811d256ff1d755b5aab00855007d5bDeleted: sha256:2fb79bc1163c8003dc25438c32d472ac3034900b86bd5a17b421abdd32fb4496Deleted: sha256:9222d87e80ed54151a186ba2a1e2702008c1e0fce425b7e671e6de0751b005bcDeleted: sha256:2093e80d5f422868e454b8551a268d5892702b74e1e82326f015f6e68c0e2400Deleted: sha256:462c555fe32ac61371c4d1dba2ea30d51e3e803b7c4b0e9d84bf0afa4d938969Deleted: sha256:e0f0f24c7303048f18ce79f408f83ba1ecb49f0c94dc38c0c47e6aa7a38b6b2cDeleted: sha256:742c3e7ab1e9c7242d735106cd62e9efba28105c82b50b06b5a4a8f3a60a5b4f 删除本地的所有镜像：docker rmi -f ${docker images -q} 容器操作新建并启动容器命令的基本语法：docker run [操作参数] 镜像名/镜像ID [指令] [参数...]docker run 命令常用的参数有： --name 容器的新名字 给容器起一个名字，没有指定时会默认生成一个随机的字符串 -d 后台运行运行容器，并返回容器的ID -i 以交互式的方式运行容器 -t 为容器重新分配一个伪输入终端，通常会与-i配合使用 -P 随机端口映射 -p 指定端口映射，有以下四种格式：&nbsp;&nbsp;&nbsp;1.ip:hostPort:containerPort&nbsp;&nbsp;&nbsp;2.ip::containerPort&nbsp;&nbsp;&nbsp;3.hostPort:containerPort (常用的格式)&nbsp;&nbsp;&nbsp;4.containerPort 例如：在后台启动tomcat,并把虚拟机的25050端口映射到容器的8080端口 12[root@localhost huangxin]# docker run --name Tomcat -d -p 25050:8080 tomcat:latest239057353cedab1dfc26b921b237580f72009d7710008772d5a2a3befd539324 查看容器命令的基本语法：docker ps [操作参数]docker ps 常用的命令参数有： -a docker ps命令默认显示当前运行中的容器，加上-a参数会显示会有所有的容器（包括停止的、退出的） -l 显示最近一次启动的容器 -n 值 显示最近指定值次数启动的容器，比如 docker ps -n 2 ,表示显示最近两次启动的容器 -q 仅仅显示所有运行中的容器容器ID -s 显示所有运行中的容器的文件大小 示例： 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost huangxin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ESeea2f65ecd70 90cce17c1af8 \"docker-entrypoint...\" 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ESeea2f65ecd70 90cce17c1af8 \"docker-entrypoint...\" 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql[root@localhost huangxin]# docker ps -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01[root@localhost huangxin]# docker ps -n 2CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES[root@localhost huangxin]# docker ps -qff15f2f20b325e68d3980e15eea2f65ecd7016fe5da80056e3a6146e9ee4[root@localhost huangxin]# docker ps -sCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZEff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01 37.2 kB (virtual 225 MB)5e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 32.8 kB (virtual 486 MB)eea2f65ecd70 90cce17c1af8 \"docker-entrypoint...\" 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq 123 B (virtual 179 MB)16fe5da80056 redis:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-server 0 B (virtual 98.2 MB)e3a6146e9ee4 mysql:latest \"docker-entrypoint...\" 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 62 B (virtual 445 MB) 停止/退出运行中的容器 退出容器：exit（停止容器并退出）或使用快捷键Ctrl+P+Q（容器不停止并退出，相当于让容器后台运行） 停止容器：docker stop [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...] 强制停止容器: docker kill [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]例如：停止ES可以这么写：123456[root@localhost huangxin]# docker stop ESES[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Exited (143) 15 seconds ago ES 启动容器基本的命令语法：docker start [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]这里的启动这个docker run的功能不太一样，docker start是指启动一个已经停止的容器，而docker run是指创建出一个容器（这个容器还不存在）并启动它。示例：启动刚才停止的ES 123456[root@localhost huangxin]# docker start ESES[root@localhost huangxin]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 17 seconds 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 重启容器基本的命令语法：docker restart [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]示例：重启zookeeper 123456[root@localhost huangxin]# docker restart zookeeper01zookeeper01[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 9 seconds 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b \"/docker-entrypoin...\" 5 days ago Up 6 minutes 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 删除容器基本语法是：docker rm [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]注意：docker rm 删除的容器必须是不在运行状态的容器，如果想直接删除一个运行中的容器可以使用-f参数执行强制删除。 1234[root@localhost huangxin]# docker rm ESError response from daemon: You cannot remove a running container 5e68d3980e15f41d97662241c3bd022b3fcb9c4912761f50212c2ce2d6213e9f. Stop the container before attempting removal or use -f[root@localhost huangxin]# docker rm -f ESES docker rm支持一次删除多个容器，例如批量删除本地所有的容器： 1[root@localhost huangxin]# docker rm $&#123;docker ps -aq&#125; 解释一下这个组合命令:docker ps -aq可以返回本地所有的容器ID，然后把它传给docker rm执行批量删除。 查看容器的日志基本语法是：docker logs [操作参数] 容器名/容器IDdocker logs命令常用的参数：-t 加入时间戳-f 跟随最新的日志打印--tail 值 显示最后多少条日志 1[root@localhost huangxin]# docker logs 239057353ced 打印的日志： 查看容器内运行的进程命令：docker top 容器名/容器ID [ps OPTIONS] 1234[root@localhost huangxin]# docker top mysqlUID PID PPID C STIME TTY TIME CMDpolkitd 6565 6548 0 Sep17 ? 00:16:43 mysqldroot 6895 6879 0 Sep17 pts/1 00:00:00 bash 获取容器/镜像的元数据命令：docker inspect [操作参数] 容器名1|容器ID1 [容器名2|容器ID2...]使用这个命令可以查看容器内部的各种信息，docker会以json串的形式返回结果,例如查看mysql这个容器的内部细节： 123456789101112[root@localhost huangxin]# docker inspect mysql[ &#123; \"Id\": \"e3a6146e9ee47230bb6f6df49f23db31cbd570c40e8125654443de42e02c4b79\", \"Created\": \"2019-09-10T10:48:43.201901131Z\", \"Path\": \"docker-entrypoint.sh\", \"Args\": [ \"mysqld\" ], \"State\": &#123; \"Status\": \"running\",..... 进入容器并且在容器中以命令行的方式交互 命令1：docker exec [操作参数] 容器名/容器ID COMMAND [ARG...] 命令2：docker attach [操作参数] 容器名/容器ID 这两个命令的区别是：docker exec是在容器中打开新的终端并且启动新的线程，docker attach 是直接进入容器并启动终端，不会启动新的线程。示例：使用docker exec命令进入到mysql容器的命令行界面： 1234567891011121314151617181920212223242526[root@localhost huangxin]# docker exec -it mysql mysql -uroot -pEnter password: #输入数据库密码Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 14Server version: 8.0.17 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.13 sec)mysql&gt; 容器与主机之间的数据拷贝命令：把容器的数据拷贝到主机上：docker cp [操作参数] 容器名/容器ID:源路径 目的路径|-把主机上的数据拷贝到容器：docker cp [操作参数] 源路径|- 容器名/容器ID:目的路径示例：把mysql的一个库中的数据拷贝到主机的/Desktop 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost huangxin]# docker exec -it mysql /bin/bash #相当于windows上打开mysql的安装目录root@e3a6146e9ee4:/# mysql -uroot -p 密码 #进入数据库Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 15Server version: 8.0.17 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; create database xust; #创建一个数据库xustQuery OK, 1 row affected (0.12 sec)#之后借助数据库工具创建了一张Students表mysql&gt; select * from students;+-------------+----------+----------+---------+| s_id | s_name | major_in | s_class |+-------------+----------+----------+---------+| 20190808001 | zhangsan | aas | casss 1 || 20190808002 | lisi | dad | casss 1 || 20190808003 | wangwu | ad | casss 3 || 20190808004 | lixiaoer | ad | casss 4 || 20190808005 | tom | ad | casss 5 |+-------------+----------+----------+---------+5 rows in set (0.00 sec)#使用Ctrl+P+Q快捷键退出数据库root@e3a6146e9ee4:/# mysqldump -u root -p 'xust'&gt;xust.sql #导出数据库数据Enter password: #之后使用ls命令就可以看到导出的脚本文件,使用pwd xust.sql查看一下他的路径,我的xust.sql文件的路径是/# 退出容器后将容器内文件拷贝到宿主机[root@localhost huangxin]# docker cp mysql:/xust.sql /Desktop/ #将容器中的xust.sql脚本文件复制到主机的/Desktop/目录下 导出的数据表： 由容器实例生成镜像（container-&gt;image）命令语法：docker commit [操作参数] 容器名/容器ID [仓库名[:标签名]]docker commit命令常用的参数： -a 指定作者名 -m 提交描述 示例：在tomcat容器中部署自己的网页,然后把它打包成一个镜像1.首先把一个项目www拷贝到CentOS的/home/huangxin/Desktop/目录下,然后进入运行中的tomcat的容器内部 1234[root@localhost Desktop]# docker exec -it 6f1bb2d2118d /bin/bashroot@6f1bb2d2118d:/usr/local/tomcat# ls #使用ls会看到我熟悉的目录，比如webappsBUILDING.txt LICENSE README.md RUNNING.txt conf lib native-jni-lib webappsCONTRIBUTING.md NOTICE RELEASE-NOTES bin include logs temp work 2.进入webapps，使用pwd得到webapps的路径记下来 12root@6f1bb2d2118d:/usr/local/tomcat# pwd/usr/local/tomcat/webapps 3.退出容器使用docker的复制命令把/home/huangxin/Desktop/www复制到容器中 1[root@localhost Desktop]# docker cp www 6f1bb2d2118d:/usr/local/tomcat/webapps 可以在虚拟机的localhost:25050/www来访问我们定制的网页： 接下来我们把这个定制的Tomcat容器打包成一个镜像4.把我们定制的这个tomcat打包成一个镜像 1234567891011[root@localhost Desktop]# docker commit -m=\"A tomcat with my site\" -a=\"Huangxin\" 6f1bb2d2118d xust/tomcat:1.0.0sha256:71a1320815f58ac6f71d8fbf8823dfff091f1561ce9cec7e9cac2bc32f2fe619[root@localhost Desktop]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZExust/tomcat 1.0.0 71a1320815f5 11 seconds ago 506 MB #这个是我们的tomcatdocker.io/zookeeper latest eb0a01329223 5 days ago 225 MBdocker.io/rabbitmq 3.8-rc-management 90cce17c1af8 9 days ago 179 MBdocker.io/tomcat latest 96c4e536d0eb 4 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 5 weeks ago 98.2 MBdocker.io/mysql latest 62a9f311b99c 5 weeks ago 445 MBdocker.io/elasticsearch latest 5acf0e8da90b 12 months ago 486 MB 5.在虚拟机80端口启动我们定制的tomcat，然后访问localhost:/www 1234567891011[root@localhost Desktop]# docker run --name mytomcat -d -p 80:8080 71a1320815f5292830f2988b094ebd720aa438311f26e9a756bd6bdfca50abd01d7b81a2c228[root@localhost Desktop]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS #我们定制的tomcat启动了并映射在虚拟机的80端口 NAMES292830f2988b 71a1320815f5 \"catalina.sh run\" 12 seconds ago Up 11 seconds 0.0.0.0:80-&gt;8080/tcp mytomcat6f1bb2d2118d tomcat:latest \"catalina.sh run\" 2 hours ago Up 2 hours 0.0.0.0:25050-&gt;8080/tcp cranky_aryabhataff15f2f20b32 eb0a01329223 \"/docker-entrypoin...\" 3 days ago Up 6 hours 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01eea2f65ecd70 90cce17c1af8 \"docker-entrypoint...\" 7 days ago Up 7 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest \"docker-entrypoint...\" 9 days ago Up 9 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest \"docker-entrypoint...\" 9 days ago Up 9 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 后记&nbsp;&nbsp;&nbsp;&nbsp;至此，docker的基本常用命令就介绍到这里了，使用后我个人的直观的感受是这个东西确实非常方便。然而这里仅仅是介绍了一些常用的命令，Docker中还有许多的命令这里没有介绍到，具体的可以参考Docker技术文档，而且我们也可以参考docker.hub上每个镜像官方给出的配置方法，方法很多这里就不一&nbsp;一介绍了。","tags":[{"name":"Docker","slug":"Docker","permalink":"http://easyblog.top/tags/Docker/"}]},{"title":"Spring Boot + Eureka 实现微服务负载均衡","date":"2019-09-17T12:57:52.000Z","path":"2019/09/17/Spring Boot + Eureka 实现微服务负载均衡/","text":"&nbsp;&nbsp; 什么是Eureka？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka这个单词原本的意思就是“我发现了，我找到了”，然而他在Spring中的功能也和他的本意是一样的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka是netflix的一个子模块，也是核心模块之一，Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非常重要的，有了服务发现和注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务，而不需要修改服务调用的配置文件了，功能类似于dubbo的注册中心，比如zookeeper。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringCloud封装了Netflix公司开发的Eureka模块来实现服务注册时和发现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka采用了C-S的设计架构。Eureka Server作为服务注册功能的服务器，它是服务注册时中心。而系统中的其他微服务，使用eureka的客户端连接到eureka server并维持心跳连接。这样系统的维护人员就可以通过eureka server来监控系统中各个微服务是否正常运行。SpringCloud的一些其他模块就可以通过eureka server来发现系统中的其他微服务，并执行相关的逻辑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka包含两个组件：Eureka Server和Eureka Client。Eureka Server提供服务注册服务。各个节点启动后，会在Eureka Server中进行注册，这样Eureka server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka client是一个java客户端，用于简化eureka server的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表把这个服务节点移除。Eureka的三大角色： Eureka server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到。 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务。 总结起来就是说： Eureka是Netflix开源的一个RESTful服务，主要用于服务的注册发现。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。 Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。 Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 &nbsp;&nbsp; 搭建一个基于Spring Boot + Eureka的微服务工程工程的搭建我使用IDEA，首先新建一个空工程【Empty project】,选择空工程点击【next】，之后我们需要在这个工程中建立三个子模块，分别是euraka-server注册中心，poervider服务提供者，customer消费者。新建一个空工程 在新建项目的时候我们可以使用【Spring Initializr】，在新建eurake-server模块的时候选上Eureka Server，新建provider和customer模块的时候可以选上Web的satrter和Eurake Discovery Client的satrter 建好后的项目结构： &nbsp;&nbsp; Eureka Server—注册中心的配置12345678910server: port: 8761eureka: instance: hostname: eureka-service #配置Eureka的主机名 client: register-with-eureka: false #不把自己注册到Eureka fetch-registry: false #不从Eureka获取注册信息 service-url: defaultZone: http://localhost:8761/eureka/ 在Eureka Server的启动类上使用@EnableEurekaServer开启Eureka服务 1234567891011121314151617181920package com.xust.iot.eureka.service;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * 注册中心：服务提供把服务注册到注册中心，消费者可以在注册中心发现他需要的服务 * 1.在application.yml文件中配置Eureka有关的配置 * 2.使用@EnableEurekaServer 注解开启Eureka服务 */@EnableEurekaServer //开启Eureka服务@SpringBootApplicationpublic class EurekaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServiceApplication.class, args); &#125;&#125; 配置好后启动enureka-server，它将会在配置的端口8761启动，输入http://localhost:8761就可一个看到enureka-server的管理界面： &nbsp;&nbsp; Service Provider—服务提供方的配置在服务提供方的配置文件中配置如下信息： 1234567891011121314debug: trueserver: port: 8080 #服务的端口eureka: instance: prefer-ip-address: true #注册时使用ip进行注册 client: service-url: defaultZone: http://localhost:8761/eureka/ #服务将会按照这个路径注册到eureka server中spring: application: name: provider #服务的名字 实现一个服务，TicketService 12345678910@Servicepublic class TicketService &#123; private Logger log= LoggerFactory.getLogger(TicketService.class); public String order(int num)&#123; log.info(\"8080卖出\"+num+\"张票\"); return \"现在 ——G8888次——&gt; 未来\"; &#125;&#125; Eureka的底层还是基于HTTP协议的，在消费者端要调用服务提供方的服务时，实际是通过HTTP请求的方式来调用的，因此需要在服务提供方给对应的service提供对应的controller。TicketController如下： 123456789101112@Controllerpublic class TicketController &#123; @Autowired TicketService ticketService; @ResponseBody @RequestMapping(value = \"/ticket\",method = RequestMethod.GET) public String getTicket(@RequestParam(value = \"num\",defaultValue = \"1\") int num)&#123; return ticketService.order(num); &#125;&#125; 最后在服务提供方的启动类上使用@EnableEurekaClient来告诉Spring这是Eureka的Cilent端，这个服务要注册到注册中心上去。（也可以使用@EnableDiscoveryClient注解，这两个注解的作用是相同的，但是还是有差别的，具体的可以参考@EnableDiscoveryClient与@EnableEurekaClient 区别）。 1234567891011/** * 服务提供者 */@EnableEurekaClient@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; 配置完成后启动Server Provider（注意在启动Client端的服务时Eureka Server要保持运行），启动后可以正常访问http://localhost:8080/ticket,并且在注册中心可以看到8080端口的PROVIDER实例已经注册了就算是成功了。 我们可以开启多个服务提供方，方法是把当前的provider使用Maven命令(mvn install)打包成可执行jar包，然后在把server.port改成另一个端口再使用Maven命令打包后运行…下面是我启动了两个provider，分别在8080和8081端口 &nbsp;&nbsp; Service Customer—服务消费方的配置在服务消费方的配置文件中配置如下内容： 12345678910111213debug: truespring: application: name: customereureka: instance: prefer-ip-address: true #使用ip地址注册实例 client: service-url: defaultZone: http://localhost:8761/eureka/server: port: 8020 在服务消费方的启动类上使用@EnableDiscoveryClient注解告诉SpringBoot把这个服务注册到注册中心。并且注册RestTemplate到IoC容器中，可以使用他来远程调用服务提供方的服务。 12345678910111213141516171819/** * 消费者发现服务,并消费这些服务 */@EnableDiscoveryClient //开启发现服务的功能@SpringBootApplicationpublic class CustomerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CustomerApplication.class, args); &#125; @LoadBalanced //开启负载均衡 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 编写一个controller使用 RestTemplate来调用服务提供方的注册在服务中心的服务。 123456789101112131415161718@Controllerpublic class UserController &#123; @Autowired RestTemplate restTemplate; @ResponseBody @RequestMapping(value = \"/buy\",method = RequestMethod.GET) public String sellTicket(@RequestParam(value=\"num\",defaultValue = \"1\") int num, @RequestParam(value = \"name\",defaultValue = \"\") String name)&#123; //使用RestTemplate提供的方法来获得目标服务，第一个参数是目标服务的url：http://服务提供者名/请求的服务 //这里使用getForObject通过http获得目标服务，与之相同的还有getForEntity(),这两个都是用get请求获得目标服务 //使用postForObject、postForEntity、postForLocation可以使用post请求的方式获的目标服务 String s = restTemplate.getForObject(\"http://PROVIDER/ticket?num=\" + num, String.class); return name+\"买了\"+num+\"张票\"+\"\\n\"+s; &#125;&#125; 最后启动服务消费方看看效果吧！ 首先我们可以访问http://localhost:8761/，可以在注册中心看到消费方也在注册中心注册了： 我们接着访问http://localhost:8020/buy?name=李四&amp;num=6就可以看到下面的页面： 微服务负载均衡的体现把另一个打包的可执行jar包在命令行使用java -jar 命令运行，注意不要让端口冲突。让两个服务提供方同时运行，然后我们访问http://localhost:8020/buy?name=李四&amp;num=6，不断改变num的值查看控制台的打印 发现这两个端口交替工作的，从而达到了一个负载均衡的作用。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Security—认证和授权","date":"2019-09-16T03:25:42.000Z","path":"2019/09/16/SpringSecurity/","text":"认证（Authentication）：建立声明主体的过程。一般也就是指用户登录，表示让系统知道你的存在。授权（Authorization）：确定一个主体是否允许在你的应用程序里执行一个运动的过程，也就是赋予你用户能干什么。 &nbsp;&nbsp; 引入必要的pom文件这一步可以使用Spring Boot的初始化向导在新建工程的时候选上需要的starter，然后初始化向导就会自定引入选择的starter。或者你也可以在你已经建好的项目上直接粘贴复制下面的pom依赖到你的项目的pom文件中。 12345678910111213141516&lt;!--spring security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf对spring-security的支持包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; &nbsp;&nbsp; 配置使用Spring Security首先我们先搭建实验环境。 导入HTML页面具体的页面由于比较多而且又很简单的那种，所以这里就不贴出来了，这里仅仅是用于演示效果。 编写一个controller用于控制页面之间的跳转KufuController.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.xust.iot.security.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class KufuController &#123; private static final String PREFIX=\"pages\"; @RequestMapping(value = \"/\") public String index() &#123; return \"welcome\"; &#125; @RequestMapping(value = \"/userlogin\") public String login()&#123; return PREFIX+\"/login\"; &#125; @RequestMapping(value = \"/level1/&#123;page&#125;\") public String toLevel11(@PathVariable(\"page\")int page) &#123; return PREFIX+\"/Level1/\"+page; &#125; @RequestMapping(value = \"/level2/&#123;page&#125;\") public String toLevel24(@PathVariable(\"page\")int page) &#123; return PREFIX+\"/Level2/\"+page; &#125; @RequestMapping(value = \"/level3/&#123;page&#125;\") public String toLevel37(@PathVariable(\"page\")int page) &#123; return PREFIX+\"/Level3/\"+page; &#125;&#125; 这是我的项目结构： 启动SpringBoot看看效果：启动后在浏览器地址栏中输入https://localhost:8080来到welcome页面 配置Spring Security&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot中对Security有很多自动配置，我们要使用它只要编写一个配置类，并且让这个配置类继承自WebSecurityConfigurerAdapter，然后在配置类上使用EnableWebSecurity注解告诉Spring开启WebSecurity功能。以后我们需要定制有关认证和授权的功能的时候只需要重写WebSecurityConfigurerAdapter中的方法，下面是一个例子： 一个简单的Spring Security配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.xust.iot.security.config;import org.springframework.context.annotation.Bean;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;/** * 1、引入spring security的starter * 2、编写配置类继承WebSecurityConfigurerAdapter * 3、在配置类上标注@EnableWebSecurity开启WebSecurity */@EnableWebSecurity //开启Web Securitypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) &#123; //防止静态资源被拦截 web.ignoring().antMatchers(\"/config/**\", \"/css/**\", \"/fonts/**\", \"/img/**\", \"/js/**\"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; //设置Http安全规则 http.authorizeRequests().antMatchers(\"/\").permitAll() //配置认证规则 .antMatchers(\"/level1/**\").hasRole(\"VIP1\") .antMatchers(\"/level2/**\").hasRole(\"VIP2\") .antMatchers(\"/level3/**\").hasRole(\"VIP3\"); //开启自动配置的登录功能 http.formLogin() .usernameParameter(\"username\") //指定提交的表单中的用户名参数 .passwordParameter(\"password\") //指定提交的表单中的密码参数 .loginPage(\"/userlogin\") //指定自定义的登录页面 .loginProcessingUrl(\"/login\") //指定处理登录请求的url .permitAll(); //开启自动配置的注销功能：注销后来到登录页面 http.logout() .deleteCookies() .logoutSuccessUrl(\"/userlogin\") //注销成功后跳转的页面 .permitAll() .invalidateHttpSession(true); //记住我功能 http.rememberMe().rememberMeParameter(\"remember\").tokenValiditySeconds(60 * 60 * 24 * 7); //关闭Spring提供的CSRF攻击保护，一般不建议这么做 /*http.csrf().disable();*/ &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() /*Spring Security 5.0开始必须要设置加密方式*/ .withUser(\"张三\").password(passwordEncoder().encode(\"123456\")).roles(\"VIP1\", \"VIP2\", \"VIP3\") .and() .withUser(\"李四\").password(passwordEncoder().encode(\"123456\")).roles(\"VIP1\"); &#125; //配置passwordEncoder @Bean public Pbkdf2PasswordEncoder passwordEncoder() &#123; return new Pbkdf2PasswordEncoder(); &#125;&#125; 注意：1、formLogin系统会自动配置/login请求去Spring内部默认的登录页面，如果想改成自己的实现，可以参考上面的配置2、如果登录失败系统默认会重定向到/login/error页面3、如果没有配置允许登录页面任何人可以访问，那么SpringBoot默认的登录页面的username是username，密码会在SpringBoot启动启动的时候自动生成，打印在控制台中。然而还有一种办法即使我们可以配置初始的用户密码，下面是一个配置示例： 123#spring boo默认会对所有的资源进行拦截，所以可以在这里配置个初始的用户名个密码spring.security.user.name=adminspring.security.user.password=123456 然而我们完全不必要这么做，我们可以对公共的资源放开权限就好了，具体的配置方法参照上面的配置。4、SpringBoot2.x抛弃了原来的NoOpPasswordEncoder，要求用户保存的密码必须要使用加密算法后存储，在登录验证的时候Security会将获得的密码在进行编码后再和数据库中加密后的密码进行对比，如果强行使用明码会报错： 在Web页面(HTML中)获得用户的身份、授权信息主要就是利用sec提供的方法。 sec:authorize=”isAuthenticated()”：是否授权成功 sec:authentication=”principal.authorities”：获取用户身份 sec:authentication=”name”：获取用户名字 sec:authorize=”hasRole()”：判断当前身份 要使用这些功能，需要先引入sec的名称空间 1234&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" &lt;!--引入sec名称空间，注意版本冲突的问题--&gt; xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\"&gt; 不同授权的用户会有不同的操作权限，包括可以通过sec提供的这几个方法，动态的获取用户是否授权成功，用户有哪些身份…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt; &lt;div sec:authorize=\"!isAuthenticated()\"&gt; &lt;h2&gt;游客你好，如果想看武林秘籍&lt;a href=\"\" th:href=\"@&#123;/userlogin&#125;\" style=\"text-decoration: none\"&gt;请登录&lt;/a&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div sec:authorize=\"isAuthenticated()\"&gt; &lt;h2&gt;&lt;span sec:authentication=\"name\"&gt;&lt;/span&gt;,你好，你的角色有 &lt;span sec:authentication=\"principal.authorities\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/div&gt;&lt;/center&gt;&lt;form action=\"/logout\" th:action=\"@&#123;/logout&#125;\" method=\"post\"&gt; &lt;!--解决SpringBoot由于CSFR保护而对空post请求的拦截问题--&gt; &lt;!--&lt;input type=\"hidden\" name=\"$&#123;_csrf.parameterName&#125;\" value=\"$&#123;_csrf.token&#125;\"/&gt;--&gt; &lt;button type=\"submit\"&gt;注销&lt;/button&gt;&lt;/form&gt;&lt;hr/&gt;&lt;div sec:authorize=\"hasRole('VIP1')\"&gt;&lt;h3&gt;普通武林秘籍(限VIP1)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level1/1&#125;\" style=\"text-decoration: none\"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level1/2&#125;\" style=\"text-decoration: none\"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level1/3&#125;\" style=\"text-decoration: none\"&gt;武当长拳&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('VIP2')\"&gt;&lt;h3&gt;高级武林秘籍(限VIP2)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level2/4&#125;\" style=\"text-decoration: none\"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level2/5&#125;\" style=\"text-decoration: none\"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level2/6&#125;\" style=\"text-decoration: none\"&gt;梯云纵&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize=\"hasRole('VIP3')\"&gt;&lt;h3&gt;绝世武林秘籍(限VIP3)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level3/7&#125;\" style=\"text-decoration: none\"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level3/8&#125;\" style=\"text-decoration: none\"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\" th:href=\"@&#123;/level3/9&#125;\" style=\"text-decoration: none\"&gt;孤独九剑&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动Spring Boot看看最终的效果：如果你没有登录，那么你将没有任何操作权限，登录后页面可以根据不同的用户的不同授权显示不同的操作权限可以操作的资源。 &nbsp;&nbsp; Demo的Github地址https://github.com/LoverITer/spring-security-test","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SpringBoot之异步任务、定时服务和邮件服务","date":"2019-09-14T12:25:57.000Z","path":"2019/09/14/SpringBoot之任务/","text":"SpringBoot—异步任务&nbsp;&nbsp;&nbsp;&nbsp;异步调用是相对于同步调用而言的，同步调用是指程序按预定顺序一步步执行，每一步必须等到上一步执行完后才能执行，异步调用则无需等待上一步程序执行完即可执行。&nbsp;&nbsp;&nbsp;&nbsp;实现异步处理任务的方式有很多，我们可以自己通过多线程来实现或者也可以使用SpringBoot提供的@EableAysnc和@Aysnc这两个注解来实现。 通过多线程来实现异步处理任务直接在需要异步任务处理的方法中开启新的线程来处理任务。 12345678910111213141516171819202122@Servicepublic class AsyncService &#123; private Logger log= LoggerFactory.getLogger(AsyncService.class); /** * 手动开启一个线程来处理异步任务 */ public void async()&#123; log.info(\"开始处理任务\"); //开启一个新新线程方式来异步处理任务 new Thread(() -&gt; &#123; try &#123; log.info(\"处理中，请稍等...\"); Thread.sleep(3000); //处理过程中 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); log.info(\"任务提前返回，交给另一个线程处理\"); &#125;&#125; 执行结果如下： 使用SpringBoot提供的注解处理异步任务首先在需要异步任务处理的方法上加上@Async注解告诉SpringBoot这个方法需要异步处理 123456789101112131415161718@Servicepublic class AsyncService &#123; private Logger log= LoggerFactory.getLogger(AsyncService.class); @Async //开启异步任务 public void async()&#123; log.info(\"开始处理\"); try &#123; log.info(\"处理中，请稍等...\"); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info(\"处理完成.....\"); &#125;&#125; 然后在主配置类使用@EnableAsync注解开启异步注解功能 1234567891011121314package com.xust.iot.task;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class SpringBootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootTaskApplication.class, args); &#125;&#125; 执行结果如下，SpringBoot也是开启了一个新的线程task-1来处理这个任务的： SpringBoot—定时任务定时任务就是提前设置好时间点，然后每到这个时间点就会执行的任务。SpringBoot中可以通过@Scheduled和@EableScheduled这两个注解来实现定时任务。同样在需要定时任务对方法上标注@Scheduled注解，然后在主配置类上标注@EableScheduled注解开启定时注解功能 123456789101112131415161718192021222324252627@Servicepublic class ScheduledService &#123; private Logger log= LoggerFactory.getLogger(ScheduledService.class); //0 * * * * MON-FRI //秒 分 时 日 月 星期 @Scheduled(cron=\"0 * * * * 1-7\") //星期一~星期天 每分钟的整秒（00秒）执行该任务 public void service1()&#123; log.info(\"执行定时任务service1@\"+ LocalDateTime.now()); &#125; @Scheduled(cron=\"1,11,21,31,41,51 * * * * 1-7\") //星期一~星期天 每分钟的1秒，11秒，21秒，31秒，41秒，51秒的时候执行该任务 public void service2()&#123; log.info(\"执行定时任务service2@\"+ LocalDateTime.now()); &#125; @Scheduled(cron = \"0-5 * * * * 1-7\") //星期一~星期天 每分钟的00秒~05秒执行该任务 public void service3()&#123; log.info(\"执行定时任务service3@\"+ LocalDateTime.now()); &#125; @Scheduled(cron = \"0/5 * * * * 1-7\") //星期一~星期天 从00秒开始每隔5秒执行该任务 public void service4()&#123; log.info(\"执行定时任务service4@\"+ LocalDateTime.now()); &#125;&#125; 执行结果： 从上面这个例子中可以看到，对于定时任务使用主要就是对cron表达式的编写，cron允许的值可以有以下几种： 字段允许值允许的特殊字符 秒0-59, - * / 分0-59, - * / 小时0-23, - * / 日1-31, - * / ? L W C 月1-12, - * / 星期0-7或SUN-STA, - * / ? L W C # 解释： , ：表示枚举，可以用它在一个一段上枚举多个值 — ：表示一个区间 * ：表示任意 / ：步长 ？：日/星期冲突匹配 L ： 最后 W： 工作日 C ： 和Calendar联系后计算后的值 # :星期，例如4#2 表示第二个星期四 下面是几个用法示例： 12345678910111213141516171819202122232425262728293031@Servicepublic class ScheduledService &#123; private Logger log= LoggerFactory.getLogger(ScheduledService.class); @Scheduled(cron=\"0 0/5 14,18 * * ?\") //每天14点整合18点整，每隔5分钟执行一次该任务 public void service5()&#123; log.info(\"执行定时任务service5@\"+ LocalDateTime.now()); &#125; @Scheduled(cron=\"0 30 12 ? * 1-6\") //每月的周一~周六12:30执行一次该任务 public void service6()&#123; log.info(\"执行定时任务service6@\"+ LocalDateTime.now()); &#125; @Scheduled(cron = \"0 0 12 ? * 6L\") //每月的最后一个周六中午12点执行一次 public void service7()&#123; log.info(\"执行定时任务service7@\"+ LocalDateTime.now()); &#125; @Scheduled(cron = \"0 0 12 LW * ?\") //每月的最后一个工作日的12点执行一次 public void service8()&#123; log.info(\"执行定时任务service8@\"+ LocalDateTime.now()); &#125; @Scheduled(cron = \"0 0 6/1 ? * 4#2\") //每月的第二个星期四在六点整开始每隔一小时执行一次 public void service9()&#123; log.info(\"执行定时任务service9@\"+ LocalDateTime.now()); &#125;&#125; SpringBoot—邮件任务 &nbsp; &nbsp; &nbsp; &nbsp;Spring Email 抽象的核心是 MailSender 接口，MailSender 的实现能够把 Email 发送给邮件服务器，由邮件服务器实现邮件发送的功能。 &nbsp; &nbsp; &nbsp; &nbsp;Spring 自带了一个 MailSender 的实现JavaMailSenderImpl，它会使用 JavaMail API 来发送 Email。Spring 或 SpringBoot 应用在发送 Email 之前，我们必须要把JavaMailSenderImpl 装配为 Spring应用上下文的一个 bean。 首先引入邮件服务的starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 邮件配置1234567spring: mail: host: smtp.qq.com #smpt主机 password: ceozdvepgtlydihg #这里的password是生成的授权码，不是账户密码 username: huangxin9830@qq.com #发送邮件的账户名 properties: #properties的值应该是一个Map mail.smpt.ssl: true #设置使用SSL安全协议 简单邮件服务—SimpleMessage使用简单邮件服务只能发送文本消息 1234567891011121314@AutowiredJavaMailSenderImpl mailSender;@Testpublic void contextLoads() &#123; //简单邮件服务 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(\"你好，这是SpringBootMail\"); message.setFrom(\"2489868503@qq.com\"); message.setText(\"Hello JMail!\"); message.setTo(\"2489868503hx@gmail.com\"); mailSender.send(message);&#125; 执行的结果，收到了邮件： 复杂邮件服务—MimeMessage使用复杂邮件服务可以发送文本消息、HTML语句、甚至支持上传附件 12345678910111213141516171819@Test public void test02()&#123; //复杂邮件服务 MimeMessage mimeMessage = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"你好，陌生人！\"); helper.setFrom(\"2489868503@qq.com\"); //HTML语句 helper.setText(\"&lt;font color='red'&gt;你中奖啦！！！&lt;/font&gt;\"，true); helper.setTo(\"2489868503hx@gmail.com\"); //上传附件 helper.addAttachment(\"1.jpg\",new File(\"D:\\\\pic\\\\1.jpg\")); helper.addAttachment(\"2.jpg\",new File(\"D:\\\\pic\\\\2.jpg\")); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; mailSender.send(mimeMessage); &#125; 执行结果：在GMail收到了邮件，并且设置HTML样式起作用了，附件也上传成功了。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SpringBoot之缓存二（使用Redis作为缓存）","date":"2019-09-11T12:57:05.000Z","path":"2019/09/11/SpringBoot与缓存之整合Redis/","text":"&nbsp;&nbsp;&nbsp;&nbsp;在我的上一篇笔记SpringBoot之缓存一（基本的缓存注解）中学习了一下SpringBoot对缓存的处理机制，重点介绍了SpringBoot提供的基于JCache的几个缓存注解的使用，这篇笔记跟随上篇对Redis做一下整合。首先在原有的pom文件的基础上引入Redis的pom依赖： 12345&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; &nbsp;&nbsp;&nbsp;&nbsp;在我的上一篇笔记在我的上一篇笔记SpringBoot之缓存一（基本的缓存注解）中提到过，当我们没有导入其他第三方的缓存的时候，SpringBoot默认给我们实例化的缓存是SimpleCacheConfiguration的对象，如果我们导入了任何其他第三方的缓存，SpringBoot就会自动切换成第三方的缓存。所以在我们导入Redis的starter后要想正常使用缓存，就需要对他做配置在application.yml文件中添加如下基本的配置： 1234567891011121314#Redis配置spring: redis: host: 192.168.92.128 # redis主机 port: 6379 # redis端口 password: # redis密码，默认没有密码 database: 0 # Redis数据库索引，默认是0 jedis: pool: max-active: 8 # 连接池最大连接数，使用负值表示没有限制 max-wait: -1 # 连接池最大阻塞等待时间，默认是负值表示无限等待 max-idle: 5 # 连接池的最大空闲连接 min-idle: 0 # 连接池的最小空闲连接 timeout: 1200 # 连接超时时间(ms) 配置Redis缓存管理器&nbsp;&nbsp;&nbsp;&nbsp;通过配置Spring的CacheManager为redis，即可指定使用redis做缓存，具体的配置方式跟1.0也有所不同，在1.0中使用RedisTemplate即可实例化一个RedisCacheManager：RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);在2.0中删除了这个构造器，同时也不可以通过之前的setDefaultExpiration方法设置默认的缓存过期时间等，在新版本中可以通过以下的两种方式构造一个RedisCacheManager： 通过RedisCacheManager的静态方法create():123456@Beanpublic RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; RedisCacheManager redisCacheManager =RedisCacheManager.create(redisConnectionFactory); return redisCacheManager; &#125; 通过Spring提供的RedisCacheConfiguration类构造一个自己的Redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager： 123456789101112131415161718192021222324252627282930313233343536package com.xust.iot.learningspirngbootcache01.config;import com.xust.iot.learningspirngbootcache01.bean.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import java.net.UnknownHostException;import java.time.Duration;@Configurationpublic class RedisCache &#123; @Bean public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123; //生成默认配置 RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds(60L)); //不缓存空值 redisCacheConfiguration = redisCacheConfiguration.disableCachingNullValues(); //设置序列化 RedisSerializationContext.SerializationPair&lt;User&gt; serializationPair = RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer&lt;User&gt;(User.class)); //把User对象转成JSON格式 redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(serializationPair); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory) // 使用自定义的缓存配置初始化一个cacheManager .cacheDefaults(redisCacheConfiguration) //这里一定要把我们的配置设置成默认的额缓存配置才会有效果 .build(); return cacheManager; &#125;&#125; 在设置的时候有一个坑要特别注意RedisCacheConfiguration是有返回值的，也就是说，每设置一次都要重新复制给RedisCacheConfiguration对应的那个对象，不然设置无效。 启动SpringBoot连续查询几次重复的查询1号User后发现第一次是查的数据库，以后都是去Redis中取得值，而且缓存在Redis中的数据也被格式化为JSON格式了：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SpringBoot之缓存一（基本的缓存注解）","date":"2019-09-09T13:31:35.000Z","path":"2019/09/09/SpringBoot与缓存注解/","text":"&nbsp;&nbsp; JSR-107规范JSP-107是什么？ &nbsp;&nbsp;&nbsp;&nbsp;要回答这个问题，首先要知道JSR是什么，JSR是Java Specification Requests 的缩写 ，Java规范请求，故名思议就是Java规范，大家一同遵守这个规范的话，会让大家‘沟通’起来更加轻松。规范是很重要的 ，举个例子大家都知道红灯停，路灯行吧，如果每个城市的信号灯代表不一样，那就麻烦了，B城市红灯行，绿灯停，C城市甚至出现紫灯行，闪灯行，想想都知道，如果我们保证不出问题，必须知道每个城市的信号等代表的意义。我们一直使用的JDBC就一个访问数据库的一个规范的例子。 而 JSR-107呢就是关于如何使用缓存的规范。 JSR-107核心APIJava Caching定义了5个核心接口，分别是CachingProvider,CacheManager,Cache,Entry和Expiry。CachingProvider用于定义创建、配置、获取、管理和控制CacheManager。CacheManager用于定义了建立，配置，得到，管理和控制有着唯一名字的Cache ，一个CacheManager被包含在单一的CachingProvider。CacheCache是一个Map类型的数据结构，用来存储基于键的数据，很多方面都像java.util.Map数据类型。一个Cache 存在在单一的CacheManager。EntryEntry是一个存在于Cache的key-value键值对Expiry每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy来设置。这些接口之间的关系可以用下图表示： &nbsp;&nbsp; Spring缓存抽象Spring 从3.1版本开始在org.springframework.cache包下定义了Cache和CacheManager接口来统一不同的缓存技术，并使用JCache(JSR-107)注解简化我们的开发。 Cache接口为缓存的组件规范定义，包含缓存的各种操作集合 Cache接口下Spring提供了各种xxxCache的实现，如RedisCache、EncheCache、ConcurrentMapCache…… 每次调用需要缓存功能的方法是，Spring会检查指定的参数的是定目标方法时候已经被调用过，如果有就直接从缓存中获取方法调用后对结果，如果没有就调用方法去数据库查询并缓存结果后返回给用户，下次回直接从缓存中获取。 重要的缓存注解 注解功能 Cache缓存接口，定义缓存操作。 CacheManager缓存管理器。管理和中缓存组件 @Cacheable主要用于方法，能够根据方法的请求参数对其进行缓存 @CachePut方法被调用，并且在调用后结果被缓存，主要用于更新操作 @CacheEvict清除缓存 @EnableCaching开启基于注解的缓存 @Caching配置复杂对缓存策略 @CacheConfig同一配置本类的缓存注解额属性 serialize缓存数据的value序列haul策略 @Cacheable/@CachePut/@CacheEvict 主要的参数 参数解释 value/cacheNames缓存的名字。必须指定至少一个，可以配置多个例如：@Cacheable(value={\"cache1\",\"cache2\"}) key缓存的key。可以为空，如果指定要使用SpEL。默认将方法的所有参数组合起来作为key。例如：@Cacheable(value=\"cache1\",key=\"#id\") keyGenerator定义自动生成主键的策略，使用的时候key和keyGenerator二选一 condition作缓存的条件。可以为空，使用SpEL表达式指定，返回true表示作缓存，否者不缓存。例如：@Cacheable(vlaue=\"cache\",condition=\"#id&gt;0\") unless也是作缓存的条件。当条件为true时，就不缓存（和condition的效果是反的）。例如：@Cacheable(value=\"cache\",unless=\"#id&lt;0\") sync(@Cacheable)是否使用异步支持，这是Spring 4.3以后才支持的,默认值false，不开启异步模式例如：@Cacheable(value=\"cache\",sync=true) //开启异步模式 allEntries(@CacheEvict)是否清空所有缓存内容。默认为false,如果指定为true，则方法调用后将立即清空所有缓存。 beforeInvocation(@CacheEvict)是否在方法执行前清空缓存。默认为false，如果指定为true,则方法还没有执行的时候就清空缓存。默认情况下如果方法抛出异常，就没有办法清空缓存了。 SpEL上下文数据Spring 提供了一些供我们使用的SpEL表达式， 名称位置描述 用法示例 methodName(方法名) root对象 当前被调用的方法名 #root.methodname method(方法) root对象 当前被调用的方法 #root.method.name target(当前对象) root对象 当前被调用的目标对象实例 #root.target targetClass(目标类)root对象 当前被调用的目标对象的类 #root.targetClass args(参数列表) root对象 当前被调用的方法的参数列表 #root.args[0] caches(缓存列表)root对象 当前方法调用使用的缓存列表 #root.caches[0].name Argument Name(参数名)执行上下文 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 #artsian.id result(方法返回值) 执行上下文 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） #result &nbsp;&nbsp; Spring缓存的配置和使用先把基本的实现环境搭建起来首先引入需要的pom依赖12345678910111213141516171819202122232425&lt;!--springboot 缓存--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--数据库连接--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--druid数据源--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 接下来依次配置数据库连接信息、配置Druid数据源，配置MyBatis，这些配置好后就可以使用SpringBoot默认配置的缓存(SimpleCacheConfiguration)了。如果要使用别的第三方缓存，直接在pom文件中导入相应的starter就可以了。SpringBoot默认配置的缓存是SimpleCacheConfiguration： 首先创建一个实体类User1234567public class User implements Serializable &#123; private Integer id; private String name; private Integer age; private String email; //getter 、setter....&#125; 创建Mapper接口(DAO层) UserMapper.java；123456789101112131415161718192021222324package com.xust.iot.learningspirngbootcache01.mapper;import com.xust.iot.learningspirngbootcache01.bean.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserMapper &#123; //增加一个User Integer addOneUser(User usr); //根据id删除一个User boolean deleteUserById(Integer id); //根据id查询一个User User selectUserById(Integer id); //查询所有User List&lt;User&gt; selectAllUser(); //根据id更新一个User boolean updateUserById(@Param(\"id\") Integer id,@Param(\"user\") User user);&#125; 对应的mapper映射文件,UserMapper.xml： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xust.iot.learningspirngbootcache01.mapper.UserMapper\"&gt; &lt;insert id=\"addOneUser\" useGeneratedKeys=\"true\" keyProperty=\"id\" &gt; insert into user(name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;) &lt;/insert&gt; &lt;delete id=\"deleteUserById\" parameterType=\"integer\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;select id=\"selectUserById\" parameterType=\"integer\" resultType=\"com.xust.iot.learningspirngbootcache01.bean.User\"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=\"selectAllUser\" parameterType=\"integer\" resultType=\"com.xust.iot.learningspirngbootcache01.bean.User\"&gt; select * from user &lt;/select&gt; &lt;update id=\"updateUserById\" &gt; update user &lt;set&gt; name=#&#123;user.name&#125;,email=#&#123;user.email&#125;,age=#&#123;user.age&#125; &lt;/set&gt; &lt;/update&gt;&lt;/mapper&gt; 接下来就是今天的主角——service层。首先编写一个Service层的基接口ServiceBase&lt;T&gt;,在这个接口抽取了service层中通用的CRUD方法，如下： 123456789101112public interface ServiceBase&lt;T&gt; &#123; Integer register(T t); boolean delete(Integer id); User get(Integer id); List&lt;User&gt; getAll(); boolean update(Integer id, T t);&#125; 然后定义IUserService接口，让他去继承ServiceBase接口，由于IUserService接口中这里没有定义新的方法，只是个空类（但它任然有存在的意义），这里就不贴出来了。之后定义IUserService接口的实现类UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.xust.iot.learningspirngbootcache01.service.impl;import com.xust.iot.learningspirngbootcache01.bean.User;import com.xust.iot.learningspirngbootcache01.mapper.UserMapper;import com.xust.iot.learningspirngbootcache01.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * @Author: HuangXin * @Date: Created in 15:00 2019/9/9 2019 * @Description: */@Transactional //开启事务@Servicepublic class UserServiceImpl implements IUserService&lt;User&gt; &#123; @Autowired UserMapper userMapper; @Override public Integer register(User user) &#123; return userMapper.addOneUser(user); &#125; @Override public boolean delete(Integer id) &#123; return userMapper.deleteUserById(id); &#125; @Override public User get(Integer id) &#123; return userMapper.selectUserById(id); &#125; @Override public List&lt;User&gt; getAll() &#123; return userMapper.selectAllUser(); &#125; @Override public boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id, user); &#125;&#125; 在SpringBoot的启动类头上添加注解@EnableCaching 开启开启基于注解的缓存配置以及@MapperScan(value = &quot;com.xust.iot.learningspirngbootcache01.mapper&quot;) 扫描com.xust.iot.learningspirngbootcache01.mapper路径下的所有Mapper接口 之后写一个controller,UserController.java 1234567891011121314151617181920212223242526272829303132@Controllerpublic class UserController &#123; @Autowired IUserService&lt;User&gt; iUserService; @ResponseBody @RequestMapping(value = \"/user/&#123;id&#125;\") public User selectUser(@PathVariable(\"id\") Integer id) &#123; return iUserService.get(id); &#125; @ResponseBody @RequestMapping(value = \"/user/add\") public User register(User user) &#123; int id = iUserService.register(user); return user; &#125; @ResponseBody @RequestMapping(value = \"/user/all\") public List&lt;User&gt; showAllUser()&#123; return iUserService.getAll(); &#125; @ResponseBody @RequestMapping(value = \"/user/del/&#123;id&#125;\") public ResponseEntity delete(@PathVariable(\"id\") Integer id)&#123; iUserService.delete(id); return new ResponseEntity(HttpStatus.OK); &#125;&#125; 这样搭建好环境后是没有缓存的，使用缓存的方法有很多种，这里就使用SpringBoot提供的注解来使用缓存 @Cacheable@Cacheable注解会先查询是否已经有缓存，有的话会使用缓存，没有则会执行方法并缓存。 12345@Cacheable(value=\"user\",key = \"#root.methodName+'('+#id+')'\")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; 在CacheAspectSupport这个类的findCachedItem方法上打上断点，观察发现我们配置的key是有效： 自定义主键生成策略1234567891011121314151617package com.xust.iot.learningspirngbootcache01.config;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Arrays;@Configurationpublic class CacheConfig &#123; @Bean(\"userKey\") //bean的名字就是主键生成策略的名字 public KeyGenerator keyGenerator()&#123; //主键策略：方法的hashcode+@+[参数] return (target, method, params) -&gt; method.getName().hashCode()+\"@\"+ Arrays.toString(params); &#125;&#125; 在方法中可以这么使用： 12345@Cacheable(value=\"user\",keyGenerator = \"userKey\")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; 同样，通过打断点发现我们配置的主键生成也起作用了： 其他参数的用法可以参考下面的程序： 1234567891011121314151617181920212223242526 /** *自定义缓存策略，并且只有当返回值不是null的时候才缓存 */@Cacheable(value=\"user\",keyGenerator = \"userKey\",condition = \"#result!=null\")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; /** *自定义缓存策略，并且当返回值是null的时候不缓存，也就相当于上面的写法，只不过unless是判断为false的时候才做缓存 */@Cacheable(value=\"user\",keyGenerator = \"userKey\",unless = \"#result==null\")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; /** *自定义缓存策略，并且开启异步缓存 */@Cacheable(value=\"user\",keyGenerator = \"userKey\",sync = true)@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; @CachePut&nbsp;&nbsp;&nbsp;&nbsp;@CachePut注解的作用主要用于对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 。简单来说就是用户更新缓存数据。但需要注意的是该注解的value 和 key 必须与要更新的缓存相同，也就是与@Cacheable 相同。 123456//方法本调用后，总是会执行方法，返回后如果条件瞒住就来缓存@CachePut(value = \"user\",keyGenerator = \"userKey\",condition = \"#result==true\")@Overridepublic boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id,user);&#125; @CachePut的其他参数的用法和一样@Cacheable参数的用法一样。这里不再赘述。 @CacheEvict@CachEvict 的作用主要用于方法的配置，能够根据一定的条件对缓存进行清空 。 123456789101112131415161718192021222324252627@CacheEvict(value = \"user\",beforeInvocation = false) //默认就是false,会在方法执行后清缓存public boolean delete(Integer id) &#123; int i/0; //这里发生异常了，缓存无法清空 return userMapper.deleteUserById(id);&#125; @CacheEvict(value = \"user\",beforeInvocation = true) //在方法执行前清除缓存@Overridepublic boolean delete(Integer id) &#123; int i/0; //即使这里会发生异常，还是会清空缓存，因为清除缓存是在方法执行前执行的 return userMapper.deleteUserById(id);&#125; @CacheEvict(value = \"user\",allEntries = true) //方法调用后清空所有缓存@Overridepublic boolean delete(Integer id) &#123; return userMapper.deleteUserById(id);&#125;@CacheEvict(value = \"user\",allEntries = false) //默认不清空所有缓存@Overridepublic boolean delete(Integer id) &#123; return userMapper.deleteUserById(id);&#125; @Caching有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。 123456789101112131415 //组合缓存策略，Caching只有下面三个属性@Caching(cacheable = &#123; @Cacheable(value = \"user\", keyGenerator = \"userKey\") &#125;, put = &#123; @CachePut(value = \"user\", keyGenerator = \"userKey\") &#125;, evict = &#123; @CacheEvict(beforeInvocation = true, allEntries = true) &#125; ) @Override public boolean delete(Integer id) &#123; return userMapper.deleteUserById(id); &#125; @CachingConfig当我们需要缓存的地方越来越多，你可以使用@CacheConfig(cacheNames = {“cacheName”})注解来统一指定value/cacheNames的值，这时可省略value/cacheNames，如果你在你的方法依旧写上了value/cacheNames，那么依然以方法的@CacheConfig配置的值为准。使用方法如下： 12345678910111213141516171819@CacheConfig(cacheNames = \"user\") //在类名头上只用@CacheConfig来指定这个类全局的缓存的名字@Servicepublic class UserServiceImpl implements IUserService&lt;User&gt; &#123; @Autowired UserMapper userMapper; @Cacheable(keyGenerator = \"userKey\", sync = true) @Override public User get(Integer id) &#123; return userMapper.selectUserById(id); &#125; @CachePut(value = \"user\", keyGenerator = \"userKey\", condition = \"#result==true\") @Override public boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id, user); &#125;&#125; @CacheConfig可以配置单的属性如下： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig &#123; String[] cacheNames() default &#123;&#125;; //缓存名字，它里面没有value String keyGenerator() default \"\"; //主键生成策略 String cacheManager() default \"\"; //指定缓存管理器 String cacheResolver() default \"\"; //缓存处理器&#125;","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot之自定义starter","date":"2019-09-08T10:46:40.000Z","path":"2019/09/08/SpringBoot自定义starter/","text":"Spring Boot中提供了各种starter，starter可以理解为一个可拔插式的插件，当我们要使用的时候只用导入需要的starter即可。例如：你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data-mongodb。但是当我们需要的场景没有的时候我们可以来定制starter。 创建一个maven工程首先在IDEA中创建一个空工程，在其中创建两个Model，一个是hello-spring-boot-starter,另一个是hello-spring-boot-starter-configurer，目结构如下： 要特别注意artifactId的命名规则：Spring官方starter通常命名为spring-boot-starter-{name},如 spring-boot-starter-web Spring官方建议非官方Starter命名应遵循{name}-spring-boot-starter的格式, 如mybatis-spring-boot-starter。 一般我们不会直接在starter中写配置，starter一般只一个空项目，然后主要的配置写在这个starter对应的autoconfigurer中，让starer依赖configurer就可以了。 在starter中引入对应的configurer依赖starter一般是一个空模块，真正的实现放在configurer中，让starter依赖configurer，以后需要使用这个模块的时候只用引入starter就可以引入它所依赖的configurer。 12345678&lt;dependencies&gt; &lt;!--在自定义的start中引入对应的配置类--&gt; &lt;dependency&gt; &lt;groupId&gt;com.xust.iot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-configurer&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在hello-spring-boot-starter-configurer模块中写我们需要的配置XxxProperties123456789101112131415package com.xust.iot.starter;import org.springframework.boot.context.properties.ConfigurationProperties;/** * 用户的配置信息类 */@ConfigurationProperties(prefix = \"com.xust.user\")public class UserProperties &#123; private String username; //用户名 private Integer age; //用户年龄 private String gender=\"M\"; //用户性别 //getter、setter。。。 核心业务类123456789101112131415161718192021package com.xust.iot.starter;/** * 核心服务类 */public class UserService &#123; private UserProperties userProperties; public UserService()&#123; &#125; public UserService(UserProperties userProperties) &#123; this.userProperties = userProperties; &#125; public String sayHello()&#123; return \"大家好，我叫\"+userProperties.getUsername()+\",今年\"+userProperties.getAge()+\"岁，\"+\"性别：\"+userProperties.getGender(); &#125;&#125; 自动配置类XxxAutoConfigurer12345678910111213141516171819202122package com.xust.iot.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration //说明这是配置@ConditionalOnWebApplication //说明在Web环境下该类起作用@EnableConfigurationProperties(UserProperties.class) //自动配置UserProperties中的属性public class UserServiceAutoConfigurer &#123; @Autowired private UserProperties userProperties; @Bean public UserService userService() &#123; UserService userService = new UserService(userProperties); return userService; &#125;&#125; src/main/resources/META-INF/spring.factories然后需要在hello-spring-boot-starter-configurer的src/main/resources文件夹下新建META-INF文件夹然后新建spring.factories文件,配置这个类让他可以自动启动。 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\com.xust.iot.starter.UserServiceAutoConfigurer 打包mvn clean install使用Maven命令mvn clean install或直接使用IDEA提供的Maven插件执行install命令把我们的这个starter安装到本地Maven仓库。注意：如果提示没有找到pom文件的错误，那就使用命令行找到对应的项目执行Maven命令 测试一下之后我们再新建一个普通的Spring Boot项目，引入我们自定义的starter 123456&lt;!--在别的项目中引入我们自己的starter,只需要引入starter就可以了--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xust.iot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 引入后的效果： 写一个controller来测试一下我们的starter是否有效 123456789101112@Controllerpublic class UserController &#123; @Autowired UserService userService; @ResponseBody @RequestMapping(value = \"/user\") public String hello()&#123; return userService.sayHello(); &#125;&#125; 可以在主配置文件中配置UserProperties中的属性（不配置将会使用默认值） 123com.xust.user.username=李四com.xust.user.age=21com.xust.user.gender=M 启动运行看看效果：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot之MyBatis的配置和使用（注解和XML配置）","date":"2019-09-07T10:20:50.000Z","path":"2019/09/07/SpirngBoot之Mybatis的配置和使用/","text":"关于MyBatis，大部分人都很熟悉。MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。这篇文章主要介绍了Spring Boot集成MyBatis的两种方式（注解和XML文件配置）,需要的朋友可以参考下 &nbsp;&nbsp; 使用XML配置MyBatis在pom.xml文件中引入MyBatis的依赖12345 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 编写MyBatis的主配置文件Mybatis-config.xml在src/main/resources目录下新建mybatis文件夹，然后新建Mybatis-config.xml文件并配置如下： 123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--一些有关于mybatis运行时行为的设置--&gt; &lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!--开启懒加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--aggressvieLazyLoading当这个参数为true的时候，对任意延迟属性都会完全的加载，当为false时会按需加载--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\"/&gt; &lt;!--开启自动映射--&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!--开启驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 编写Mapper接口以及对应的Mapper映射文件在src/main/java下新建mapper包，然后新建ArticleMapper接口如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/***对article表的CRUD*/@Repository@Mapper //特别注意一定要加上@Mapper注解(或者也可以在启动类中使用@MapperScan)public interface ArticleMapper &#123; /** * 增加一片文章 * * @param article 文章对象 * @return */ Integer add(Article article) throws SQLException; /** * 删除一片文章 * * @param id 文章id * @return */ boolean delete(Integer id) throws SQLException; /** * 修改一片文章 * * @param id * @return * @throws SQLException */ boolean update(@Param(\"id\") Integer id, @Param(\"article\") Article article) throws SQLException; /** * 根据传入的参数查询文章 * * @param id * @return * @throws SQLException */ List&lt;Article&gt; getArticle(@Param(\"id\") Integer id, @Param(\"title\") String title) throws SQLException; /** * 查询所有的文章 * * @return * @throws SQLException */ List&lt;Article&gt; getAll() throws SQLException;&#125; 在src/main.resoures下新建mapper文件夹，然后在mapper文件夹中新建对应的Mapper映射文件ArticleMapper.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xust.iot.springboot_db.mapper.ArticleMapper\"&gt; &lt;insert id=\"add\" parameterType=\"com.xust.iot.springboot_db.bean.Article\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO article ( title, summary, content,level, ctimes, picture ) VALUES (#&#123;title&#125;,#&#123;summary&#125;,#&#123;content&#125;,#&#123;level&#125;,#&#123;ctimes&#125;,#&#123;picture&#125;) &lt;/insert&gt; &lt;delete id=\"delete\" parameterType=\"integer\"&gt; delete from article where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id=\"update\"&gt; update article &lt;if test=\"article!=null\"&gt; &lt;set&gt; &lt;if test=\"article.title!=null\"&gt;title=#&#123;article.title&#125;&lt;/if&gt; &lt;if test=\"article.summary!=null\"&gt;summary=#&#123;article.summary&#125;&lt;/if&gt; &lt;if test=\"article.content!=null\"&gt;content=#&#123;article.content&#125;&lt;/if&gt; &lt;if test=\"article.level!=null\"&gt;level=#&#123;article.level&#125;&lt;/if&gt; &lt;if test=\"article.ctimes!=null\"&gt;ctime=#&#123;article.times&#125;&lt;/if&gt; &lt;if test=\"article.picture!=null\"&gt;picture=#&#123;article.picture&#125;&lt;/if&gt; &lt;/set&gt; &lt;/if&gt; &lt;where&gt; id=#&#123;id&#125; &lt;/where&gt; &lt;/update&gt; &lt;select id=\"getArticle\" resultType=\"com.xust.iot.springboot_db.bean.Article\"&gt; select * from article &lt;where&gt; &lt;choose&gt; &lt;when test=\"id!=null\"&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;/choose&gt; &lt;choose&gt; &lt;when test=\"title!=null\"&gt;title=#&#123;title&#125;&lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id=\"getAll\" resultType=\"com.xust.iot.springboot_db.bean.Article\"&gt; select * from article &lt;/select&gt;&lt;/mapper&gt; 然后在application.yml文件中配置mybatis这两个文件的位置： 123456mybatis: config-location: classpath:/mybatis/mybatis-config.xml #MyBatis主配置文件的位置 mapper-locations: classpath:/mybatis/mapper/*.xml #mapper文件的位置 这种写法就注册了所有mapper包下的mapper映射文件logging: level: com.xust.iot.learningspirngbootcache01.mapper: debug #对mapper包开启debug,可以看到MyBatis执行SQL的日志打印 编写一个controller，简单测试一下看看我们配置的MyBatis能不能用。这里为了简单就没有写对应的service。 1234567891011121314@Controllerpublic class ArticleController &#123; @Autowired ArticleMapper articleMapper; @ResponseBody @RequestMapping(\"/article/&#123;id&#125;\") public List&lt;Article&gt; getArticle(@PathVariable(\"id\") Integer id) &#123; List&lt;Article&gt; articles=articleMapper.getArticle(id,null); //articles.forEach(article -&gt; System.out.println(\"article\"+article)); return articles; &#125;&#125; 测试结果： &nbsp;&nbsp; 使用注解配置MyBatis在src/main/java/mapper下新建CourseMapper接口 12345678910111213141516171819@Repositorypublic interface CourseMapper &#123; @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into course(cid,cname) values(#&#123;cid&#125;,#(cname))\") int add(Course course); @Delete(\"delete from course where id=#&#123;id&#125;\") boolean delete(Integer id); @Update(\"update course set cid=#&#123;course.cid&#125;,cname=#&#123;course.cname&#125;\") boolean update(@Param(\"id\") Integer id, @Param(\"course\") Course course); @Select(\"select * from course where id=#&#123;id&#125;\") Course getOne(Integer id); @Select(\"select * from course\") List&lt;Course&gt; getAll();&#125; 在启动类上使用@MapperScan扫描mapper包下的所有的Mapper接口，这样做的好处是可以省去在每个Mapper接口上写@Mapper注解。 12345678@MapperScan(value = \"com.xust.iot.springboot_db.mapper\")@SpringBootApplicationpublic class SpringbootDbApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDbApplication.class, args); &#125;&#125; 还可以写一个配置类彻底取代MyBatis的所有XML文件MyBatisConfig.java 12345678910111213141516@Configurationpublic class MybatisConfig &#123; /** * @return */ public ConfigurationCustomizer configurationCustomizern()&#123; return configuration -&gt; &#123; configuration.setMapUnderscoreToCamelCase(true); //开启驼峰命名 configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); configuration.setCacheEnabled(true); //.....在mybatis主配置文件可以设置的在这里都可以设置 &#125;; &#125;&#125; 编写一个controller，看看实际的效果： 1234567891011121314@Controllerpublic class CourseController &#123; @Autowired CourseMapper courseMapper; @ResponseBody @RequestMapping(value = \"/course\") public List&lt;Course&gt; show()&#123; List&lt;Course&gt; courses = courseMapper.getAll(); courses.forEach(course -&gt; System.out.println(\"course；\"+course)); return courses; &#125;&#125; 测试结果：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot 整合Druid数据源","date":"2019-09-07T04:14:52.000Z","path":"2019/09/07/Springboot配置druid监控/","text":"java实现的数据库连接池有很多，c3p0,dbcp等，还有号称速度最快的HikariCP，并且springboot2.0.2版本默认使用的就是HikariCP。为什么选用Druid呢？ 性能够好，比c3p0,dbcp强一些 经过考验，毕竟是阿里开源出来的项目 最关键的是带一个强大的数据库监控 &nbsp;&nbsp; Druid能监控那些数据 1. 数据源 2. SQL监控 ，对执行的MySQL语句进行记录，并记录执行时间、事务次数等 3. SQL防火墙 ，对SQL进行预编译，并统计该条SQL的数据指标 4. Web应用， 对发布的服务进行监控，统计访问次数，并发数等全局信息 5. URI监控， 对访问的URI进行统计，记录次数，并发数，执行jdbc数等 6. Session监控， 对用户请求后保存在服务器端的session进行记录，识别出每个用户访问了多少次数据库等 7. Spring监控 ，（按需配置）利用aop对各个内容接口的执行时间、jdbc数进行记录 &nbsp;&nbsp; 如何配置使用Druid想达到的目标效果，监控sql，监控sql防火墙，监控url，监控session，监控spring 其中监控sql、监控url、基础信息，几乎不怎么需要配置，集成好druid，配置好监控页面，就可以显示。需要我们配置的大概分为3部分，基础连接池配置，基础监控配置，定制化监控配置 首先需要引入Druid的依赖123456&lt;!--这里最好引入spring提供的这个starter，在druid-spring-boot-starter这个pom文件中已经引入了源工程的pom文件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 基础连接池配置主要配置用户名，密码，数据库驱动、数据库连接…..以及和连接池有关的配置 1234567891011121314151617181920212223242526272829303132spring: datasource: # 数据源基本配置 username: root password: 123456 url: jdbc:mysql://localhost:3306/xust?useSSL=false&amp;set global time_zone=\"+8:00\" driver-class-name: com.mysql.cj.jdbc.Driver #使用type指定使用Druid type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 # 初始化连接池的连接数量 大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 是否缓存preparedStatement，也就是PSCache 官方建议MySQL下建议关闭 如果想用SQL防火墙 建议打开 poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true # 通过connectProperties属性来打开mergeSql功能 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 导入Druid数据源的其他属性上面的配置文件中和数据库连接池有关的配置属性在Spring Boot是没有的，因此我们需要告诉Spring Boot，让他在启动的时候去找加载这些属性，因此我们需要写一个配置类。没有写配置类之前的效果： 写一个配置类 12345678910@Configurationpublic class DruidConfig &#123; //配置Druid的其他属性 @Bean @ConfigurationProperties(prefix = \"spring.datasource\") //让Spring boot去加载这些属性，完成对连接池的初始化 public DataSource druid()&#123; return new DruidDataSource(); &#125;&#125; 写配置类后的效果，配置类起作用了： 配置Durid监控主要就是配置一个后台管理的Servlet—StarViewServlet和Web监控过滤器—WebStatFilter。具体有哪些初始化参数可以设置，可以参考这两个类以及他们的父类，都是以常量的方式出现的，配置的时候配置他们的值就可以了。 123456789101112131415161718192021222324252627282930313233@Configurationpublic class DruidConfig &#123; //配置Druid数据监控 //1.配置管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),\"/druid/*\"); //设置后台管理的路径是/druid/* Map&lt;String,String&gt; initParams= new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\"); //默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); //设置不允许访问ip initParams.put(\"resetEnable\",\"false\"); //是否手动清除监控数据 //设置一些初始化的参数 bean.setInitParameters(initParams); return bean; &#125; //2.配置一个Web监控的Filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean=new FilterRegistrationBean(new WebStatFilter()); Map&lt;String,String&gt; initParams=new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 写一个controller启动看看效果： 1234567891011121314@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @ResponseBody @RequestMapping(value = \"/query\") public List&lt;Map&lt;String,Object&gt;&gt; hello()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(\"select * from article\"); return maps; &#125;&#125; 启动后在浏览器地址栏输入localhost:8080/query，执行一次请求启动后在浏览器地址栏输入localhost:8080/druid，可以看到Druid后台管理的登录界面 输入刚刚设置的用户名个密码，来到后台管理页面，点击SQL监控就可以看到刚才执行的SQL被记录了。 上面Druid监控的配置还可以直接在properties/yml文件中配置，下面是关于Druid监控的配置片段： 123456789101112131415debug: truespring: datasource: # Druid监控配置 druid: stat-view-servlet: enabled: true #开启后台管理 ，默认也是true url-pattern: /druid/* #后台管理页面的路径 login-password: 123456 login-username: admin reset-enable: false #禁止手动清除监控数据 web-stat-filter: enabled: true exclusions: .js,.css,.html,/druid/* url-pattern: /*","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot配置外部Servlet容器（Tomcat）","date":"2019-09-04T05:58:07.000Z","path":"2019/09/04/SpringBoot配置外置Servlet容器/","text":"嵌入式Servlet容器：将应用打成可执行的jar包 ​优点：简单、便携； ​缺点：默认不支持JSP、优化定制比较复杂； 外置的Servlet容器：在外面安装Tomcat(或者使用外部已经安装好的Tomcat)，项目完成后把项目打包成war包，然后放到外部Tomcat容器中运行。 &nbsp;&nbsp; 配置步骤修改打包的方式修改的方法有两种：一种是在使用【Spring Initializr】新建项目的时候选择Packing为war；另一种是在Maven pom.xml文件中修改&lt;packaging&gt;jar&lt;/packaging&gt;使用【Spring Initializr】新建项目的时候选择Packing为war pom.xml文件中修改 1234&lt;artifactId&gt;springboot_servlet_contanier&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!--修改为war的打包方式--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 修改原有嵌入式的Tomcat的作用域为provided&lt;/&gt;123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!--provided的意思是告诉Spring Boot 外部提供了，使用外部提供的这个。--&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 添加servlet-api依赖1234567891011121314151617181920212223242526&lt;!--添加原生tomcat依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--使用jsp还要添加下面对依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 编写一个SpringBootServletInitializer的子类，并调用configure方法【必须】12345678public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //参数是当前项目的启动类的class return application.sources(SpringbootServletContanierApplication.class); &#125;&#125; 如果使用的是【Spring Initializr】创建的项目，正常操作后就会自动生成这个类。 最后在项目中新建webapp目录，启动服务器就可以使用了。 注意：如果发生使用JSP EL表达式无法解析的情况时，可以在jsp页面写上&lt;%@ page isELIgnored=&quot;false&quot; %&gt;这条语句就可以了。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot之嵌入式Servlet容器的配置、切换和启动原理","date":"2019-09-04T03:34:34.000Z","path":"2019/09/04/SpringBoot嵌入式Server容器/","text":"注意：以下的所有操作、原理、源码全部是建立在Spring Boot 2.1.7基础上的。 &nbsp;&nbsp; 修改SpringBoot对嵌入式Server容器的默认配置&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot默认使用Tomcat作为嵌入式的Servlet容器。实际应用中我们需要对他进行专门的定制。定制的方式不外乎两种：application.proeprties(yml)或在配置类中注册组件的方式，但是这里介绍了3种方法，其实后面两种方法大同小异，原理都是一样的。 方式1：直接在application.properties/application.xml文件中配置和server有关的属性配置方式是server.属性名=值，下面是ServerProperties类中定义的绝大多数可以配置的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273server配置server.address 指定server绑定的地址server.compression.enabled 是否开启压缩，默认为false.server.compression.excluded-user-agents 指定不压缩的user-agent，多个以逗号分隔，默认值为:text/html,text/xml,text/plain,text/cssserver.compression.mime-types 指定要压缩的MIME type，多个以逗号分隔.server.compression.min-response-size 执行压缩的阈值，默认为2048server.context-parameters.[param name] 设置servlet context 参数server.context-path 设定应用的context-path.server.display-name 设定应用的展示名称，默认: applicationserver.jsp-servlet.class-name 设定编译JSP用的servlet，默认: org.apache.jasperservlet.JspServlet)server.jsp-servlet.init-parameters.[param name] 设置JSP servlet 初始化参数.server.jsp-servlet.registered 设定JSP servlet是否注册到内嵌的servlet容器，默认trueserver.port 设定http监听端口server.servlet-path 设定dispatcher servlet的监听路径，默认为: /cookie、session配置server.session.cookie.comment 指定session cookie的commentserver.session.cookie.domain 指定session cookie的domainserver.session.cookie.http-only 是否开启HttpOnly.server.session.cookie.max-age 设定session cookie的最大age.server.session.cookie.name 设定Session cookie 的名称.server.session.cookie.path 设定session cookie的路径.server.session.cookie.secure 设定session cookie的“Secure” flag.server.session.persistent 重启时是否持久化session，默认falseserver.session.timeout session的超时时间server.session.tracking-modes 设定Session的追踪模式(cookie, url, ssl).ssl配置server.ssl.ciphers 是否支持SSL ciphers.server.ssl.client-auth 设定client authentication是wanted 还是 needed.server.ssl.enabled 是否开启ssl，默认: trueserver.ssl.key-alias 设定key store中key的别名.server.ssl.key-password 访问key store中key的密码.server.ssl.key-store 设定持有SSL certificate的key store的路径，通常是一个.jks文件.server.ssl.key-store-password 设定访问key store的密码.server.ssl.key-store-provider 设定key store的提供者.server.ssl.key-store-type 设定key store的类型.server.ssl.protocol 使用的SSL协议，默认: TLSserver.ssl.trust-store 持有SSL certificates的Trust store.server.ssl.trust-store-password 访问trust store的密码.server.ssl.trust-store-provider 设定trust store的提供者.server.ssl.trust-store-type 指定trust store的类型.tomcat配置server.tomcat.access-log-enabled 是否开启access log ，默认: false)server.tomcat.access-log-pattern 设定access logs的格式，默认: commonserver.tomcat.accesslog.directory 设定log的目录，默认: logsserver.tomcat.accesslog.enabled 是否开启access log，默认: falseserver.tomcat.accesslog.pattern 设定access logs的格式，默认: commonserver.tomcat.accesslog.prefix 设定Log 文件的前缀，默认: access_logserver.tomcat.accesslog.suffix 设定Log 文件的后缀，默认: .logserver.tomcat.background-processor-delay 后台线程方法的Delay大小: 30server.tomcat.basedir 设定Tomcat的base 目录，如果没有指定则使用临时目录.server.tomcat.internal-proxies 设定信任的正则表达式，默认:“10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;| 192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;| 169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;| 127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;| 172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;| 172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;”server.tomcat.max-http-header-size 设定http header的最小值，默认: 0server.tomcat.max-threads 设定tomcat的最大工作线程数，默认为: 0server.tomcat.port-header 设定http header使用的，用来覆盖原来port的value.server.tomcat.protocol-header 设定Header包含的协议，通常是 X-Forwarded-Proto，如果remoteIpHeader有值，则将设置为RemoteIpValve.server.tomcat.protocol-header-https-value 设定使用SSL的header的值，默认https.server.tomcat.remote-ip-header 设定remote IP的header，如果remoteIpHeader有值，则设置为RemoteIpValveserver.tomcat.uri-encoding 设定URI的解码字符集.undertow配置server.undertow.access-log-dir 设定Undertow access log 的目录，默认: logsserver.undertow.access-log-enabled 是否开启access log，默认: falseserver.undertow.access-log-pattern 设定access logs的格式，默认: commonserver.undertow.accesslog.dir 设定access log 的目录.server.undertow.buffer-size 设定buffer的大小.server.undertow.buffers-per-region 设定每个region的buffer数server.undertow.direct-buffers 设定堆外内存server.undertow.io-threads 设定I/O线程数.server.undertow.worker-threads 设定工作线程数 配置示例： 12345678910server: port: 80 #端口 servlet: context-path: /crud #项目的context-path tomcat: uri-encoding: UTF-8 #tomcat URI的字符编码 basedir: localhost/crud #tomcat基路径 compression: #是否开启压缩文件 enabled: true #true是开启 mime-types: text/html,text/css,text/javascript #压缩的文件类型 方式2：向IoC容器中添加servlet容器工厂定制器 WebServerFactoryCustomizer123456789101112131415161718@Configurationpublic class ServerConfig &#123; @Bean //注册到IOC容器中 public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; webServerFactoryCustomizer()&#123; return factory -&gt; &#123; //在这里设置server有关对属性 factory.setPort(8085); factory.setContextPath(\"/crud\"); factory.setUriEncoding(Charset.forName(\"utf-8\")); Compression compression = new Compression(); compression.setEnabled(true); String []mimes=&#123;\"text/html\",\"text/css\"&#125;; compression.setMimeTypes(mimes); factory.setCompression(compression); &#125;; &#125;&#125; 运行结果： 如果使用的是Spring Boot 1.x版本可以参考下面的方法来使用配置 123456789101112public class ServerConfig extends WebMvcConfigurerAdapter &#123; public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() &#123; return new EmbeddedServletContainerCustomizer() &#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; //配置server属性 container.setPort(8083); ... &#125; &#125;; &#125;&#125; 方式3：向IoC容器中添加可配置的servlet容器工厂 ConfigurableServletWebServerFactory123456789101112131415161718@Configurationpublic class ServerConfig &#123; @Bean public ConfigurableServletWebServerFactory configurableServletWebServerFactory() &#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); //设置属性 factory.setPort(8089); factory.setContextPath(\"/springboot\"); factory.setUriEncoding(Charset.forName(\"utf-8\")); Compression compression = new Compression(); compression.setEnabled(true); String[] mimes = &#123;\"text/html\", \"text/css\"&#125;; compression.setMimeTypes(mimes); factory.setCompression(compression); return factory; &#125;&#125; 运行自然是没有什么问题，在地址栏输入localhost:8089/springboot/也来到了目标页面： 在Spring Boot中注册Servlet三大组件【Servlet、Filter、Listener】以前注册这些组件都是在web.xml中配置，由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动Spring Boot的web应用，默认就没有web.xml文件了。那怎么办呢？Spring Boot给的解决办法很简单，就是使用对应的XxxRegistrationBean来注册，具体的方法参考下面示例 注册三大组件用以下方式： 1、借助ServletRegistrationBean注册自定义Servlet组件； 自定义MyServlet.java： 12345678public class MyServlet extends HttpServlet &#123; //重写service方法 @Override protected void service(HttpServletRequest req,HttpServletResponse resp)&#123; resp.getWriter().write(\"Hello Spring Boot!\"); &#125;&#125; 借助ServletRegistrationBean来注册一个Servlet并放入容器中： 12345@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),\"/myServlet\"); return registrationBean;&#125; 2、借助FilterRegistrationBean注册自定义Filter组件(自定义的MyFilter忽略) 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; 3、借助ServletListenerRegistrationBean注册自定义Listener组件(自定义的MyListener忽略) 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; &nbsp;&nbsp; 嵌入式Servlet容器切换三大容器比较 容器 优点 缺点 默认 tomcat 功能齐全 庞大，荣泽 true jetty 轻量 功能不全 false undertow 异步，高效 不支持jsp false 容器切换 Tomcat Spring Boot引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器。 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Jetty 123456789101112131415161718&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--排除tomcat--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入jetty容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; &nbsp;&nbsp; 嵌入式Servlet容器自动配置原理主要的三个类： ServletWebServerFactoryConfiguration ServletWebServerFactoryAutoConfiguration ServletWebServerFactoryCustomizer ServletWebServerFactoryConfiguration首先从ServletWebServerFactoryConfiguration这个配置类说起，在它里面主要有三个嵌入式的Web容器：EmbeddedUndertow ，EmbeddedJetty，EmbeddedTomcat以及@Conditionalxxx 标注的类（条件检查，只有条件满足才向容器中添加组件）。这个类的作用就是根据配置的环境，产生一个对应容器的工厂类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configurationclass ServletWebServerFactoryConfiguration &#123; //默认配置的就是Tomcat @Configuration //条件检查：类路径下存在servlet.class(存在servlet依赖) tomcat.class(tomcat依赖) 才会执行向容器中添加组件 @ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;) //判断容器中有没有用户自定义的ServletWeServerbFactory @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedTomcat &#123; //向IOC容器中添加tomcat工厂，之后由工厂产生嵌入式的tomcat实例 @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123; return new TomcatServletWebServerFactory(); &#125; &#125; /** * 如果配置了Jetty就会自动配置jetty */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyServletWebServerFactory JettyServletWebServerFactory() &#123; return new JettyServletWebServerFactory(); &#125; &#125; /** * 如果配置了Undertow就会自动配置Undertow */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowServletWebServerFactory undertowServletWebServerFactory() &#123; return new UndertowServletWebServerFactory(); &#125; &#125;&#125;&#125; ServletWebServerFactory：嵌入式Servlet工厂。作用：创建嵌入式Servlet容器 1234567@FunctionalInterfacepublic interface ServletWebServerFactory &#123; //ServletWebServerFactory只有一个接口方法getWebServer，他会拿到Spring Boot在启动的时候初始化的参数 WebServer getWebServer(ServletContextInitializer... initializers);&#125; 在判断@ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class})是否导入依赖，满足条件后return new TomcatServletWebServerFactory(); 添加对应的Servlet容器工厂；通过工厂的唯一方法getWebServer 获取对应的Servlet容器TomcatServer. TomcatServletWebServerFactory 123456789101112131415161718192021222324252627282930313233public class TomcatServletWebServerFactory extends AbstractServletWebServerFactory implements ConfigurableTomcatWebServerFactory, ResourceLoaderAware &#123; public WebServer getWebServer(ServletContextInitializer... initializers) &#123; // 1. 创建Tomcat对象 Tomcat tomcat = new Tomcat(); //设置tomcat的基路径 File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); // 2.完成tomct 配置的基本操作 Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); this.customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); this.configureEngine(tomcat.getEngine()); Iterator var5 = this.additionalTomcatConnectors.iterator(); while(var5.hasNext()) &#123; Connector additionalConnector = (Connector)var5.next(); tomcat.getService().addConnector(additionalConnector); &#125; this.prepareContext(tomcat.getHost(), initializers); 3.将tomcat 传入方法：getTomcatWebServer() return this.getTomcatWebServer(tomcat); &#125;&#125; TomcatWebServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TomcatWebServer implements WebServer &#123; //TomcatWebServer的构造器中真正的实例化tomcat，并且启动tomcat public TomcatWebServer(Tomcat tomcat, boolean autoStart) &#123; this.monitor = new Object(); this.serviceConnectors = new HashMap(); Assert.notNull(tomcat, \"Tomcat Server must not be null\"); this.tomcat = tomcat; this.autoStart = autoStart; this.initialize(); &#125; //initialize方法执行初始化 private void initialize() throws WebServerException &#123; logger.info(\"Tomcat initialized with port(s): \" + getPortsDescription(false)); synchronized (this.monitor) &#123; try &#123; addInstanceIdToEngineName(); Context context = findContext(); context.addLifecycleListener((event) -&gt; &#123; if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123; //服务启动的时候执行 removeServiceConnectors(); &#125; &#125;); //启动tomcat this.tomcat.start(); // We can re-throw failure exception directly in the main thread rethrowDeferredStartupExceptions(); try &#123; ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader()); &#125; catch (NamingException ex) &#123; // Naming is not enabled. Continue &#125; // Unlike Jetty, all Tomcat threads are daemon threads. We create a // blocking non-daemon to stop immediate shutdown startDaemonAwaitThread(); &#125; catch (Exception ex) &#123; stopSilently(); destroySilently(); throw new WebServerException(\"Unable to start embedded Tomcat\", ex); &#125; &#125; &#125;&#125; ServletWebServerFactoryAutoConfiguration修改定制嵌入式Servlet 容器的方法:&nbsp;&nbsp;&nbsp;1、配置文件中添加配置。&nbsp;&nbsp;&nbsp;2、ServerProperties 绑定/修改定制组件 WebServerFactoryCustomizer 他们的本质是一样的：在ServletWebServerFactoryAutoConfiguration配置类中@EnableConfigurationProperties({ServerProperties.class})。导入了BeanPostProcessorsRegistrar，在这个类的方法中添加了组件WebServerFactoryCustomizerBeanPostProcessor(定制器后置处理器)。也就是说一旦容器中添加任何组件都会启动定制后置处理器，进行Servlet的赋值。 ServletWebServerFactoryCustomizer在这个配置类中使用customize(ConfigurableServletWebServerFactory factory)这个方法 完成了Tomcat的各项配置的修改和定制 1234567891011121314151617181920public class ServletWebServerFactoryCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123; //具体对Tomcat的配置细节 @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); map.from(this.serverProperties::getPort).to(factory::setPort); map.from(this.serverProperties::getAddress).to(factory::setAddress); map.from(this.serverProperties.getServlet()::getContextPath).to(factory::setContextPath); map.from(this.serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName); map.from(this.serverProperties.getServlet()::getSession).to(factory::setSession); map.from(this.serverProperties::getSsl).to(factory::setSsl); map.from(this.serverProperties.getServlet()::getJsp).to(factory::setJsp); map.from(this.serverProperties::getCompression).to(factory::setCompression); map.from(this.serverProperties::getHttp2).to(factory::setHttp2); map.from(this.serverProperties::getServerHeader).to(factory::setServerHeader); map.from(this.serverProperties.getServlet()::getContextParameters).to(factory::setInitParameters); &#125;&#125; 配置修改定制原理(以tomcat为例)1、Spring Boot根据根据导入依赖的情况，给容器中添加相应的ServletWebServerFactory（比如tomcat就会添加TomcatServletWebServerFactory） 2、如果使用的是通过application.properties 修改配置，那么server 相关的配置修改是与ServerProperties 类绑定的，所以相关的修改会直接通过ServerProperties 的方法实现【相关的配置类：ServletWebServerFactoryCustomizer】 3、如果使用的是修改定制器 WebServerFactoryCustomizer的方法来配置server，那么定制器会创建ConfigurableWebServerFactory对象，这样一来就会触发WebServerFactoryCustomizerBeanPostProcessor 后置处理器，判断是否为WebServerFactory 类型；满足条件后，就会获取容器中的所有定制器（customizer.cutomize(bean)），为Servlet容器修改和定制配置【相关的配置类ServletWebServerFactoryAutoConfiguration，导入了定制处理器】 &nbsp;&nbsp; 嵌入式Servlet 容器启动的原理（tomcat）几个重要的回调机制：配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 1、SpringBoot 应用启动，运行run()方法跟随源码我们来到SpringApplication类中发现他对run方法进行了几次封装 1234567891011121314151617181920212223242526272829303132333435//这是我们在启动类中调用的run()方法public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; //调用了本类中的另一个run()方法,也就是紧跟着下面的这个方法 return run(new Class[]&#123;primarySource&#125;, args);&#125;public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; //调用了SpringApplication中的构造器创建了一个SpringAapplication的对象，并最终调用了真正的run方法 return (new SpringApplication(primarySources)).run(args);&#125;//最终执行初始化SpringApplication的构造器public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; this.sources = new LinkedHashSet(); this.bannerMode = Mode.CONSOLE; this.logStartupInfo = true; //默认开启命令行参数 this.addCommandLineProperties = true; this.addConversionService = true; this.headless = true; this.registerShutdownHook = true; //多profiles初始化，使用的是HashSet来保存 this.additionalProfiles = new HashSet(); this.isCustomEnvironment = false; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); //设置初始化参数 this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); //设置监听器 this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); //从多个主配置类中找到有main方法的的主配置类（启动类） this.mainApplicationClass = this.deduceMainApplicationClass();&#125; 运行run()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //获取SpringApplictionRunListeners对象，从META-INF/factroies下加载 SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的SpringApplicationRunListeners的startings方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //准备环境，在这个方法内部当环境创建完成后会调用SpringApplicationRunListener的environmentPrepared()方法表示环境准备完成 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); //Spring Boot一启动打印Spring图标就是在这里完成的 Banner printedBanner = printBanner(environment); //创建ioc容器 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //准备上下文环境：将environment保存到ioc容器中 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新容器：扫描、加载、创建所有组件的地方（如果Web环境默认还会创建嵌入式的tomcat容器） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调。ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; //Spring Boot引用启动完成后返回ioc容器 return context; &#125; 2、SpringApplication类中的run方法中调用refreshContext(context) 刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】,如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则普通应用创建AnnotationConfigApplicationContext 1234567891011121314151617private void refreshContext(ConfigurableApplicationContext context) &#123; //直接调用的是本类中的refresh方法 refresh(context); if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125; &#125; //在这里真正调用AbstractApplicationContext类中的refersh方法来刷新容器 protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh(); &#125; 3、refresh()刷新刚才创建好的ioc容器AbstractApplicationContext 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; 4、Web模块的IOC容器重写了onRefresh()方法，创建了嵌入式的Servlet容器5、获取嵌入式工厂容器组件：ServletWebServerFactory factory = this.getServletWebServerFactory (); TomcatServletWebServerFactory 对象被创建，触发后置处理器，配置类中：@EnableConfigurationProperties({ServerProperties.class}) 根据配置文件，获取所有的定制器为Servlet容器赋值6、TomcatServerWebServletFactory 获取后使用这个容器工厂获取Servlet容器TomcatWebServer(其他容器类似) 完成自启动7、嵌入式的Servlet容器创建对象并启动Servlet容器 IOC容器启动创建嵌入式的Servlet容器，再启动嵌入式的Servlet容器，再将IOC容器中剩下没有创建出的对象获取出来","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot 错误处理机制","date":"2019-09-02T05:53:24.000Z","path":"2019/09/02/SpringBoot错误处理机制/","text":"&nbsp;&nbsp; Spring Boot默认的错误处理机制（现象）&nbsp;&nbsp;&nbsp;&nbsp;当我们使用Spring Boot发生错误的时候，如果我们没有配置错误的处理规则，那么Spring Boot就会启用内部的默认错误处理办法。比如当发生404错误的时候，网页端的效果如下： 而在别的客户端访问的时候如果出现了404错误，默认会给客户端发送一串错误消息的JSON数据 客户端的测试使用到了一个工具：Postman,感兴趣的小伙伴可以去Postman官网下载后来测试。 &nbsp;&nbsp; Spring Boot默认的错误处理机制（原理）&nbsp;&nbsp;&nbsp;&nbsp;看到这些现象我们不禁会有疑问，Spring Boot的底层是如何生成不同错误的默认错误页面的？还有他是如何区分浏览器和普通客户端的？带着疑问我们继续往下看。&nbsp;&nbsp;&nbsp;&nbsp;我们参照源码来分析一下（Spring Boot 2.1.7版本），具体在ErrorMvcAutoConfiguration这个错误处理自动配置类,下面是在这个类中注册的几个重要的组件的源码： ErrorMvcAutoConfiguration源码片段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class &#125;)// Load before the main WebMvcAutoConfiguration so that the error View is available@AutoConfigureBefore(WebMvcAutoConfiguration.class)@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class, WebMvcProperties.class &#125;)public class ErrorMvcAutoConfiguration &#123; //注册DefaultErrorAttributs @Bean @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); &#125; //注册BaseErrorController @Bean @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT) public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers); &#125; //注册ErrorPageCustomizer @Bean public ErrorPageCustomizer errorPageCustomizer() &#123; return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath); &#125; //配置DefaultErrorViewResolver内部类 @Configuration static class DefaultErrorViewResolverConfiguration &#123; private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) &#123; this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; &#125; //在这个静态内部内中配置了DefaultErrorViewResolver @Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean public DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); &#125; &#125;&#125; 可以看到，ErrorMvcAutoConfiguration这个错误处理类中配置了几个重要的组件： DefaultErrorAttributs ：翻译这个类的名字：默认的错误属性，他就是和错误信息的填充有关。 BasicErrorController ：他是Spring Boot中默认处理/error请求的Controller ErrorPageCustomizer ：系统出现错误以后来到error请求进行处理 DefaultErrorViewResolver ：默认的错误视图解析器 继续跟踪源码 DefaultErrorAttributs源码片段 12345678910111213141516171819@Order(Ordered.HIGHEST_PRECEDENCE)public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123; //获得错误的属性信息，在页面上默认显示的错误信息都由这来的 @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; //new了一个Map Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;(); //产生错误放生的时间戳 errorAttributes.put(\"timestamp\", new Date()); //产生错误的状态码 addStatus(errorAttributes, webRequest); //错误的细节 addErrorDetails(errorAttributes, webRequest, includeStackTrace); //错误的路径 addPath(errorAttributes, webRequest); return errorAttributes; &#125;&#125; BasicErrorController源码片段 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\")public class BasicErrorController extends AbstractErrorController &#123; //浏览器的错误请求用这个处理方法来处理，产生HTML数据 @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; //得到状态码 HttpStatus status = getStatus(request); //把ErrorAttributs中的错误信息填充到model中 Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); //设置响应码 response.setStatus(status.value()); //去哪个页面作为错误页面,包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); //如果没有映射到可以去的错误页面就会去默认的错误页面(就是看到的那个白板页面) return (modelAndView != null) ? modelAndView : new ModelAndView(\"error\", model); &#125; //返回JSON格式的数据，非浏览器访问后错误的处理方法 @RequestMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); //返回Json数据 return new ResponseEntity&lt;&gt;(body, status); &#125;&#125; BasicErrorController中调用了它父类AbstractErrorControlle的方法resolveErrorView来处理ModelAndViewAbstractErrorController源码片段 123456789101112public abstract class AbstractErrorController implements ErrorController &#123;protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status,Map&lt;String, Object&gt; model) &#123; //遍历所有的错误视图处理器 for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null; &#125;&#125; ErrorPageCustomizer源码片段 123456789101112131415161718192021222324252627 /** *ErrorMvcAutoConfiguration的内部类 * &#123;@link WebServerFactoryCustomizer&#125; that configures the server's error pages. */private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered &#123; private final ServerProperties properties; private final DispatcherServletPath dispatcherServletPath; protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) &#123; this.properties = properties; this.dispatcherServletPath = dispatcherServletPath; &#125; @Override public void registerErrorPages(ErrorPageRegistry errorPageRegistry) &#123; ErrorPage errorPage = new ErrorPage( this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); errorPageRegistry.addErrorPages(errorPage); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; DefaultErrorViewResolver源码片段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered &#123; private static final Map&lt;Series, String&gt; SERIES_VIEWS; //错误状态码 static &#123; Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class); views.put(Series.CLIENT_ERROR, \"4xx\"); views.put(Series.SERVER_ERROR, \"5xx\"); SERIES_VIEWS = Collections.unmodifiableMap(views); &#125; @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; // 这里如果没有拿到精确状态码(如404)的视图，则尝试拿4XX(或5XX)的视图 ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认情况下Spring Boot会在error/目录下去找视图，比如error/404.html或error/4xx String errorViewName = \"error/\" + viewName; //如果模板引擎可以解析就有模板引擎来解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; //从静态资源文件夹下面找错误页面 private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; //遍历所有静态资源文件到的路径来看看有没有和viewName同名的视图名（网页名） for (String location : this.resourceProperties.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + \".html\"); if (resource.exists()) &#123; //如果有就返回该视图的ModelAndView return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; //没有就返回null return null; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;大致分析源码后可以总结Spring Boot对错误的处理流程如下：如果系统出现4xx或者5xx之类的错误，ErrorPageCustomizer就会生效（定制错误的响应规则），就会发出/error请求，然后就会被BasicErrorController处理并返回ModelAndView（网页）或者JSON（客户端）。 &nbsp;&nbsp; 使用Spring Boot默认的错误处理机制来处理我们程序中的错误情况&nbsp;&nbsp;&nbsp;&nbsp;通过分析源码我们可以发现，如果要使用Spring Boot默认的错误处理机制，我们可以把我们定制的错误页面放在/templates/error目录下的，交给模板引擎来处理；或者不使用模板引擎那就放在static/error目录下。并且给这些错误页面命名为错误码.html或4xx.html、5xx.html。Spring Boot就可以自动帮我们映射到错误页面。例如，处理404错误：在/templates/error目录下放404.html &nbsp;&nbsp;&nbsp;&nbsp;访问浏览器，在地址栏中随便输入一个地址让他发生404错误，结果来到了我们定制的404错误页面，而不是Spring Boot默认的那个难看的白板页面。 4xx.html 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"Generator\" content=\"EditPlus®\"&gt; &lt;meta name=\"Author\" content=\"\"&gt; &lt;meta name=\"Keywords\" content=\"\"&gt; &lt;meta name=\"Description\" content=\"\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;main role=\"main\" class=\"col-md-9 ml-sm-auto col-lg-10 pt-3 px-4\"&gt; &lt;h1&gt;status:[[$&#123;status&#125;]]&lt;/h1&gt; &lt;h2&gt;timestamp:[[$&#123;timestamp&#125;]]&lt;/h2&gt; &lt;h2&gt;exception:[[$&#123;exception&#125;]]&lt;/h2&gt; &lt;h2&gt;message:[[$&#123;message&#125;]]&lt;/h2&gt; &lt;h2&gt;ext:[[$&#123;ext.code&#125;]]&lt;/h2&gt; &lt;h2&gt;ext:[[$&#123;ext.message&#125;]]&lt;/h2&gt;&lt;/main&gt; &lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp;&nbsp; 定制自己的错误信息默认情况下，Spring Boot的错误页面中可以可得一下错误信息： 123456​timestamp：时间戳​status：状态码​error：错误提示exception：异常对象message：异常消息errors：JSR303数据校验的错误 第一种方式：使用Spring MVC的异常处理器12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResuestBody @ExceptionHandler(NullPointerException.class) public Map&lt;String,Object&gt; handleException(Exception e, HttpServletResponse response)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(\"code\",\"\"); map.put(\"message\",e.getMessage()); map.put(\"exception\",e.getClass()); return map; &#125; &#125; 这样无论是浏览器还是别的客户端，只要出错了就全部返回的JSON数据。 ##### 第二种方式：转发到/error请求进行自适应效果处理 12345678910111213141516@ControllerAdvicepublic class MyExceptionHandler &#123; @ExceptionHandler(NullPointerException.class) public String handleException(Exception e,HttpServletResponse response, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); //设置状态码【必须】 request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"null exception\"); map.put(\"message\",e.getMessage()); map.put(\"exception\",e.getClass()); //转发到/error return \"forward:/error\"; &#125;&#125; 第三种方式：编写一个MyErrorAttributes继承自DefaultErrorAttributes重写其getErrorAttributes方法前两种虽然都可以解决错误，但是单当我们自己定义一个错误属性（比如上面的code属性）就没办法带到页面，因此我们设置的信息也就无法被带到页面显示。我们可以编写一个MyErrorAttributes继承自DefaultErrorAttributes重写其getErrorAttributes方法将我们的错误数据添加进去。 12345678910111213@Component //使用我们的ErrorAttributespublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; //得到原有的errorAttributes Map&lt;String,Object&gt; errorAttributes=super.getErrorAttributes(webRequest,includeStackTrace); errorAttributes.put(\"code\",\"MyError\"); errorAttributes.remove(\"exception\"); errorAttributes.put(\"path\",webRequest.getContextPath()); return errorAttributes; &#125;&#125; 最终的效果：响应是自适应的，以后可以通过定制ErrorAttributes改变需要返回的内容。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot自动配置Spring MVC的原理","date":"2019-08-29T15:05:16.000Z","path":"2019/08/29/SpringBootMVC自动配置/","text":"&nbsp;&nbsp; Spring MVC自动配置&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot对Spring MVC自动配置的详细可以参考管方文档。Spring Boot为Spring MVC提供的AutoConfiguration适用于大多数应用场景，Spring Boot对Spring MVC做了以下默认的自动配置： 1.引入ContentNegotiatingViewResolver 和 BeanNameViewResolver 。 2.对静态资源的支持，包括对WebJars 的支持。 3.自动注册Converter，GenericConverter，Formatter。 4.对HttpMessageConverters 的支持。 5.自动注册MessageCodeResolver。 6.对静态index.html的支持。 7.对自定义Favicon的支持。 8.自动使用 ConfigurableWebBindingInitializer bean。 &nbsp;&nbsp;&nbsp;&nbsp;Spring Boot默认情况下是自动配置好Spring MVC的，可以直接使用，但是Spring Boot也支持我们修改Spring Boot对SpringMVC的配置。如果保留Spring Boot MVC特性，我们只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。我们可以添加自己的WebMvcConfigurerAdapter 类型的@Configuration类（配置类），而不需要注解@EnableWebMvc。如果希望使用自定义的RequestMappingHandlerMapping，RequestMappingHandlerAdapter，或ExceptionHandlerExceptionResolver，我们可以声明一个WebMvcRegistrationsAdapter实例提供这些组件。 &nbsp;&nbsp;&nbsp;&nbsp;但是如果想全面控制Spring MVC，我们可以添加自己的@Configuration类，并使用@EnableWebMvc注解。这样Spring Boot就不会对MVC进行配置了。然后我们就可以像刚开始使用Spring MVC那样对他进行配置。 &nbsp;&nbsp;Spring MVC自动配置原理细节&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot对Spring MVC的自动配置主要是通过WebMvcAutoConfiguration这个类实现的，接下来我们就结合这个类来简单分析一下自动配置的细节。 ContentNegotiatingViewResolver 和 BeanNameViewResolver &nbsp;&nbsp;&nbsp;&nbsp;这两个一听名字就知道是和视图解析器有关，也确实是这样的，他们自动配置了ViewReslover，然后由ViewReslover得到View对象，View对象调用他的render方法渲染页面等等。其中BeanNameViewResolver 就是SpringMVC中的一个视图解析器，他可以通过视图名来获得视图解析器，而ContentNegotiatingViewResolver的作用就是组合所有的视图解析器，下面他们的源码： 12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; @Bean @ConditionalOnBean(View.class) @ConditionalOnMissingBean //只会创建一个 public BeanNameViewResolver beanNameViewResolver() &#123; BeanNameViewResolver resolver = new BeanNameViewResolver(); //给这个视图解析器设置执行顺序order，他的级别是很低的 resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; &#125; @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = \"viewResolver\", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; &#125;&#125; 问题：ContentNegotiatingViewResolver是如何组合所有视图解析器的？ 1234567891011121314151617181920212223242526272829303132333435public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered, InitializingBean &#123; @Nullable private List&lt;ViewResolver&gt; viewResolvers; @Override protected void initServletContext(ServletContext servletContext) &#123; Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values(); if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size()); //遍历BeanFactoryutils中的视图解析器 for (ViewResolver viewResolver : matchingBeans) &#123; if (this != viewResolver) &#123; //如果没有这个视图解析器，那就把它加入 this.viewResolvers.add(viewResolver); &#125; &#125; &#125;else &#123; for (int i = 0; i &lt; this.viewResolvers.size(); i++) &#123; ViewResolver vr = this.viewResolvers.get(i); if (matchingBeans.contains(vr)) &#123; continue; &#125; String name = vr.getClass().getName() + i; obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name); &#125; &#125; AnnotationAwareOrderComparator.sort(this.viewResolvers); this.cnmFactoryBean.setServletContext(servletContext); &#125;&#125; 因此，我们可以实现自己的视图解析器，然后ContentNegotiatingViewResolver把它注册到容器中。定制自己的视图解析器我们可以在启动类中实现ViewResolver接口，编写我们自己的视图解析器，然使用@Bean标签配置给IOC容器。 123456789101112131415161718192021222324252627282930313233343536package com.xust.iot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;@SpringBootApplicationpublic class SpringBootWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebApplication.class, args); &#125; //直接在容器中添加我们的视图解析器 @Bean public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; /** * 实现ViewResolver */ public static class MyViewResolver implements ViewResolver&#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; //在这里面写我们自己的视图处理逻辑 return null; &#125; &#125;&#125; Converter，GenericConverter，Formatter 这些功能在Spring Boot中也有默认的自动配置，这里我们要了解的是如何扩展配置Converter和Formatter。源码： 1234567891011121314151617181920@Bean@ConditionalOnProperty(prefix = \"spring.mvc\", name = \"date-format\")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125;//添加格式化组件@Overridepublic void addFormatters(FormatterRegistry registry) &#123; for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123; registry.addConverter(converter); &#125; for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123; registry.addConverter(converter); &#125; for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123; registry.addFormatter(formatter); &#125;&#125; 我们也可以定制自己的转换器 12345678910111213141516171819202122232425262728293031323334package com.xust.iot;import com.xust.iot.bean.User;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.core.convert.converter.Converter;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;@SpringBootApplicationpublic class SpringBootWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebApplication.class, args); &#125; @Bean public Converter&lt;?,?&gt; userToStringConverter()&#123; return new UserToStringConverter(); &#125; //把User对象转换成String public static class UserToStringConverter implements Converter&lt;User,String&gt;&#123; @Override public String convert(User source) &#123; //写我们自己的转换规则 return null; &#125; &#125;&#125; HttpMessageConverters &nbsp;&nbsp;&nbsp;&nbsp;Spring MVC 使用HttpMessageConverter 接口转换HTTP 请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用UTF-8编码。可以使用Spring Boot 的HttpMessageConverters 类添加或自定义转换类： 123456789101112131415161718192021222324@Configurationpublic class FastJsonHttpMessageConvertersConfig extends WebMvcConfigurerAdapter &#123; @Bean public FastJsonConfig fastJsonConfig() &#123; FastJsonConfig fastJsonConfig = new FastJsonConfig(); SerializerFeature writeMapNullValue = SerializerFeature.WriteMapNullValue; SerializerFeature WriteNullStringAsEmpty = SerializerFeature.WriteNullStringAsEmpty; SerializerFeature WriteNullNumberAsZero = SerializerFeature.WriteNullNumberAsZero; SerializerFeature WriteNullListAsEmpty = SerializerFeature.WriteNullListAsEmpty; fastJsonConfig.setSerializerFeatures(writeMapNullValue, WriteNullStringAsEmpty, WriteNullNumberAsZero, WriteNullListAsEmpty); return fastJsonConfig; &#125; @Bean public HttpMessageConverters fastJsonHttpMessageConverters( @Qualifier(\"fastJsonConfig\") FastJsonConfig fastJsonConfig) &#123; FastJsonHttpMessageConverter4 fastConverter = new FastJsonHttpMessageConverter4(); fastConverter.setFastJsonConfig(fastJsonConfig); HttpMessageConverter&lt;?&gt; converter = fastConverter; return new HttpMessageConverters(converter); &#125;&#125; &nbsp;&nbsp;扩展Spring Boot对Spring MVC的配置&nbsp;&nbsp;&nbsp;&nbsp;想要扩展Spring Boot的MVC功能，我们要WebMvcConfigurer接口，但是这样太麻烦了，因此Spring Boot提供了一个适配器类WebMvcConfigurerAdapter，它里面全部是一些空方法，我们可以继承WebMvcConfigurerAdapter类，然后我们只需要按照我们的需要重写里面的方法就好了。（注：Spring Boot 2.0以后官方废除了WebMvcConfigurerAdapter类，而是推荐我们直接实现WebMvcConfigurer接口。） 12345678910111213141516171819202122232425262728293031323334353637package com.xust.iot.configurer;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import java.util.List;@Configurationpublic class ApplicationMVCConfig extends WebMvcConfigurerAdapter &#123; //在这里可以配置拦截器，文件上传解析器，异常解析器....只要是在原本spring-mvc.xml文件中可以配置的在这里都可以配置 //视图映射 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //相当于&lt;mvc:view-controller path=\"/hello\" view=\"success.html\"/&gt; registry.addViewController(\"/hello\").setViewName(\"success\"); &#125; /** * 拦截器 拦截hello请求 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/hello\"); &#125; //异常解析处理器 @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; exceptionResolvers.add(new MyExceptionHandler()) ; &#125;&#125; &nbsp;&nbsp;全面接管Spring Boot对Spring MVC的自动配置&nbsp;&nbsp;&nbsp;&nbsp;官网中的一句话：”If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.“意思就是我们可以配置类上加上EnableWebMvc来全面接管Spring MVC，这样一来Spring Boot就不会对Spring MVC进行配置了，一切都需要我们来配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.xust.iot.configurer;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.view.InternalResourceViewResolver;@EnableWebMvc@Configurationpublic class ApplicationMVCConfig implements WebMvcConfigurer &#123; //在这里可以配置拦截器，文件上传解析器，异常解析器....只要是在原本spring-mvc.xml文件中可以配置的在这里都可以配置 //配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; InternalResourceViewResolver resourceViewResolver=new InternalResourceViewResolver(); resourceViewResolver.setPrefix(\"/**\"); resourceViewResolver.setSuffix(\"/.html\"); registry.viewResolver(resourceViewResolver); registry.order(10); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/hello\").setViewName(\"success.html\"); &#125; /** * 拦截器 拦截hello请求 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns(\"/hello\"); &#125; &#125;","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot—Thymeleaf模板引擎","date":"2019-08-28T06:56:25.000Z","path":"2019/08/28/Spring Boot—Thymeleaf模板引擎/","text":"&nbsp;&nbsp; 引言&nbsp;&nbsp;&nbsp;&nbsp;在做WEB开发的时候，我们不可避免的要在前端页面之间进行跳转，中间进行数据的查询等等操作。我们在使用Spring Boot之前包括我在内其实大部分都是用的是JSP页面，可以说使用的已经很熟悉。但是我们在使用Spring Boot开发框架以后我们会发现一个致命的问题，就是SpringBoot对Jsp的支持可以说是惨不忍睹，因此官方推荐我们使用Thymeleaf模板引擎来解决问题。目前而言，当然模板引擎有很多，比如Velocity、Freemarker、等等，但是我这一直感觉thymeleaf相对于其他的来说好用的还是不少的。在这里我们就来了解一下thymeleaf这个模板引擎的用法！ &nbsp;&nbsp; 什么是模板引擎？&nbsp;&nbsp;&nbsp;&nbsp;模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档。用于网站的模板引擎（比如Thymeleaf模板引擎）就是将模板文件和数据通过模板引擎生成一个HTML代码。 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。 &nbsp;&nbsp; Spring Boot中使用Thymeleaf模板引擎使用的方法很简单，首先在pom.xml文件中引入thymeleaf的starter 引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 一般Spring Boot引入的都是依赖文件的最新的版本，如果发现不是最新的依赖版本或者你想更改依赖的版本，可以在&lt;properties&gt;标签中修改，比如修改thymeleaf的版本为3.0.10版本 123456&lt;properties&gt; &lt;!--切换thymeleaf版本--&gt; &lt;thymeleaf.version&gt;3.0.10.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 使用Thymeleaf&nbsp;&nbsp;&nbsp;&nbsp;引入Thymeleaf的依赖后，我们就可以使用了。在学习Spring Boot时无论是啥新东西，我们都可以打开XxxxAutoConfigration和XxxxProperties，从中我们可以基本了解Spring Boot对这个东西的默认配置。好了我们来看看Thymeleaf的配置类 当然，我们也可以在Spring Boot的主配置文件中进行thymeleaf相关配置： 12345678#thymeleaf有关设置spring.thymeleaf.prefix=classpath:/templatesspring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.servlet.content-type=text/html#关闭模板缓存，避免更新无效spring.thymeleaf.cache=false 尝试使用1.在控制层写一个跳转到hello.html页面的处理器方法 123456789101112131415161718package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Map;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String toHello(Model model)&#123; model.addAttribute(\"msg\",\"Hello Thymeleaf!\"); return \"hello\"; &#125;&#125; 2.在html页面中导入thymeleaf名称空间，名称空间的导入不是必须的，但是导入后可以有提示，提示还是挺好用的。 12&lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt; 3.然后在页面只用Thymeleaf语法获取服务器响应的数据hello.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--thymeleaf中的th:text 作用是将等号后面值写到标签体内，会覆盖原有的值--&gt;&lt;h1 th:text=\"$&#123;msg&#125;\"&gt;这里显示欢迎信息&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp;&nbsp; Thymelaf模板引擎的基本语法常用th属性下面列举一些常用的th属性，全部的属性还请参考官方手册。th属性执行的优先级从1~8，数字越低优先级越高。 1、th:text：设置当前元素的文本内容，相同功能的还用th:utext,两者的区别是前者会转义特殊字符，后者不会。order=7 2、th:value：设置当前元素的value值，类似修改指定属性的还有th:src、th:herf,order=6 3、th:each：遍历循环元素，和th:value或th:value一起使用。order=2 4、th:if：条件判断，类似的还有th:unless 、th:switch、th:case 。order=3 5、th:insert：代码块引入，类似的还有th:replace、th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 6、th:fragment：定义代码块，方便被th:insert、th:replace、th:include引用。优先级最低：order=8 7、th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 8、th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5 Thymeleaf标准表达式语法 ${.....} 变量表达式（Variable Expressions） #{.....} 消息表达式（Message Expressions） @{.....} 链接表达式（Link URL Expressions） ~{.....} 代码块表达式（Fragment Expressions） *{.....} 选择变量表达式（Selection Variable Expressions） ${…}变量表达式Thymeleaf的变量表达式使用的其实是OGNL表达式，这使得变量表达式的功能非常丰富。 1、可以获取对象的属性、调用方法等(OGNL可以做的事他都可以做) 2、可以使用内置对象。官方手册上给的可以使用的内置对象如下： 12345678#ctx : the context object. 上下文对象#vars: the context variables. 上下文变量 #locale : the context locale. 本地区域信息//下面的内置对象下web环境下才有效果的#request : (only in Web Contexts) the HttpServletRequest object. request对象#response : (only in Web Contexts) the HttpServletResponse object. response对象 #session : (only in Web Contexts) the HttpSession object. session对象#servletContext : (only in Web Contexts)the ServletContext object. ServletContext对象 3、可以使用一些内置的工具对象(方法)。 123456789101112131415#execInfo : 正在处理的模板信息#messages : 获取外部信息的内部变量的一个实用方法，同时也可以用#&#123;...&#125;获取#uris : 针对URL或URI进行一些转码的方法#conversions : 根据配置执行一些转换方法#dates : java.util.Date 的对象#calendars : java.util.Calendar 的对象#numbers : 数值格式化方法#strings : 字符串格式化方法，常用的Java方法它都有#objects : java中Object类的一些方法#bools : 布尔方法，常用的方法有：isTrue，isFalse等#arrays : 数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等#lists ，#sets: 集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等#maps : map对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等#aggregates : 在数组或集合中创建聚合的一些实用方法.#ids : 用于处理可能重复的标识属性的使用方法，例如，作为迭代的变量。 *{…}选择表达式对于变量我们还可以使用*{...}来处理，它和${}在功能上是一样的。但是有一个重要的区别：*{}评估所选对象上的表达式而不是整个上下文。 也就是说，只要没有选定的对象，${}和*{}语法就会完全相同。下面是官网给的一个例子，可以说明这个问题： #{…}消息表达式用于处理国际化信息,下面是一个支持中英文的国际化登录页面 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;[[#&#123;login.topic&#125;]]&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link rel=\"shortcut icon\" th:href=\"@&#123;/favicon.ico&#125;\"/&gt; &lt;link rel=\"bookmark\" th:href=\"@&#123;/favicon.ico&#125;\"/&gt; &lt;link href=\"assert/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;link th:href=\"@&#123;/webjars/jquery/3.3.1-1/jquery.js&#125;\"&gt; &lt;link href=\"assert/css/signin.css\" th:href=\"@&#123;/assert/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard\" th:action=\"@&#123;/checkLogin&#125;\" method=\"post\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/assert/img/bootstrap-solid.svg&#125;\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.topic&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remeberme&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index(locale=zh_CN)&#125;\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\" th:href=\"@&#123;/index(locale=en_US)&#125;\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果： @{…}链接表达式Thymeleaf中专门用于定义超链接的表达式。配合Thymeleaf中的th:href、th:src等凡是可以写链接、路径的标签一起使用(前缀th:)，下面是几个例子： 12345678910111213&lt;!--引入资源文件--&gt;&lt;link rel=\"shortcut icon\" th:href=\"@&#123;/favicon.ico&#125;\"/&gt;&lt;link rel=\"bookmark\" th:href=\"@&#123;/favicon.ico&#125;\"/&gt;&lt;link href=\"assert/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt;&lt;script type=\"text/javascript\" src=\"assert/js/popper.min.js\" th:src=\"@&#123;assert/js/popper.min.js&#125;\"&gt;&lt;/script&gt;&lt;!--路径--&gt;&lt;a href=\"#\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-primary\"&gt;编辑&lt;/a&gt;&lt;a href=\"/emp/del/\" th:href=\"@&#123;/emp/del/&#125;+$&#123;emp.id&#125;\" th:value=\"$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger\" &gt;删除&lt;/a&gt; &lt;!--表单--&gt;&lt;form action=\"/emp/save\" th:action=\"@&#123;/emp/save&#125;\" method=\"post\" role=\"form\"&gt; &lt;input type=\"hidden\" name=\"id\" th:value=\"$&#123;emp.getId()&#125;\"/&gt; ~{…}代码块表达式Thymeleaf中专门用于引用代码片段的表达式。经常配合th:fragment和th:insert 、th:replace、th:include这四个属性使用（后三个属性中选一种，效果差不多，但是还是有细微的差别），例如： 12345678910&lt;!--使用th:fragement属性抽取公共页面：th:fragement=\"片段名\"--&gt;&lt;nav class=\"navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0\" th:fragment=\"topbar\"&gt; &lt;a class=\"navbar-brand col-sm-3 col-md-2 mr-0 \" style=\"align-content: center\" href=\"#\" th:href=\"@&#123;/main&#125;\" &gt;[[$&#123;session.loggedUser&#125;]]&lt;/a&gt; &lt;input class=\"form-control form-control-dark w-100\" type=\"text\" placeholder=\"Search\" th:placeholder=\"#&#123;main.search&#125;\" aria-label=\"Search\"&gt; &lt;ul class=\"navbar-nav px-3\"&gt; &lt;li class=\"nav-item text-nowrap\"&gt; &lt;a class=\"nav-link\" href=\"#\" th:href=\"@&#123;/signout&#125;\" th:text=\"#&#123;main.logout&#125;\"&gt;退出&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 在别的页面中就可以使用th:insert 、th:replace、th:include引入公共片段引入的就要用到~{} 表达式，具体的语法有两种： ~{templatename::selector}====&gt;模板名::选择器 ~{templatename::fragmentname}====&gt;模板名::片段名 其中模板名就是你引用的片段在templates/目录下的HTML文件名 12345678&lt;!--使用th:insert--&gt;&lt;div th:insert=\"~&#123;template :: topbar&#125;\"&gt;&lt;/div&gt;&lt;!--使用th:replace--&gt;&lt;div th:replace=\"~&#123;template&#125; :: topbar\"&gt;&lt;/div&gt;&lt;!--使用th:inclue--&gt;&lt;div th:include=\"~&#123;template :: topbar&#125;\"&gt;&lt;/div&gt; 使用th:insert 、th:replace、th:include都可以引入公共的代码片段，但是他们有一点细微的差别th:insert：按上面的代码来说就是会在&lt;div&gt;&lt;/div&gt;内把整个公共片段插入，这样一来原有的片段就会被套在&lt;div&gt;&lt;/div&gt;内部th:replace：在声明使用的地方替换原有的标签为要引入的代码片段（就是把原生的代码片段发在要插入的地方）th:include：将被引入的片段的内容包含进这个标签中","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot 对静态文件的默认映射规则","date":"2019-08-28T02:00:02.000Z","path":"2019/08/28/SpringBoot映射映射静态文件的规则/","text":"Webjars(官网：http://www.webjars.org/)​ webjars：以jar包的方式引入静态资源；Spring Boot中所有 /webjars/** ，都会去 classpath:/META-INF/resources/webjars/ 找资源。推荐使用Webjars的三大理由： 将静态资源版本化，更利于升级和维护。 剥离静态资源，提高编译速度和打包效率。 实现资源共享，有利于统一前端开发。 使用方法首先来看一下源码是如何以jar包的方式引入静态资源的： 1234567891011121314151617181920@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(\"Default resource handling disabled\"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 原来是直接到jar包类路径/META-INF/resources/webjars/下来找静态资源的。使用方法很简单，只用引入Maven依赖就可以了。在Webjars官网找到需要的依赖，例如在pom.xml中引入jQuery和BootStrap 12345678910111213&lt;!--引入jquery--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入BootStrap--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 引入之后我们可以尝试访问一下BootStrap里面的东西，在地址栏输入localhost/webjars/bootstrap/4.0.0/webjars-requirejs.js，如果能看到下面的页面那就没问题。 引入自己的静态资源文件自己的资源文件可以放在一下几个地方： 123456静态资源文件夹&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, //系统默认生成的&quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径下 WebMvcAutoConfiguration.java 123456789@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; //设置欢迎页（首页）的构造方法中大有乾坤，我们可以点进去看看 WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors()); return welcomePageHandlerMapping;&#125; WelcomePageHandlerMapping.java 12345678910111213//WelcomePageHandlerMapping唯一的一个构造方法WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; \"/**\".equals(staticPathPattern)) &#123; //检查发现欢迎页面存在兵并且在静态资源文件夹下，默认就会forward到index.html页面 logger.info(\"Adding welcome page: \" + welcomePage.get()); setRootViewName(\"forward:index.html\"); &#125;else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; //检查发现欢迎页面没有，那就设置欢迎页面的视图名是index logger.info(\"Adding welcome page template: index\"); setRootViewName(\"index\"); &#125;&#125; 简单分析源码可以知道，Spring Boot欢迎页面的处理机制是如果没有欢迎页面那就默认叫index.html，如果有并且在静态资源文件夹中，那就以forward的方式请求转发过去。根据上面的分析，设置首页就简单了，把首页起名为index.html，然后把它放在任何一个静态文件夹中就可以不被映射到，之后直接访问localhost:8080/就可以访问到首页把静态资源放在classpath:/public/ 来看看效果 给网页设置小图标先来看看源码是如何做的。 1234567@Beanpublic SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); mapping.setUrlMap(Collections.singletonMap(\"**/favicon.ico\", faviconRequestHandler())); return mapping;&#125; 从源码的倒数第二行可以看到，他会在映射到**/favicon.ico这个目录，那就简单了，我们只需要只需要将把我们的图标命名为favicon.ico，然后放在任一静态资源文件夹下即可。在classpath:/public/放一个我自己的图标 启动来看看效果： 很nice！我们的小图标被用上了。 使用spring.resources.static-locations改变静态资源文件夹在Spring Boot的主配置文件中，我们可以使用spring.resources.static-locations来指定静态资源文件的位置，可以指定多个，多个路径之间用”,”（逗号）隔开。需要注意的是，我们这么指定后，那些默认的资源文件夹就会失效。 123debug=trueserver.port=80spring.resources.static-locations=classpath:/webapps,classpath:/pages 在resources下新建webapps文件夹，把静态资源放在里面。 启动来看看效果：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SpringBoot与日志","date":"2019-08-27T03:51:47.000Z","path":"2019/08/27/SpringBoot日志配置/","text":"&nbsp;&nbsp; 日志框架分类目前，日志框架有很多，例如：JUL（java.util.logging）、JCL（Apache Jakarta Commons Logging）、Log4j、Log4j2、LogBack、SLF4J、jboss-logging等等。 日志门面日志实现 JCL（Apache Jakarta Commons Logging）SLF4J(Simple Logging Facade for Java)jboss-loggingLog4jJUL(java.util.logging)Log4j2Logback &nbsp;&nbsp;&nbsp;&nbsp;日志门面就是日志的抽象层，里面只是定义了日志的规范，日志实现就是来具体实现日志门面的。日志门面中这里重点来介绍一下SLF4J。 SLF4J&nbsp;&nbsp;&nbsp;&nbsp;slf4j是对所有日志框架制定的一种规范、标准、接口，并不是一个框架的具体的实现。因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）。 那么问题来了，我们有了日志的实现，为什么还需要日志门面（日志抽象层）？ &nbsp;&nbsp;&nbsp;&nbsp;我们都知道使用一个接口实际上使用的是这个接口的实现类，那好了，我只要在程序中使用接口中的API来操作日志，然后导入实现了这个日志接口的日志实现类，程序就可以正常的记录日志；下次我们导入了另一套基于这个接口实现的日志实现类，不用改我们在程序中写的任何日志代码程序还是可以正常的记录日志。原理很简单，日志实现类实现了日志接口的规范。因此这个问题的回答总结为一句话：使用日志框架接口更便于更换为其他的日志框架。 &nbsp;&nbsp;&nbsp;&nbsp;log4j、logback、log4j2都有SLF4J的具体实现，他们既可以单独使用，也可以结合SLF4J框架使用。 相关的Maven依赖写法： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Log4J&nbsp;&nbsp;&nbsp;&nbsp;log4j是apache实现的一个开源日志组件。通过使用log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。然而log4j已经很多年没有更新过了，小项目可以使用，大项目还是算了吧。 相关的Maven依赖写法： 123456789101112&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Logback&nbsp;&nbsp;&nbsp;&nbsp;logback同样是由log4j的作者设计完成的，拥有更好的特性，是用来取代log4j的一个日志框架，是slf4j的原生实现，所以logback与slf4j的结合最好。&nbsp;&nbsp;&nbsp;&nbsp;Logback，一个“可靠、通用、快速而又灵活的Java日志框架”。logback当前分成三个模块：logback-core，logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。 因此在log4j和logback之间选择的话，我们应该选择更强大的logback。理由如下： 1. logback比log4j要快大约10倍，而且消耗更少的内存。 2. logback-classic模块直接实现了SLF4J的接口，所以我们迁移到logback几乎是零开销的。 3. logback不仅支持xml格式的配置文件，还支持groovy格式的配置文件。相比之下，Groovy风格的配置文件更加直观，简洁。 4. logback-classic能够检测到配置文件的更新，并且自动重新加载配置文件。 5. logback能够优雅的从I/O异常中恢复，从而我们不用重新启动应用程序来恢复logger。 6. logback能够根据配置文件中设置的上限值，自动删除旧的日志文件。 7. logback能够自动压缩日志文件。 8. logback能够在配置文件中加入条件判断（if-then-else)。可以避免不同的开发环境（dev、test、uat…）的配置文件的重复。 9. logback带来更多的filter。 10. logback的stack trace中会包含详细的包信息。 11. logback-access和Jetty、Tomcat集成提供了功能强大的HTTP-access日志。 相关的Maven依赖写法： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt; log4j2引用官网的一句话Apache Log4j 2 is an upgrade to Log4j that provides significant improvements over its predecessor, Log4j 1.x, and provides many of the improvements available in Logback while fixing some inherent problems in Logback’s architecture.翻译过来就是说：Apache Log4j 2是对Log4j的升级，它比其前身Log4j 1.x提供了重大改进，并提供了Logback中可用的许多改进，同时修复了Logback架构中的一些固有问题。Log4j2的特性： 1. 插件式结构。Log4j 2支持插件式结构。我们可以根据自己的需要自行扩展Log4j2. 我们可以实现自己的appender、logger、filter。 2. 配置文件优化。在配置文件中可以引用属性，还可以直接替代或传递到组件。而且支持json格式的配置文件。不像其他的日志框架，它在重新配置的时候不会丢失之前的日志文件。 3. Java 5的并发性。Log4j 2利用Java 5中的并发特性支持，尽可能地执行最低层次的加锁。解决了在log4j 1.x中存留的死锁的问题。 4. 异步logger。Log4j2是基于LMAX Disruptor库的。在多线程的场景下，和已有的日志框架相比，异步的logger拥有10倍左右的效率提升。 相关的Maven依赖写法： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j2异步日志需要加载disruptor-3.0.0.jar或者更高的版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--如果还要使用slf4j可以导入下面的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; &nbsp;&nbsp; 日志框架的使用SLF4J 什么时候使用SLF4J比较合适呢？ &nbsp;&nbsp;&nbsp;&nbsp;如果你开发的是类库或者嵌入式组件，那么就应该考虑采用SLF4J，因为不可能影响最终用户选择哪种日志系统。在另一方面，如果是一个简单或者独立的应用，确定只有一种日志系统，那么就没有使用SLF4J的必要。 如何在系统中使用SLF4J?(官网:https://www.slf4j.org/manual.html)下面是官网给的一个使用实例，以后如果要是用SLF4J,那就不要直接调用实现类的API，而是应该调用SLF4J里面的API，当然只是使用日志实现类另当别论！ 12345678910import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); //输出一个info级别的日志 logger.info(\"Hello World\"); &#125;&#125; Log4J&nbsp;&nbsp;&nbsp;&nbsp;log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、数据库等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 &nbsp;&nbsp;&nbsp;&nbsp;Log4j有7种不同的log级别，按照等级从低到高依次为：TRACE、DEBUG、INFO、WARN、ERROR、FATAL、OFF。如果配置为OFF级别，表示关闭log。 Log4j支持两种格式的配置文件：properties和xml。包含三个主要的组件：Logger、appender、Layout。 一个简单的log4j配置文件 1234567891011121314151617181920212223242526272829303132333435### set log levels ### log4j.rootLogger = INFO , console , debug , error ### console ### log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n ### log file ### log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.File = xzy_mybatis.log log4j.appender.debug.Append = true log4j.appender.debug.Threshold = INFO log4j.appender.debug.layout = org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n ### exception ### log4j.appender.error = org.apache.log4j.DailyRollingFileAppender log4j.appender.error.File = xzy_mybatis.log log4j.appender.error.Append = true log4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayout log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n # LOG4J配置log4j.rootCategory=INFO,stdout,jdbc# 数据库输出log4j.appender.jdbc=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.jdbc.driver=com.mysql.jdbc.Driverlog4j.appender.jdbc.URL=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=truelog4j.appender.jdbc.user=rootlog4j.appender.jdbc.password=rootlog4j.appender.jdbc.sql=insert into log_icecoldmonitor(level,category,thread,time,location,note) values('%p','%c','%t','%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;','%l','%m') 在Spring Boot中使用log4j&nbsp;&nbsp;&nbsp;&nbsp;首先创建一个Spring Boot工程，在创建Spring Boot工程时，我们引入了spring-boot-starter，其中包含了spring-boot-starter-logging，由于Spring Boot默认的日志框架是Logback，所以我们在引入log4j之前，需要先排除该包的依赖，再引入log4j的依赖。 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;&lt;/dependency&gt; 配置log4j-spring.properties &nbsp;&nbsp;&nbsp;&nbsp;配置文件的编写方法上面介绍的没有啥区别，但是配置文件的名字可以是log4j-spring.properties也可以是log4j.properties，但是Spring Boot官方推荐的命名方式是第一种方式。配置文件的内容参考上面。在Spring Boot主配置文件中指定日志文件的配置 1loggin.config=classpath:log4j-spring.properties Logback logblack的加载顺序SLF4J+Logback是Spring Boot默认的日志策略，logback支持xml和groovy形式的配置文件，而且还支持编程式地配置，它加载配置文件的顺序： 在 classpath 中寻找 logback-test.xml文件 如果找不到 logback-test.xml，则在 classpath 中寻找 logback.groovy 文件 如果找不到 logback.groovy，则在 classpath 中寻找 logback.xml文件 如果上述的文件都找不到，则 logback 会使用 JDK 的 SPI 机制查找 META-INF/services/ch.qos.logback.classic.spi.Configurator 中的 logback 配置实现类，这个实现类必须实现 Configuration 接口，使用它的实现来进行配置 如果上述操作都不成功，logback 就会使用它自带的 BasicConfigurator 来配置，并将日志输出到 console 在Spring Boot中使用LogBack(官网：https://logback.qos.ch/documentation.html)前面说过，logback是Spring Boot默认的日志系统，假如对日志没有特殊要求，可以完全零配置使用 SLF4J（Simple Logging Facade For Java）的logback来输出日志。LogBack的日志等级有ERROR、WARN、INFO、DEBUG、TRACE5级日志等级，等级由左至右等级又高到底。没有FATAL，他被分类到ERROR。 12345678910111213141516171819202122package com.jianeye.test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;SpringBootApplicationpublic class TestApplication &#123; private static Logger logger = LoggerFactory.getLogger(TestApplication.class); public static void main(String[] args) &#123; logger.warn(\"logback --------------------------------\\n\"); SpringApplication.run(TestApplication.class, args); logger.trace(\"trace log**********\\n\"); logger.info(\"default log**************\\n\"); logger.debug(\"dubug log***********\\n\"); logger.wran(\"warn log**********\\n\"); logger.error(\"error log*******\\n\"); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;上面这段程序，不经过任何配置，默认的日志系统是完全可以正常运行的。但是Spring Boot也支持我们修改默认配置，修改的方式有两种，一种是在src/main/resources下新建logback-spring.xml文件（logback.xml也可以，但官方推荐前面的写法）；第二种是直接在Spring Boot主配置文件中配置，下面是简单的配置示例：logbac-spring.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.springboot.sample\" level=\"TRACE\" /&gt;&lt;/configuration&gt; application.properties 123456789101112131415161718192021222324252627debug=trueserver.port=80server.servlet.context-path=/book#指定配置文件的名字#logging.config.name=logback-spring.xml#配置文件的位置，#logging.config.location=classpath:logback-spring.xml#指定输出文件，当不指定路径时，默认将在当前项目路径下创建日志文件。#logging.file=logback-spring.log#也可以指定路径到硬盘的具体的某个路径，如果某及路径不存在就会创建logging.file=G://log/logback-spring.log#控制台输出的日期格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#日期输出格式logging.pattern.dateformat=HH:mm:ss.sss#指定输出到文件的日志格式logging.pattern.file=file-%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n#指定日志中日志级别输出的格式logging.pattern.level=custom-%5p#调整根目录级别的日志级别logging.level.root=WARN#调整特定文件的日志级别 logging.level.文件名=日志级别logging.level.com.xust=INFOlogging.level.org.springframework=DEBUG 扩展使用springProperty&nbsp;&nbsp;&nbsp;&nbsp;在logback-spring.xml中可以使用Spring Boot扩展的，使用它可以把在application.properties中定义的属性值映射为logback环境中的一个属性，从而可以在logback的上下文使用。 1234567891011&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; &lt;!--可以指定某段配置只在某个环境下生效--&gt;&lt;/springProfile&gt;&lt;springProfile name=\"dev | staging\"&gt; &lt;!-- configuration to be enabled when the \"dev\" or \"staging\" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=\"!production\"&gt; &lt;!-- configuration to be enabled when the \"production\" profile is not active --&gt;&lt;/springProfile&gt; 举个例子：&nbsp;&nbsp;&nbsp;&nbsp;下面的配置中定义了属性appName对应于Spring Boot的Environment中的app.name（由source属性指定），当未指定时默认使用defaultValue属性指定的TEST；属性name对应于Spring Boot的Environment中的logging.path，未指定时使用/logs/${appName}.log，其中的${appName}又对应于变量appName的值。定义好的变量可以在logback的配置文件中以${varName}的形式进行引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748logback-spring.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;include resource=\"org/springframework/boot/logging/logback/base.xml\" /&gt; &lt;logger name=\"org.springframework.web\" level=\"INFO\"/&gt; &lt;logger name=\"org.springboot.sample\" level=\"TRACE\" /&gt; &lt;springProfile name=\"dev\"&gt; &lt;logger name=\"org.springboot.sample\" level=\"DEBUG\" /&gt; &lt;/springProfile&gt; &lt;springProfile name=\"staging\"&gt; &lt;logger name=\"org.springboot.sample\" level=\"INFO\" /&gt; &lt;/springProfile&gt; &lt;!-- %d ：表示日期时间 %thread ：表示线程名 %-5level ：级别从左显示5个字符宽度，- 表示左对齐 %logger&#123;50&#125; ：表示 logger 名字最长为50个字符，否则按照句号分割 %msg ：表示日志消息 %n ：表示换行--&gt; &lt;springProfile&gt; &lt;appender name=\"stdOut\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;dev&#125;-%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name=\"fileOut\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;logPath&#125;&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;logPath&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--log root的日志级别--&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"stdOut\" /&gt; &lt;appender-ref ref=\"fileOut\" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; &nbsp;&nbsp; 多个不同的日志框架兼容SLF4J&nbsp;&nbsp;&nbsp;&nbsp;经常在实际的开发环境中，我们会使用到不同的框架，而且不同的框架默认的日志系统不同，那么如何在Spring Boot中设置一下，让这些不同框架的默认日志系统可以借助于Spring Boot的默认日志系统来工作？这是可以办到的,具体的步骤如下：1、在pom.xml文件中导入依赖的时候排除所使用框架对默认日志系统的依赖2、用SLF4J提供的中间包替换原有日志框架下图有详细的配置方法：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot自动配置原理（深入源码）","date":"2019-08-26T10:37:17.000Z","path":"2019/08/26/SpringBoot自动配置原理/","text":"&nbsp;&nbsp; 引言&nbsp;&nbsp;&nbsp;&nbsp;不论在工作中，亦或是求职面试，Spring Boot已经成为我们必知必会的技能项。除了某些老旧的政府项目或金融项目持有观望态度外，如今的各行各业都在飞速的拥抱这个已经不是很新的Spring启动框架。 &nbsp;&nbsp;&nbsp;&nbsp;当然，作为Spring Boot的精髓，自动配置原理的工作过程往往只有在“面试”的时候才能用得上，但是如果在工作中你能够深入的理解Spring Boot的自动配置原理，将无往不利。 &nbsp;&nbsp;&nbsp;&nbsp;Spring Boot的出现，得益于“习惯优于配置”的理念，没有繁琐的配置、难以集成的内容（大多数流行第三方技术都被集成），这是基于Spring 4.x提供的按条件配置Bean的能力。 &nbsp;&nbsp; Spring Boot自动配置原理配置文件到底能写什么？怎么写？自动配置原理？&nbsp;&nbsp;&nbsp;&nbsp;我们一接触Spring Boot的时候就了解到：Spring Boot有一个全局配置文件application.properties或application.yml。我们的各种属性都可以在这个文件中进行配置，最常配置的比如：server.port、logging.level.* 等等，然而我们实际用到的往往只是很少的一部分，而且可以在主配置文件中配置的属性都可以在官方文档中查找到：https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties @EnableAutoConfiguration&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot在从启动类启动，启动类上有@SpringBootApplication注解，这个注解是Spring Boot的核心注解，那么自动配置原理一定和这个注解有着千丝万缕的联系！ 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; //省略&#125; &nbsp;&nbsp;&nbsp;&nbsp;点开@SpringBootApplication源码，这里面最重要的就是@SpringBootConfiguration和@EnableAutoConfiguration，前者是Spring Boot的配置注解，底层使用的是@Configuration这个注解，后者翻译他的名字就知道这是开启自动配置，它是Spring Boot自动配置的核心。于是，让我们点进去看看里面的乾坤。 12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，EnableAutoConfiguration注解内部的代码那是非常的简单，但是@Import(AutoConfigurationImportSelector.class)这个注解引起了我的好奇，@Import这个注解我们都不陌生，他的作用无外乎这几种：@Configuration注解的配置类、声明@Bean注解的bean方法、导入ImportSelector的实现类或导入ImportBeanDefinitionRegistrar的实现类。按照他的写法，他是导入了ImportSelector的实现类AutoConfigurationImportSelector。它的核心方法就是 selectImports(..)，它表明哪些自动配置类是要加入到容器中，在Spring Boot 2.1.7.RELEASE版本中得源码如下： 1234567891011@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125; 继续追踪源码，可以看到getAutoConfigurationEntry（..)这个方法，其中configurations存放的数据就是加入容器的自动配置类的完整包路径 12345678910111213141516171819protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); //扫描具有META-INF/spring.factories文件的jar包 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //去掉重复的配置 configurations = removeDuplicates(configurations); //删除需要排除的类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125; 而从getCandidateConfigurations(..)中，我们发现他调用SpringFactoriesLoader.loadFactoryNames产生了一个List，返回的东西是啥呢？继续往下看 1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations;&#125; 我们继续往下看，发现他确实最终在loadFactories方法中使用本类的一个私有静态方法loadSpringFactories加载了META-INF/spring.factories这个配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class SpringFactoriesLoader &#123; /** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\"; public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); &#125; private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125; &#125;&#125; 查看spring-boot-autoconfigure包下META-INF/spring.factories： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384......# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration...... 看到的非常多的xxxxAutoConfiguration类，这些类都是容器中的一个组件，加入到容器中，用他们做自动配置。 总结—Spring Boot自动配置的精髓&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot启动的时候会加载大量的自动配置类xxxxAutoConfiguration（就如在spring.factories那些类），当我们需要的功能在Spring Boot中恰好有默认的自动配置类，那么这个自动配置类在Spring Boot中一定有一个对应的XxxPropertoes类（相当于对应自动配置类的配置文件），这个类中有很多的属性，我们可以使用人家Spring Boot默认的属性值，但是当这些默认值无法满足我们的需求的时候，我们也可以在主配置文件中来使用XxxPropertoes类中的属性来配置我们需求的值。 &nbsp;&nbsp; @Conditional派生注解然而，虽然Spring Boot在启动的时候加载了全部的自动配置类，但是不是所用的这些类都是可以使用的，只有符合条件的自动配置类才可以使用，用于判断的就是这些@ConditionalXxx注解 @Conditional扩展注解作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication当前是web环境 @ConditionalOnNotWebApplication当前不是web环境 @ConditionalOnJndiJNDI存在指定项 问：如何知道哪些自动配置类生效了，哪些配置类没有生效？我们可以通过在主配置文件中配置 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。如下：","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SpringBoot配置文件详解","date":"2019-08-25T08:12:31.000Z","path":"2019/08/25/SpringBoot配置文件详解/","text":"Spring Boot配置文件&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot支持两种形式的配置文件，分别是.properties、和.yml，而且配置文件的名字是固定不可变的： application.properties application.yml &nbsp;&nbsp;&nbsp;&nbsp;配置文件的作用是修改Spring Boot自动配置的默认值。相对于properties文件而言，yml文件更年轻。当application.properties文件和application.yml同时存在的时候，application.properties会优先加载，application.yml则后加载，而且在applicatin.properties中已经加载的属性如果在application.yml中再次出现会被忽略，如果是application.yml中的独有的属性则会加载。这里面有很多的坑。下面我们就来一起学习一下吧。 YAML/YML文件简介什么是YAML/YML文件？&nbsp;&nbsp;&nbsp;&nbsp;YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递回缩写。YAML 是一个可读性高，用来表达资料序列的编程语言。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YAML以数据为中心，比json、xml等更适合做配置文件。 YAML/YML的基本语法 基本语法：key: value，key: 和value中间要有一个空格,而且key: value的形式可以写无限层。还有一下规则：1.大小写敏感2.使用缩进表示层级关系3.缩进时不允许使用Tab键，只允许使用空格。4.缩进的空格数目不重要，只要相同层级的元素左侧对齐即可5.只有一种注释方式，使用# YAML/YML支持的数据结构YML支持3中类型的数据结构类型 1.字面量2.对象（属性和值），Map（键值对）3.数组（List、Set） 1、字面量具体包括：字符串、布尔值、整数、浮点数、Null、时间、日期字面量可以直接使用，但是特别注意字符串的字面量在写的时候是不需要引号的（无论单引号还是双引号）。单/双引号在yml语法中有特殊的含义：​ “”：双引号；会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ”：单引号；不会转义特殊字符，特殊字符最终只是一个普通的字符串数据name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 2.对象（属性和值），Map（键值对）基本的语法还是key：value，以一个例子来说明： 123friends: lastName: zhangsan age: 20 对应的行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 3.数组（List、Set）用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 举个栗子：配置一个Person的信息 123456789101112131415161718192021222324package com.xust.iot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * 但是要特别注意:只有这个组件是容器中的组件，容器才能提供@ConfigurationProperties的功能； */@Component@ConfigurationProperties(prefix=\"person\")public class Person &#123; private String name; private Integer age; private Address address; private Map&lt;String,Object&gt; map; private List&lt;String&gt; list; //省略getter setter和toStrig方法 123456789101112package com.xust.iot.bean;public class Address &#123; private String province; private String city; private String county; private String street; //省略getter setter和toStrig方法&#125; 我们可以导入配置文件处理器，编写配置的时候就有提示了 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 在application.yml配置文件中配置preson信息： 12345678910111213141516#写yml配置的时候要特别注意key和value之间要有一个空格，同级属性左对齐person: name: 李四 age: 20 map: key1: value1 key2: value2 list: - hello - hi - bye address: province: 陕西 city: 西安 county: xx street: xx 在SpringBoot测试类中测试IOC是否可以拿到在配置文件中配置的信息 12345678910111213141516171819202122package com.xust.iot;import com.xust.iot.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootConfigApplicationTests &#123; @Autowired Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; 测试结果： properties文件简介&nbsp;&nbsp;&nbsp;&nbsp;properties文件大家经常用，这里就简单介绍一下。其语法结构形如：key=value。注意中文乱码问题，需要转码成ASCII。在IDEA中可以设置自动转换把uft-8格式自动转成ASCII，设置方式是：依次点击【File】=&gt;【Other Settings】=&gt;【settigs for new projects】，搜索File Encodings，然后做如下配置： 上面Person信息的properties配置如下： 123456789person.name=小明person.age=20person.address.province=陕西person.address.city=西安person.address.county=xxperson.address.street=xxperson.map.key1=value1person.map.key2=value2person.list=hello,hi,bye 配置文件值注入@Value获取值和@ConfigurationProperties获取值比较&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot通过ConfigurationProperties注解从配置文件中获取属性。从上面的例子可以看出ConfigurationProperties注解可以通过设置prefix指定需要批量导入的数据。支持获取字面值，集合，Map，对象等复杂数据。ConfigurationProperties注解还有其他特么呢？它和Spring的Value注解又有什么区别呢？带着这些问题，我们继续往下看。 比较@ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 何时使用@Value何时使用@ConfigrationProperties？ 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。 配置文件注入值数据校验使用@Vaildatad可以给配置的属性数据校验功能。可以用在类、方法、参数上。可以加的验证注解如下： 12345678910111213141516@Null //限制只能为null@NotNull //限制必须不为null@AssertFalse //限制必须为false@AssertTrue //限制必须为true@DecimalMax(value) //限制必须为一个不大于指定值的数字@DecimalMin(value) //限制必须为一个不小于指定值的数字@Digits(integer,fraction) //限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction@Future //限制必须是一个将来的日期@Max(value) //限制必须为一个不大于指定值的数字@Min(value) //限制必须为一个不小于指定值的数字@Past //验证注解的元素值（日期类型）比当前时间早@Pattern(value) //限制必须符合指定的正则表达式@Size(max,min) //限制字符长度必须在min到max之间@NotEmpty //验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）@NotBlank //验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank //只应用于字符串且在比较时会去除字符串的空格@Email //验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 下面举个例子： 1234567891011121314151617181920212223242526272829@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; @NotEmpty @Size(max = 5, min = 2) private String name; @Max(70) @Min(10) private Integer age; @Past private Date birth; @NotEmpty private Address address; @NotEmpty private Map&lt;String, Object&gt; map; @NotEmpty private List&lt;String&gt; list; //省略getter setter和toStrig方法 &#125; @PropertySource&amp;@ImportResource&amp;@Bean @PropertySource：加载指定的配置文件； person.properties 12345678910person.name=小明person.age=20person.address.province=陕西person.address.city=西安person.address.county=xxperson.address.street=xxperson.map.key1=value1person.map.key2=value2person.list=hello,hi,byeperson.birth=2019/04/5 123456789101112131415161718192021222324252627282930313233343536373839404142package com.xust.iot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.*;import java.util.Date;import java.util.List;import java.util.Map;//使用PropertySource注解指定配置文件的路径，SpringBoot就会在启动的时候加载，然后把配置中的值赋给这个配置类的对应属性。@PropertySource(value = &#123;\"classpath:personInfo.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; @NotEmpty @Size(max = 5, min = 2) private String name; @Max(70) @Min(10) private Integer age; @Past private Date birth; private Address address; @NotEmpty private Map&lt;String, Object&gt; map; @NotEmpty private List&lt;String&gt; list; //省略getter setter和toStrig方法&#125; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 在src/main/resources下新建一个Spring配置文件applicationContext.xml 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.xust.iot.bean.Address\"&gt; &lt;property name=\"province\" value=\"陕西\"/&gt; &lt;property name=\"city\" value=\"汉中\"/&gt; &lt;property name=\"county\" value=\"xxx\"/&gt; &lt;property name=\"street\" value=\"xxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在Spring Boot的主程序类中使用@ImportResource引入配置这个配置文件 然后在测试类中自动注入ApplicationContext来拿这个组件 1234567891011121314151617181920212223242526package com.xust.iot;import com.xust.iot.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootConfigApplicationTests &#123; @Autowired ApplicationContext ioc; @Test public void contextLoads() &#123; System.out.println(ioc.containsBean(\"address\")); System.out.println(ioc.getBean(\"address\").toString()); &#125;&#125; 测试结果： 虽然这种方式可以用，但是一般我们不这么用，而且Spring Boot也不推荐这么使用，Spring Boot推荐使用全注解的方式来添加配置文件。 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 接下类，我们在com.xust.iot基包下新建配置类ApplicationConfig.java 123456789101112131415161718192021222324package com.xust.iot;import com.xust.iot.bean.Address;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//使用@Configuration告诉Spring这是配置@Configurationpublic class ApplicationConfig &#123; //@Bean注解相当于&lt;bean&gt;&lt;/bean&gt;标签,特别注意：方法名就是bean的id @Bean public Address address()&#123; System.out.println(\"在配置类中使用@Bean注解添加了组件\"); Address address=new Address(); address.setProvince(\"陕西省\"); address.setCity(\"西安\"); address.setCounty(\"xxx\"); address.setStreet(\"xxx\"); return address; &#125;&#125; 运行后得到的效果一样： 配置文件占位符在application.properties和application.yml文件可以使用${random}来设置随机值 常用随机设值如下1234567$&#123;random.value&#125; //随机生成一个32位的字符串，如：b21d56d2f10d74f84608dfff01b25552$&#123;random.int&#125; //随机生成一个int范围的随机数$&#123;random.long&#125; //随机生成一个int范围的随机数$&#123;random.int(10)&#125; //随机生一个[0,10]之间的随机数$&#123;random.int[1024,65536]&#125; //随机生成一个[1024,65536]之间的随机数$&#123;对象.属性&#125; //使用某个已配置的属性的值$&#123;对象.属性:默认值&#125; //使用某个已配置的属性的值，如果没有就是用默认值 在application.yml文件中写如下配置： 12345678910111213141516person: name: 李四$&#123;random.uuid&#125; age: $&#123;random.int(45,70)&#125; birth: 2019/08/24 map: key1: 232424@qq.com key2: dad323@163.com list: - hello - hi - bye address: province: 陕西 city: 西安 county: $&#123;person.name&#125; street: $&#123;person.address.province&#125;-$&#123;person.address.city&#125; 在测试类中打印person的信息，结果如下： Spring Boot profile&nbsp;&nbsp;&nbsp;&nbsp;Spring支持对不同环境，提供不同配置，可以通过激活、指定参数等方式快速的切换环境 。环境profile可以是开发环境（develop）、测试环境（fuy）、生产环境（production）等 配置多个profile在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 下面分别编写application-develop.properties和application-production.propertiesapplication-develop.properties 123debug=trueserver.port=8081server.servlet.acontext-path=/book application-production.properties 123debug=falseserver.port=80server.servlet.context-path=/book 目录结构： 在主配置文件application.properties中，使用spring.profiles.active=[profile]来激活不同的环境，如下激活develop环境： 启动Spring Boot观察Tomcat启动的端口 激活生产环境：spring.profiles.active=production 可以看到，配置的不同环境被激活后都起作用了。这在以后的开发中无疑是个十分强大而且方便的功能。 YML配置多个profile然而使用properties文件配置不同环境还是太麻烦了，YML对多profile的支持更加简单粗暴，配置示例： 123456789101112131415161718192021222324server: port: 8083spring: profiles: active: production #激活生产环境---#开发环境server: port: 8083 servlet: context-path: /bootdebug: truespring: profiles: develop #使用spring.profiles来指定这个环境名--- #使用连续的三个横线分隔不同的profile(文档区)#生产环境server: port: 80 servlet: context-path: /bootdebug: truespring: profiles: production 注意：Spring Boot启动的时候会优先加载.properties的文件，然后才来加载.yml文件，如果要想使applicaton.yml中配置的信息可以使用，那么.properties中不能有和.yml相同的配置。 总结激活指定profile的不同方式1、在配置文件中指定 spring.profiles.active=dev，上面的配置方式就是这种。 ​ 2、命令行：可以在IDEA中配置 –spring.profiles.active=develop 来启动开发环境，操作如下： 也可以在命令行中使用java -jar spring_boot_config-0.0.1-SNAPSHOT.jar --spring.profiles.active=develop来启动开发环境 3、虚拟机参数： 可以在IDEA中做如下配置：-Dspring.profiles.active=dev，示例如下： 配置文件的加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 这些位置的配置文件加载的优先级由高到底，而且高优先级的配置如果在低优先即中出现，那么低优先优先级中重复配置不会生效。但是低优先级中独有的配置还是会生效。也就是说SpringBoot会从这四个位置全部加载主配置文件；并且会互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 比如：项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；首先在硬盘的另一个地方(我这里在E://)创建application.properties。添加如下配置： 123debug=falseserver.port=8087server.servlet.context-path=/book 然后可以在命令行输入java -jar spring_boot_config-0.0.1-SNAPSHOT.jar --spring.config.location=E://application.properties 外部配置加载顺序SpringBoot也可以从以下位置加载配置，加载顺序的优先级从高到低；高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置。 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring_boot_config-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开；--配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile的配置文件 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile的配置文件 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源参考官方文档。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"Spring Boot快速入门","date":"2019-08-24T11:03:54.000Z","path":"2019/08/24/SpringBoot快速入门/","text":"SpringBoot 2.x 中文文档 入门环境准备&nbsp;&nbsp;&nbsp;&nbsp;在本地安装3.3版本以上的Maven，以及JDK1.7以上的java环境，然后在IDEA【settings】=&gt;【File | Settings | Build, Execution, Deployment】=&gt;【Maven】，设置如下内容： 创建SpringBoot HelloWord&nbsp;&nbsp;&nbsp;&nbsp;第一个程序我们先创建一个Maven工程。&nbsp;&nbsp;&nbsp;&nbsp;创建好Maven项目后，首先导入Spring Boot的依赖包，依赖可以在Spring Boot的官网：https://docs.spring.io/spring-boot/docs/1.5.22.RELEASE/reference/html/getting-started-installing-spring-boot.html#getting-started-maven-installation找到。 123456789101112131415161718192021222324&lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.22.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--这个插件可以把我们的应用打包成一个可以运行的jar包，后面有详细的说明--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 注意：&nbsp;&nbsp;&nbsp;&nbsp;1.spring-boot-starter-parent的父项目是spring-boot-dependencies（Spring Boot的版本仲裁中心），他的作用是用来管理Spring Boot应用里面的所有依赖版本&nbsp;&nbsp;&nbsp;&nbsp;2.spring-boot-starter-web：spring-boot-starter我们称作spring-boot场景启动器，Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来（要用什么功能就导入什么场景的启动器）。spring-boot-starter-web的作用是帮我们导入了web模块正常运行所依赖的组件； 完成上面的操作后，在src/main/java下新建一个主程序类Application.java类 1234567891011121314package com.xust.iot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 使用@SpringBootApplication 来标注主程序 */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 注意：&nbsp;&nbsp;&nbsp;&nbsp;1、主程序类必须位于项目基包的根目录（具体原因下面会说），而且要使用@SpringBootApplication来告诉Spring Boot这是一个主程序类（配置类），这么标注后Spring Boot就会从这个类的main方法启动并加载配置。&nbsp;&nbsp;&nbsp;&nbsp;2、@SpringBootApplication是基于Spring Boot基本注解的一个复合注解，源码片段如下： 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;...... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1、@SpringBootConfiguration：标注在某个类上，表示这是一个Spring Boot的配置类；底层实际还是使用的是Spring的底层注解@Configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2、@ComponnetScan：标注在类上，就是我们熟悉的包扫描&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3、@EnableAutoConfiguration：开启自动配置功能；以前我们需要配置的文件，在类上写上这个注解，Spring Boot帮我们自动配置。@EnableAutoConfiguration的源码片段如下： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1、@AutoConfigurationPackage：自动配置包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2、@Import(AutoConfigurationImportSelector.class)：借助AutoConfigurationImportSelector这个类@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们； 然后在src/main/java包下新建controller包，在这个包下新建HelloWordController.java 123456789101112131415package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWordController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello word,hello Spring Boot!\"; &#125;&#125; 这样一个简单的SpringBoot程序就写好了，在主程序类中点击运行按钮启动它。下面是运行后的结果： 运行结果说明：启动后我们访问http://localhost:8080，回车后就会出现Whitelable Error Page提示，这是Spring Boot默认的错误页面，由于我们没有指定初始页面，出错很正常，之后在地址栏中请求hello，就可以看到我们写的Hello word,hello Spring Boot! 部署应用&nbsp;&nbsp;&nbsp;&nbsp;部署应用需要spring-boot-maven-plugin这个插件（在上面有），在POM文件中导入后，我们在IDEA有侧边栏点击【Maven】=&gt;【项目名】=&gt;【Lifecycle】=&gt;【package】，双击package就会运行插件就可以我们的应用打包成一个可运行的jar包。打包后我们在target目录下可以找到他，然后复制在里一个目录中在命令行中cd到这个目录，执行java -jar jar包名这个命令可以执行打包后的应用。下面是执行后命令行的打印： 使用Spring Initializer快速创建Spring Boot项目在IDEA依次点击【New】=&gt;【Project】然后选择Spring Initializr 填写Group和Arifact,在填写Arifact时要注意不要出现大写字母 选择需要的模块 生成的Spring Boot项目 在默认生成的Spring Boot项目中 主程序类已经生成好了，我们只需要我们实现业务逻辑 resources文件夹中目录结构 static：保存所有的静态资源，如： js css images； templates：保存所有的模板页面，Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置。这个文件也支持YML(YML)格式的文件，用YAML(YML)格式配置的文件结构更加简洁，清晰。","tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://easyblog.top/tags/Spring-Boot/"}]},{"title":"SSM三大框架整合（Spring+Spring MVC +MyBatis）","date":"2019-08-22T07:29:02.000Z","path":"2019/08/22/SSM三大框架整合/","text":"&nbsp;&nbsp;&nbsp;&nbsp;Spring是一个非常流行的轻量级框架，他是为了解决企业应用开发的复杂性而创建的，现在已经被广泛应用在各个领域。MyBatis的前身iBatis也是一个非常流行的ORM框架，因此在在iBatis时期，Spring官方便提供了对iBatis的支持。但是在MyBatis时期，Spring 3.0在MyBatis 3.0官方发布前就已经结束了，因为Spring开发团队不想发布一个基于非发布版MyBatis的整合支持，因此MyBatis不得不继续等待Spring官方的支持。&nbsp;&nbsp;&nbsp;&nbsp;因此现在我们要整合他们要获得MyBatis的一个子项目MyBatis-Spring来支持，MyBatis-Spring可以帮我们将MyBatis代码无缝整合到Spring中。使用这个类库的类，Spring将会加载必要的MyBatis工厂类和Session类。这个类库也提供了一个简单的方式将MyBatis数据映射器和SqlSession注入到业务层的bean中，而且还可以处理事务、翻译MyBatis的异常到Spring的DataAccessException数据访问异常中。&nbsp;&nbsp;&nbsp;&nbsp;MyBatis-Spring项目的地址：https://github.com//mybatis/spring。&nbsp;&nbsp;&nbsp;&nbsp;接下来我们来一步步把他们整合在一起。 创建基本的Maven Web项目在IDEA中创建一个基本的Maven项目。具体过程不是这里的重点，如有有不清楚，请自行百度或Google~。创建好项目后，在pom.xml文件中配置依赖（导包） 在pom.xml文件中添加依赖详细的依赖配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Spring Start：也不全是Spring的依赖，还包括Spirng能够正常运行的一些支持性的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring上下文核心依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--上下文支持包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring面向切面编程--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime外部依赖包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--字节码增强--&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring JDBC--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring事物管理--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 对象关系映射--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring web模块核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring MVC模块--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Servlet原生API--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--支持JSP--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--JSTL用于在控制器中将模型绑定到JSP中--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;!--文件上传，依赖commons-io--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--增强版的java IO--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--json数据绑定--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--json注解--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt;&lt;!--json核心--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring End=--&gt;&lt;!--MyBatis Start--&gt;&lt;!--mybatis核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis与Spring整合的核心包：配置这个包的时候一定要注意你的MyBatis版本和Spring版本和这个包是否兼容--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jdbc数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--Druid数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis通用分页插件pageHelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页插件依赖的包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--======MyBatis End=======--&gt;&lt;!--日志记录--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; &nbsp;&nbsp;&nbsp;&nbsp;配置的时候要特别注意mybatis-spring这个包的版本和你使用的MyBatis以及Spring版本是否兼容，特别适当发生java.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()错误的时候，还就更要怀疑是这个问题了： 12345678910111213141516171819202122232425262728293021-Aug-2019 23:47:32.939 涓ラ噸 [http-nio-80-exec-5] org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [DispatcherServlet] in context with path [/ssm_merge_war_exploded] threw exception [Handler dispatch failed; nested exception is java.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()Ljava/lang/Integer;] with root causejava.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()Ljava/lang/Integer; at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:86) at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:49) at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117) at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:76) at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:197) at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:184) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:408) at com.sun.proxy.$Proxy17.insert(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.insert(SqlSessionTemplate.java:254) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:62) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) at com.sun.proxy.$Proxy18.addAccount(Unknown Source) at com.xust.iot.service.AccountService.addAccount(AccountService.java:20) at com.xust.iot.service.AccountService$$FastClassBySpringCGLIB$$b6e17b84.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.xust.iot.service.AccountService$$EnhancerBySpringCGLIB$$a5f30121.addAccount(&lt;generated&gt;) 适配的环境：mybatis-spring对JDK、mybatis、spring都有要求 配置环境&nbsp;&nbsp;&nbsp;&nbsp;配置文件的编写是SSM整合的关键，需要配置的东西主要有web.xml、Sprng配置文件applicationContext.xml、Spring MVC配置文件applicationContext-mvc.xml、MyBatis全局配置文件MyBatis-config.xml以及后面的Mapper映射文件的编写。 1.配置web.xml文件web.xml文件的基本配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--启动Spring容器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLoaction&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--用于在Web容器启动的时候根据contextConfigLoaction配置的路径读取Spring配置文件，然后启动Spring--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置字符编码过滤器,注意：字符编码过滤器应该配置在所有过滤器之前--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置Restful过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 2.配置MyBatis-config.xml全局配置文件&nbsp;&nbsp;&nbsp;&nbsp;在MyBatis的全局配置文件中配置一些基本对settings,环境就不要在这里配置了，交给Spring管理就好了（本身MyBatis这个配置文件都是可有可无的，但是用它来写一个settings配置可以使结构清晰，方便修改）。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--一些有关于mybatis运行时行为的设置--&gt; &lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!--开启懒加载--&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;!--aggressvieLazyLoading当这个参数为true的时候，对任意延迟属性都会完全的加载，当为false时会按需加载--&gt; &lt;setting name=\"aggressiveLazyLoading\" value=\"false\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\"/&gt; &lt;!--开启自动映射--&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;!--开启驼峰--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=\"com.xust.iot.bean\"/&gt; &lt;/typeAliases&gt; &lt;!--配置分页插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 3.配置applicationContext-mvc.xml文件123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=\"com.xust.iot\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt; &lt;/context:component-scan&gt; &lt;!--开启扫描静态--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--开启扫动态--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图解析器--&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"#&#123;1024*1024*5&#125;\"/&gt; &lt;property name=\"maxUploadSize\" value=\"#&#123;1024*1024*100&#125;\"/&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.配置applicationContext.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--注解扫描--&gt; &lt;context:component-scan base-package=\"com.xust.iot\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt; &lt;/context:component-scan&gt; &lt;!--引入外部配置文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;!--配置数据源--&gt; &lt;bean id=\"DruidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\"/&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\"/&gt; &lt;property name=\"maxWait\" value=\"$&#123;jdbc.maxWait&#125;\"/&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;\"/&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;jdbc.minEvictableIdleTimeMillis&#125;\"/&gt; &lt;property name=\"validationQuery\" value=\"$&#123;jdbc.validationQuery&#125;\"/&gt; &lt;property name=\"testWhileIdle\" value=\"$&#123;jdbc.testWhileIdle&#125;\"/&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;jdbc.testOnBorrow&#125;\"/&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;jdbc.testOnReturn&#125;\"/&gt; &lt;property name=\"poolPreparedStatements\" value=\"$&#123;jdbc.poolPreparedStatements&#125;\"/&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;\"/&gt; &lt;property name=\"filters\" value=\"$&#123;jdbc.filters&#125;\"/&gt; &lt;/bean&gt; &lt;!--配置MyBatis--&gt; &lt;bean id=\"SqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"/&gt; &lt;!--全局文件的位置--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/mybatis-config.xml\"/&gt; &lt;!--指定xml映射文件的位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- 扫描DAO持久层接口 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.xust.iot.mapper\"/&gt; &lt;/bean&gt; &lt;!--配置事物管理器：MyBatis使用的是原生的jdbc,所以使用DataSourceTransactionManager来管理事物--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--两种配置数据源的方式--&gt; &lt;!-- &lt;property name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"/&gt;--&gt; &lt;constructor-arg name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"/&gt; &lt;/bean&gt; &lt;!--配置事物策略--&gt; &lt;tx:advice id=\"tx\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\"/&gt; &lt;tx:method name=\"update*\" isolation=\"REPEATABLE_READ\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"myPointCut\" expression=\"execution(* com.xust.iot.service.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"tx\" pointcut-ref=\"myPointCut\"/&gt; &lt;/aop:config&gt; &lt;!--开启自动代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class=\"true\"/&gt;&lt;/beans&gt; jdbc.properties资源文件 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/tx?useSSL=falsejdbc.username=rootjdbc.password=95162437jdbc.initialSize=10jdbc.minIdle=10jdbc.maxActive=50jdbc.maxWait=60000jdbc.timeBetweenEvictionRunsMillis=60000jdbc.minEvictableIdleTimeMillis=300000jdbc.validationQuery=SELECT 'x' FROM DUALjdbc.testWhileIdle=truejdbc.testOnBorrow=falsejdbc.testOnReturn=falsejdbc.poolPreparedStatements=truejdbc.maxPoolPreparedStatementPerConnectionSize=20jdbc.filters=wall,stat 对于SSM的配置基本上完成了，下面将使用这个搭建好的框架对对book表进行简单的CRUD操作。 一个简单CRUD1.基本准备创建数据库和表：新建tx数据库，并在tx数据库中新建book表。具体的数据库脚本如下： 1234567891011121314151617181920212223242526272829303132/*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`tx` /*!40100 DEFAULT CHARACTER SET gb2312 */;USE `tx`;/*Table structure for table `book` */DROP TABLE IF EXISTS `book`;CREATE TABLE `book` ( `isbn` varchar(50) NOT NULL, `book_name` varchar(100) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=utf-8;/*Data for the table `book` */insert into `book`(`isbn`,`book_name`,`price`) values ('ISBN-001','book01',100),('ISBN-002','book02',200),('ISBN-003','book03',300),('ISBN-004','book04',400),('ISBN-005','book05',500);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 2.开发Mapper层（DAO层）在src/main/resources目录下新建mapper目录，在mapper目录下新建BookMapper.xml文件。并在源码包的mappr包下新建对应的BookMapper.java接口。 BookMapper.xml文件 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xust.iot.mapper.BookMapper\"&gt;&lt;/mapper&gt; Mapper接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xust.iot.mapper;import com.xust.iot.bean.Book;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface BookMapper &#123; /** * 根据图书的ISBN(主键)获得图书信息 * @param isbn * @return */ public Book getBookByISBN(@Param(\"isbn\") String isbn); /** * 得到所有的书 * @return */ public List&lt;Book&gt; getAllBook(); /** * 添加一本书 * @param book * @return */ public void addBook(Book book); /** * 根据isbn更新书 * @param book */ public void updateBookByISBN(Book book); /** * 根据isbn删除一本书 * @param isbn */ public void deleteBookByISBN(@Param(\"isbn\") String isbn);&#125; 这4个接口方法对应的XML代码如下。 1234567891011121314151617181920212223242526272829303132&lt;!--开启二级缓存，当然这里以后可以替换为第三方缓存，例如Enache、Redis...--&gt;&lt;cache&gt;&lt;/cache&gt;&lt;select id=\"getBookByISBN\" resultType=\"com.xust.iot.bean.Book\"&gt; select * from book &lt;where&gt; isbn=#&#123;isbn&#125; &lt;/where&gt;&lt;/select&gt; &lt;select id=\"getAllBook\" resultType=\"com.xust.iot.bean.Book\"&gt; select * from book&lt;/select&gt;&lt;insert id=\"addBook\" parameterType=\"com.xust.iot.bean.Book\"&gt; insert into book(isbn,book_name,price) values(#&#123;isbn&#125;,#&#123;bookName&#125;,#&#123;price&#125;)&lt;/insert&gt;&lt;update id=\"updateBookByISBN\" parameterType=\"com.xust.iot.bean.Book\"&gt; update book &lt;set&gt; book_name=#&#123;bookName&#125;, price=#&#123;price&#125; &lt;/set&gt; &lt;where&gt; isbn=#&#123;isbn&#125; &lt;/where&gt;&lt;/update&gt;&lt;delete id=\"deleteBookByISBN\" parameterType=\"string\"&gt; delete from book where isbn=#&#123;isbn&#125;&lt;/delete&gt; 3.开发业务层（Service层）虽然面向接口编程对于小项目来说并不重要，但是这里为了形式上的需要仍然需要提供Service接口。在src/main/java中新建com.xust.iot.sevice包，然后新建SeviceBase接口。 123456789101112131415package com.xust.iot.service;public interface ServiceBase&lt;T&gt; &#123; public T getById(Object param); public void deleteById(Object param); public void updateAndSave(T t); public void addAndSave(T t); public List&lt;T&gt; getAll();&#125; 在com.xust.iot.service包下新建impl包，然后新建BookService接口的实现类BookServiceImpl。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.xust.iot.service.impl;import com.xust.iot.bean.Book;import com.xust.iot.mapper.BookMapper;import com.xust.iot.service.ServiceBase;import org.springframework.beans.factory.annotation.Autowired;@Servicepublic class BookServiceimpl implements ServiceBase&lt;Book&gt; &#123; @Autowired private BookMapper bookMapper; @Override public Book getById(Object param) &#123; Book book=bookMapper.getBookByISBN(param.toString()); return book; &#125; @Override public void deleteById(Object param) &#123; bookMapper.deleteBookByISBN((String)param); &#125; @Override public void updateAndSave(Book book) &#123; bookMapper.updateBookByISBN(book); &#125; @Override public void addAndSave(Book book) &#123; bookMapper.addBook(book); &#125; @Override public List&lt;Book&gt; getAll() &#123; List&lt;Book&gt; lists=bookMapper.getAllBook(); return lists; &#125;&#125; 4.开发控制层（Controller层）在com.xust.iot.controller包下新建BookController类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.xust.iot.controller;import com.xust.iot.bean.Book;import com.xust.iot.service.impl.BookServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.List;@Controllerpublic class BookController &#123; @Autowired private BookServiceImpl bookService; private static boolean isNew = false; @RequestMapping(value = \"/save\", method = RequestMethod.POST) public String save(@ModelAttribute(\"book\") Book book, Model model) &#123; System.out.println(book); if (isNew) &#123; bookService.addAndSave(book); model.addAttribute(\"msg\", \"添加成功！\"); &#125; else &#123; bookService.updateAndSave(book); model.addAttribute(\"msg\", \"更新成功！\"); &#125; return \"forward:showAll\"; &#125; @RequestMapping(\"/toUpdatePage\") public String toUpdatePage(@ModelAttribute(\"book\") Book book, Model model) &#123; model.addAttribute(\"book\",book); return \"edit\"; &#125; @RequestMapping(\"/delete\") public String delete(@RequestParam(\"isbn\") String isbn, @RequestParam(\"pageNo\")Integer pageNo, Model model) &#123; bookService.deleteById(isbn); model.addAttribute(\"msg\", \"删除成功！\"); return \"forward:showAll\"; &#125; @RequestMapping(\"/showAll\") public String showAllBook(@RequestParam(\"pageNo\")Integer pageNo,Model model) &#123; //分页插件：从pageNo开始显示20条数据，这个语句一定要紧跟着查数据的那条语句，否者分页无效 PageHelper.startPage(pageNo,20); List&lt;Book&gt; lists = bookService.getAll(); //进一步封装数据，PageInfo的两个参数：（数据集合，连续显示的分页个数）,使用这个封装的数据可以拿到首页、末页、上/下一页....信息，非常强大的一个类 PageInfo info=new PageInfo(lists,10); model.addAttribute(\"info\", info); return \"bookInfo\"; &#125; @ModelAttribute public void check(@RequestParam(value = \"isbn\", defaultValue = \"\") String isbn, @RequestParam(value = \"bookName\", defaultValue = \"\") String bookName, @RequestParam(value = \"price\", defaultValue = \"\") Integer price, Model model) &#123; System.out.println(isbn); Book book = bookService.getById(isbn); //数据库中没有这本书，那就添加一本书 if (null == book) &#123; Book book1 = new Book(); book1.setBookName(bookName); book1.setIsbn(isbn); book1.setPrice(price); model.addAttribute(\"book\", book1); isNew = true; &#125; else &#123; //数据库中有这本书,那就直接拿出来更新信息 isNew = false; model.addAttribute(\"book\", book); &#125; &#125;&#125; 5.开发视图层（View层）index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;添加账户&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;a href=\"toAdd\"&gt;添加图书&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=\"showAll\"&gt;所有图书&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 添加图书的页面：add.jsp 12345678910111213141516171819&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"save\" method=\"post\"&gt; ISBN： &lt;input type=\"text\" name=\"isbn\"/&gt;&lt;br/&gt; 书名：&lt;input type=\"text\" name=\"bookName\"/&gt;&lt;br/&gt; 价格：&lt;select name=\"price\"&gt; &lt;c:forEach begin=\"10\" end=\"100\" var=\"price\" step=\"1\"&gt; &lt;option &gt;$&#123;price&#125;&lt;/option&gt;元 &lt;/c:forEach&gt; &lt;/select&gt; &lt;button type=\"submit\"&gt;保存&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 展示所有图书信息的页面：bookInfo.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;图书信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;button &gt;&lt;a href=\"toAdd\"&gt;添加图书&lt;/a&gt;&lt;/button&gt;&lt;table border=\"1px\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\" width=\"50%\"&gt; &lt;tr&gt; &lt;th&gt;图书ISBN编号&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;info.list&#125;\" var=\"book\" varStatus=\"i\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.isbn&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;&lt;button&gt;&lt;a href=\"delete?isbn=$&#123;book.isbn&#125;\"&gt;删除&lt;/a&gt;&lt;/button&gt;&lt;button&gt;&lt;a href=\"toUpdatePage?isbn=$&#123;book.isbn&#125;\"&gt;修改&lt;/a&gt;&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr style=\"align: center\"&gt; &lt;td colspan=\"4\" &gt; &lt;button&gt;&lt;a href=\"showAll?pageNo=1\"&gt;首页&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"showAll?pageNo=$&#123;info.getPrePage()&#125;\"&gt;上一页&lt;/a&gt;&lt;/button&gt; &lt;span&gt; &lt;c:forEach items=\"$&#123;info.navigatepageNums&#125;\" var=\"nav\"&gt; &lt;c:if test=\"$&#123;nav==info.pageNum&#125;\"&gt; &lt;span style=\"background-color: greenyellow;border-radius: 5px;width: 30px\"&gt;&amp;nbsp;&amp;nbsp;$&#123;nav&#125;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;nav!=info.pageNum&#125;\"&gt; &lt;a style=\"text-decoration: none\" color=\"black\" href=\"showAll?pageNo=$&#123;nav&#125;\"&gt;$&#123;nav&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/span&gt; &lt;button&gt;&lt;a href=\"showAll?pageNo=$&#123;info.getNextPage()&#125;\"&gt;下一页&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"showAll?pageNo=$&#123;info.getPages()&#125;\"&gt;末页&lt;/a&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;span&gt;$&#123;msg&#125;&lt;br/&gt;&lt;/span&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 修改图书信息的页面：edit.jsp 12345678910111213141516171819202122232425262728&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"save\" method=\"post\"&gt; ISBN： $&#123;book.isbn&#125;&lt;br/&gt;&lt;input type=\"hidden\" name=\"isbn\" value=\"$&#123;book.isbn&#125;\"/&gt; 书名：&lt;input type=\"text\" name=\"bookName\" value=\"$&#123;book.bookName&#125;\"/&gt;&lt;br/&gt; 价格：&lt;select name=\"price\"&gt;&lt;br/&gt; &lt;c:forEach begin=\"10\" end=\"100\" var=\"price\" step=\"1\"&gt; &lt;c:choose&gt; &lt;c:when test=\"$&#123;price==book.price&#125;\"&gt; &lt;option selected&gt;$&#123;price&#125;&lt;/option&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;price!=book.price&#125;\"&gt; &lt;option&gt;$&#123;price&#125;&lt;/option&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt;&lt;/select&gt; 元&lt;br/&gt;&lt;button type=\"submit\"&gt;保存&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 最终的测试结果： 总结：经过几个小时的斗争，SSM三大框架的简单整合算是完成了，期间也遇到了这样那样的问题，但都一一解决了，从测试结果来看还是比较成功的。然而代码没有写几行，配置文件写了一大堆，我只想说SpringBoot真香！！！","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"Spring声明式事物控制","date":"2019-08-20T04:15:45.000Z","path":"2019/08/20/Spring声明式事物控制/","text":"&nbsp;&nbsp;&nbsp;&nbsp;Spring支持编程式事务管理和声明式事务管理两种方式。 &nbsp;&nbsp;&nbsp;&nbsp;编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 &nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 &nbsp;&nbsp;&nbsp;&nbsp;显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。 &nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 搭建实验环境首先新建一个Maven项目，导入需要的依赖： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;dependency&gt; &lt;!--单元测试--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;!--数据库驱动的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring面向切面编程--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 事物--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 映射--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 创建数据库和表：新建tx数据库，并在tx数据库中新建三张表account、book、book_stock。具体的数据库脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`tx` /*!40100 DEFAULT CHARACTER SET gb2312 */;USE `tx`;/*Table structure for table `account` */DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `username` varchar(50) NOT NULL, `balance` int(11) DEFAULT NULL, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `account` */insert into `account`(`username`,`balance`) values ('Jerry',800),('Tom',100000);/*Table structure for table `book` */DROP TABLE IF EXISTS `book`;CREATE TABLE `book` ( `isbn` varchar(50) NOT NULL, `book_name` varchar(100) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `book` */insert into `book`(`isbn`,`book_name`,`price`) values ('ISBN-001','book01',100),('ISBN-002','book02',200),('ISBN-003','book03',300),('ISBN-004','book04',400),('ISBN-005','book05',500);/*Table structure for table `book_stock` */DROP TABLE IF EXISTS `book_stock`;CREATE TABLE `book_stock` ( `isbn` varchar(50) NOT NULL, `stock` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `book_stock` */insert into `book_stock`(`isbn`,`stock`) values ('ISBN-001',1000),('ISBN-002',2000),('ISBN-003',3000),('ISBN-004',4000),('ISBN-005',5000);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 导入后应该是这样的三张表： 基于Annotation的事物管理首先配置数据源，这里使用的阿里的Druid数据连接池 12345678910111213141516171819202122232425262728293031&lt;!--引入外部文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置数据连接池--&gt;&lt;bean id=\"DruidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\"/&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;jdbc.maxWait&#125;\"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;jdbc.minEvictableIdleTimeMillis&#125;\" /&gt; &lt;property name=\"validationQuery\" value=\"$&#123;jdbc.validationQuery&#125;\" /&gt; &lt;property name=\"testWhileIdle\" value=\"$&#123;jdbc.testWhileIdle&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;jdbc.testOnBorrow&#125;\" /&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;jdbc.testOnReturn&#125;\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。--&gt; &lt;property name=\"poolPreparedStatements\" value=\"$&#123;jdbc.poolPreparedStatements&#125;\" /&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;\" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=\"filters\" value=\"$&#123;jdbc.filters&#125;\" /&gt;&lt;/bean&gt; 数据库配置jdbc.properties如下： 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/tx?useSSL=falsejdbc.username=rootjdbc.password=95162437jdbc.initialSize=10jdbc.minIdle=10jdbc.maxActive=50jdbc.maxWait=60000jdbc.timeBetweenEvictionRunsMillis=60000jdbc.minEvictableIdleTimeMillis=300000jdbc.validationQuery=SELECT 'x' FROM DUALjdbc.testWhileIdle=truejdbc.testOnBorrow=falsejdbc.testOnReturn=falsejdbc.poolPreparedStatements=truejdbc.maxPoolPreparedStatementPerConnectionSize=20jdbc.filters=wall,stat 配置JdbcTemplate，这里出于学习的目的先使用JdbcTemplate。 1234&lt;!--配置JdbcTemplate--&gt;&lt;bean id=\"JdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;constructor-arg name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 配置事物管理器 1234&lt;!--DataSourceTransactionManager适用于使用JDBC来操作数据库的场景--&gt;&lt;bean id=\"TransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 配置开启注解事物管理 12&lt;!--开启注解事物管理--&gt;&lt;tx:annotation-driven transaction-manager=\"TransactionManager\"/&gt; 完整的ApplicationContext.xml配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt;&lt;context:component-scan base-package=\"com.xust.iot\"/&gt;&lt;!--引入外部文件--&gt;&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;!--配置数据连接池--&gt;&lt;bean id=\"DruidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"$&#123;jdbc.initialSize&#125;\"/&gt; &lt;property name=\"minIdle\" value=\"$&#123;jdbc.minIdle&#125;\"/&gt; &lt;property name=\"maxActive\" value=\"$&#123;jdbc.maxActive&#125;\"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"$&#123;jdbc.maxWait&#125;\"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;\" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"$&#123;jdbc.minEvictableIdleTimeMillis&#125;\" /&gt; &lt;property name=\"validationQuery\" value=\"$&#123;jdbc.validationQuery&#125;\" /&gt; &lt;property name=\"testWhileIdle\" value=\"$&#123;jdbc.testWhileIdle&#125;\" /&gt; &lt;property name=\"testOnBorrow\" value=\"$&#123;jdbc.testOnBorrow&#125;\" /&gt; &lt;property name=\"testOnReturn\" value=\"$&#123;jdbc.testOnReturn&#125;\" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。--&gt; &lt;property name=\"poolPreparedStatements\" value=\"$&#123;jdbc.poolPreparedStatements&#125;\" /&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;\" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name=\"filters\" value=\"$&#123;jdbc.filters&#125;\" /&gt;&lt;/bean&gt;&lt;!--配置JdbcTemplate--&gt;&lt;bean id=\"JdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;constructor-arg name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--Spring事务控制--&gt;&lt;!--1.配置事务管理器,本身事物管理器是需要我们写一个切面类通过AOP编程的方式来实现，但是Spring提供了我们就直接使用Spring提供的事物管理器--&gt;&lt;bean id=\"TransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"/&gt;&lt;/bean&gt;&lt;!--2.开启基于注解的事物管理--&gt;&lt;!--属性transaction-manager就是事物管理器--&gt;&lt;tx:annotation-driven transaction-manager=\"TransactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;!--3.在需要事物的地方用@Transactional来告诉Spring这个地方需要进行事物管理--&gt;&lt;/beans&gt; &nbsp;&nbsp;&nbsp;&nbsp;完成上面的操作后，我们就可以在需要事物管理的地方使用@Transactional注解标注在类或方法上，以此告诉Spring这里需要事物管理。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。@Transactional注解的属性 属性 需要的参数的类型 描述 value String 指定使用的事务管理器(必须) propagation enum:Propagation 事务传播行为设置(可选) isolation enum: Isolation 事务隔离级别设置(可选) readOnly boolean 读写或只读事务，默认（false）读写 timeout int 事务超时时间设置,单位：秒 rollbackFor Class[]，必须继承自Throwable 指定发生异常后哪些异常要回滚 rollbackForClassName String[]，必须继承自Throwable 指定发生异常后哪些异常要回滚的异常类名字数组 noRollbackFor Class[]，必须继承自Throwable 指定发生异常后哪些异常不回滚 noRollbackForClassName String[]，必须继承自Throwable指定发生异常后哪些异常不回滚的异常类名字数组 DAO层，直接使用JdbcTemplate操作数据库，写3个方法分别用于：更新用户余额、更新图书库存、以及查询价格，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class BookDaoimp &#123; @Autowired JdbcTemplate jdbcTemplate; /** * 减库存 */ public void updateBookStock(Integer books,String isbn)&#123; String sql=\"update book_stock set stock=stock-? where isbn=?\"; jdbcTemplate.update(sql,books,isbn); &#125; /** * 减用户对余额 */ public void updateUserBalance(Integer payment,String username)&#123; String sql=\"updatess account set balance=balance-? where username=?\"; jdbcTemplate.update(sql,payment,username); &#125; /** * 查询图书的价格 * @param isbn * @return */ public Integer getBookPrice(String isbn)&#123; String sql=\"select price from book where isbn=?\"; return jdbcTemplate.queryForObject(sql,Integer.class,isbn); &#125;&#125; 业务层，写一个结账的方法，使用@Transactional告诉Spring要帮我们控制事务 123456789101112131415161718192021222324252627282930313233package com.xust.iot.service;import com.xust.iot.dao.BookDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class BookService &#123; @Autowired BookDao bookDao; /** * 模拟结账 * @param username 用户姓名 * @param isbn 图书编号 * @param books 用户买了几本书 */ @Transactional public void cheockout(String username,String isbn,Integer books)&#123; //减库存 bookDao.updateBookStock(books,isbn); Integer price=bookDao.getBookPrice(isbn); Integer payment=price*books; //减账户余额 bookDao.updateUserBalance(payment,username); &#125;&#125; 基于XML的事物管理其他的步骤和使用注解一样，不同的核心操作在下面： 123456789101112131415161718&lt;!--基于XML的事物管理--&gt;&lt;!--1.配置事务管理器：这个和使用注解时一样--&gt;&lt;bean id=\"TransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" value=\"#&#123;DruidDataSource&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--2.配置事物属性：使用&lt;tx:advice&gt;标签声明事物通知 --&gt;&lt;tx:advice id=\"myTransaction\" transaction-manager=\"TransactionManager\"&gt; &lt;!--事物属性--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"get*\" propagation=\"REQUIRED\" read-only=\"true\"/&gt; &lt;tx:method name=\"cheockout\" propagation=\"REQUIRED\" isolation=\"REPEATABLE_READ\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--3.配置事物切入点，把事物切入点和事物属性关联起来--&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointCut\" expression=\"execution(* com.xust.iot.service.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"myTransaction\" pointcut-ref=\"pointCut\"/&gt;&lt;/aop:config&gt; 测试在src/main/test包下新建测试类TxTest.java测试 12345678910111213141516171819202122232425262728package test;import com.alibaba.druid.pool.DruidDataSource;import com.xust.iot.service.BookService;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import java.sql.Connection;import java.sql.SQLException;import java.util.Date;public class TxTest &#123; ApplicationContext ioc=new ClassPathXmlApplicationContext(\"ApplicationContext.xml\"); private JdbcTemplate jdbcTemplate=ioc.getBean(JdbcTemplate.class); @Test public void txTest()&#123; BookService bookService=ioc.getBean(BookService.class); bookService.cheockout(\"Tom\",\"ISBN-005\",3); System.out.println(\"结账成功！\"); &#125;&#125;","tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://easyblog.top/tags/Spring-AOP/"}]},{"title":"Spring和SpringMVC整合","date":"2019-08-16T16:40:01.000Z","path":"2019/08/17/Spring和SpringMVC整合/","text":"看到这个标题有些同学有点奇怪，SpringMVC是基于Spring的框架，没有必要整合，关于Spring的IOC和bean在springmvc的配置文件里配置就可以了。如果真的这样，那我们的配置文件就面临着难以维护的致命缺点。 正常来说，我们应该将Spring的容器和SpringMVCc的配置文件分开来，在Spring的容器配置IOC和AOP的相关组件，让他只负责各个bean之间的依赖和横切逻辑，而在SpringMVC的配置文件中只负责handler的配置就完全可以了。 因此所谓的整合，实质上是让Spring和SpringMVC明确分工，各司其职。分工的目的总结来说就是： Spring配置文件：配置和业务有关的（事务控制、数据源.....） SpringMVC配置文件：配置和网站转发逻辑和网站功能有关的（视图解析、文件上传、支持ajax.....） 好了，废话不多说，下面直接来看看如何把他两有机的整合在一起。 导包首先，导入jar包这里使用Maven来管理项目，所需的Maven依赖写法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;properties&gt; &lt;spring.version&gt;5.1.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Spring start--&gt;&lt;!--Core：spring-core、spring-beans、spring-content、spring-expression--&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--AOP：spring-aop、spring-aspectj、spring-instrument、spring-instrument-tomcat--&gt;&lt;!--spring aop：外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Data Access--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-mvc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring End--&gt;&lt;!--Servlet API--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 写配置web.xml的配置web.xml应该是整个项目最重要的配置文件了，不过servlet3.0中已经支持注解配置方式了。在servlet3.0以前每个servlet必须要在web.xml中配置servlet及其映射关系。但是在spring框架中就不用了，因为Spring中是依赖注入（Dependency Injection）的也叫控制反转（Inversion of Control）。但是也要配置一个重要的servlet，就是前端控制器（DispatcherServlet）。配置方式与普通的servlet基本相似。 配置内容如下： 123456789101112131415&lt;!--配置前段控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--web容器启动的时候就加载SpringMVC--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc-config.xml是SpringMVC的配置文件，稍后讨论他的配置。在web.xml中配置Spring容器： 12345&lt;!--加载Spring容器--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 配置监听器： 1234&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注意：如果你的项目里面不使用 WebApplicationContext 就可以不配置listener节点。但是正常情况下，都会配置ContentLoaderListener，具体参考这位老哥的博客：https://blog.csdn.net/qq_15037231/article/details/78743765。 配置字符编码过滤器： 1234567891011121314151617&lt;!--配置字符编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 完整的web.xml配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;!--配置前段控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--web容器启动的时候就加载SpringMVC--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--加载Spring容器--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--配置字符编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-config.xml的配置配置自动扫描：只扫描Controller和ControllerAdvice 12345&lt;!--配置SpringMVC扫描的范围--&gt;&lt;context:component-scan base-package=\"com.xust.iot\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;&lt;/context:component-scan&gt; 注意：当使用&lt; context:component-scan /&gt;后，就可以将 &lt; context:annotation-config/&gt;移除。 配置视图解析器： 12345&lt;!--配置视图解析器--&gt;&lt;bean name=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; 配置全局异常处理器：自己先写一个异常处理的类，然后用@ControllerAdvice标注，有啥异常后面开发的时候再写 12&lt;!--配置全局的异常处理器--&gt;&lt;bean id=\"exceptionHandler\" class=\"com.xust.iot.exception.EntireExceptionHandler\"/&gt; 如果项目中有上传文件的需求，那么还需要配置文件上传解析器，一般使用commons-fileupload来上传文件，需要导入的Maven依赖写法如下： 1234567891011121314&lt;!--文件上传--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;!--comons-fileupload依赖commons-io,commons-io可以把它看成java IO的加强版--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 文件上传的配置如下： 12345&lt;!--文件上传解析器--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"#&#123;1024*1024*20&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"#&#123;1024*1024*5&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt; 注意：在使用CommonsMultipartResolver时一定要导入commons-fileupload的jar包，否者服务器一启动就会报错。 在上面web.xml中配置的前端控制器拦截了所有的请求，不做特殊处理就会导致部分静态资源无法使用。如果是这种情况就可以使用下面的配置来访问静态资源文件： 12&lt;!--配置默认对静态文件的处理--&gt;&lt;mvc:default-servlet-handler/&gt; 当然，也可以使用下面的配置方式来处理静态资源： 1234&lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt;&lt;mvc:resources mapping=\"/css/**\" location=\"/css/\" /&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/js/\" /&gt;&lt;mvc:resources mapping=\"/imgdata/**\" location=\"/imgdata/\" /&gt; 对于静态资源处理如果问题，可以参照这位老哥的博客：https://www.cnblogs.com/dflmg/p/6393416.html。 完整的springmvc-config.xml文件的配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!--配置SpringMVC扫描的范围--&gt;&lt;context:component-scan base-package=\"com.xust.iot\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;&lt;/context:component-scan&gt;&lt;!--配置默认对静态文件的处理--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- mvc的注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!--配置视图解析器--&gt;&lt;bean name=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&amp;lt;!&amp;ndash;文件上传解析器&amp;ndash;&amp;gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"#&#123;1024*1024*20&#125;\"&gt;&lt;/property&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"#&#123;1024*1024*5&#125;\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置全局的异常处理器--&gt;&lt;bean id=\"exceptionHandler\" class=\"com.xust.iot.exception.EntireExceptionHandler\"/&gt;&lt;/beans&gt; applicationContext.xml的配置配置自动扫描：Spring要扫描的是SpringMVC不扫描的，就是他两扫描的范围互补，因此这里只需要排除SpringMVC扫秒的范围即可。配置如下： 123456&lt;!--配置Spring自动扫描的范围--&gt;&lt;context:component-scan base-package=\"com.xust.iot\"&gt; &lt;!--排除掉SpringMVC扫秒的外，Spring都取扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;&lt;/context:component-scan&gt; 完整的applicationContext.xml包的配置如下： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;!--配置Spring自动扫描的范围--&gt;&lt;context:component-scan base-package=\"com.xust.iot\"&gt; &lt;!--排除掉SpringMVC扫秒的外，Spring都取扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.web.bind.annotation.ControllerAdvice\"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 测试最后写代码来测试一下Service层 12345678910111213141516package com.xust.iot.sevice;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public UserService() &#123; System.out.println(\"初始化UserService......\"); &#125; public String hello()&#123; return \"Hello,Spring和SpringMVC整合成功！\"; &#125;&#125; Controller层 123456789101112131415161718192021222324252627package com.xust.iot.controller;import com.xust.iot.sevice.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public UserController() &#123; System.out.println(\"初始化UerController.....\"); &#125; @RequestMapping(\"/hello\") public String hello(Model model)&#123; model.addAttribute(\"msg\",userService.hello()); return \"success\"; &#125;&#125; 测试结果： 与此同时，控制台的打印的信息如下： 可以看到，两个类都被注册进了各自应该去的容器中。而且都只初始化了一遍。达到了最初的目的。 Spring与SpringMVC父子容器的关系&nbsp;&nbsp;&nbsp;&nbsp;最后，简单的说一下Spring与SpringMVC父子容器的关系&nbsp;&nbsp;&nbsp;&nbsp;Spring源码中默认规定，当Spring和SpringMVC两个容器共存的时候：1. Spring和SpringMVC的容器具有父子关系，Spring容器为父容器，SpringMVC为子容器，子容器可以引用父容器中的Bean，而父容器不可以引用子容器中的Bean;2. Spring容器导入的properties配置文件，只能在Spring容器中用而在SpringMVC容器中不能读取到。 需要在SpringMVC 的配置文件中重新进行导入properties文件，并且同样在父容器Spring中不能被使用，导入后使用@Value(“${key}”)在java类中进行读取。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC异常处理","date":"2019-08-15T15:35:59.000Z","path":"2019/08/15/SpringMVC异常处理/","text":"重要的接口和类HandlerExceptionResolver&nbsp; &nbsp; &nbsp; &nbsp;他是SpringMVC“九大组件”之一,SpringMVC异常处理核心接口。该接口定义了1个解析异常的方法： ExceptionHandlerExceptionResolver &nbsp; &nbsp; &nbsp; &nbsp;继承自AbstractHandlerMethodExceptionResolver，该类主要处理Controller中用@ExceptionHandler注解定义的方法。该类是&lt;annotation-driven/&gt;配置中定义的HandlerExceptionResolver实现类之一，大多数异常处理都是由该类操作。 在Controller中使用@ExceptionHandler 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;@Controllerpublic class ExceptionHandlerTest &#123;@RequestMapping(\"/handler1\")public String handler1(Model model,@RequestParam(value = \"value\",required = false) int value)&#123; int i=10/value; model.addAttribute(\"msg\",\"你好呀！\"); model.addAttribute(\"msg1\",\"10/\"+value+\"=\"); model.addAttribute(\"res\",i); return \"success\";&#125;/** * 使用@ExceptionHandler注解可以告诉SpringMVC这是一个专门处理异常的方法 * 一个方法可处理多个异常，可以有多个处理异常的类 * @param e * @return */@ExceptionHandler(ArithmeticException.class)public ModelAndView exceptionHandler1(Exception e, HttpServletResponse response)&#123; System.out.println(\"在\"+this.getClass().getName()+\"中的异常处理方法\"); ModelAndView mv=new ModelAndView(\"error\"); mv.addObject(\"e\",e); mv.addObject(\"statusCode\",response.getStatus()); return mv;&#125;&#125; 异常后的页面： 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;出错啦&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;出错啦！响应代码：$&#123;status&#125;，错误信息:$&#123;e&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp; &nbsp; &nbsp; &nbsp;像这样在Controller中借助@ExceptionHandler这个注解定义的异常处理方法只能在定义的那个Controller中使用，当Controller类十分多的时候，那么写异常处理方法就是个体力活了，因此SpringMVC就提供了@ControllerAdvice这个注解,它只能用在类上，而这个类中的异常处理方法都是全局范围，如下定义一个类专门集中处理异常： 1234567891011121314151617181920212223242526272829303132333435package com.xust.iot.handleException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;@ControllerAdvicepublic class MyExceptionHandler &#123;@ExceptionHandler(ArithmeticException.class)public ModelAndView handleArithmeticException(Exception e,HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView(\"error\"); mv.addObject(\"status\", response.getStatus()); mv.addObject(\"e\",e); return mv;&#125;@ExceptionHandler(NullPointerException.class)public ModelAndView handlerNulPointlException(Exception e,HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView(\"error\"); mv.addObject(\"status\", response.getStatus()); mv.addObject(\"e\",e); return mv;&#125;@ExceptionHandler(Exception.class)public ModelAndView handlerException(Exception e, HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView(\"error\"); mv.addObject(\"status\", response.getStatus()); mv.addObject(\"e\",e); return mv;&#125;&#125; 一个好的异常处理机制应该是这样的，有一个集中的处理点负责所有的异常处理，在真正的业务逻辑的处理过程中，我只会关心正常的业务流程，一旦遇到异常，我只管抛出对应的异常和相关的信息就行了。 DefaultHandlerExceptionResovler&nbsp; &nbsp; &nbsp; &nbsp;HandlerExceptionResolver接口的默认实现之一 ，基本上是Spring MVC内部使用，用来处理Spring定义的各种标准异常，将其转化为相对应的HTTP Status Code。其处理的异常类型有： 123456789101112handleNoSuchRequestHandlingMethodhandleHttpRequestMethodNotSupportedhandleHttpMediaTypeNotSupportedhandleMissingServletRequestParameterhandleServletRequestBindingExceptionhandleTypeMismatchhandleHttpMessageNotReadablehandleHttpMessageNotWritablehandleMethodArgumentNotValidExceptionhandleMissingServletRequestParameterhandleMissingServletRequestPartExceptionhandleBindException ResponseStatusExceptionResovler&nbsp; &nbsp; &nbsp; &nbsp;用来支持@ResponseStatus的使用，处理使用了ResponseStatus注解的异常，根据注解的内容，返回相应的HTTP Status Code和异常页面给客户端。如果Web应用程序中配置了ResponseStatusExceptionResolver，那么我们就可以使用ResponseStatus注解来注解我们自己编写的异常类，并在Controller中抛出该异常类，之后ResponseStatusExceptionResolver就会自动帮我们处理剩下的工作。&lt;annotation-driven/&gt;配置中定义的HandlerExceptionResolver实现类之一。 自定义一个异常 123456789package com.xust.iot.handleException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason = \"用户不存在\",value = HttpStatus.NOT_FOUND)public class UserNotFoundException extends RuntimeException &#123; //......&#125; 另一个自定义异常 12345678package com.xust.iot.handleException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason = \"输入的登录参数不合法\",value = HttpStatus.BAD_REQUEST)public class ParamterIllegalException extends RuntimeException &#123;&#125; 在Controller中主动抛出这个异常看看效果： 12345678910111213141516171819202122232425262728293031323334353637383940package com.xust.iot.controller;import com.xust.iot.beans.User;import com.xust.iot.handleException.ParamterIllegalException;import com.xust.iot.handleException.UserNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;@Controllerpublic class UserController &#123;@RequestMapping(\"/toLogin\")public String checkLogIn(@RequestParam(value =\"username\",defaultValue = \"\")String username,Model model) throws Throwable &#123; if(\"\".equals(username))&#123; System.out.println(\"用户登录失败\"); throw new ParamaterIllegalException(); &#125;else if(!\"admin\".equals(username))&#123; System.out.println(\"用户登录失败\"); throw new UserNotFoundException(); &#125; model.addAttribute(\"msg\",\"欢迎你\"+username+\",现在是北京时间：\"+new SimpleDateFormat(\"hh:mm:ss\").format(new Date())); System.out.println(\"用户登录成功\"); return \"success\";&#125;&#125; 测试结果： ExceptionHandlerExceptionResolver、DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver这三个类是&lt;mvc:annotation-driver&gt;配置后默认的3个实现类，他们的优先级是按书写的顺序由高到底。 SimpleMappingExceptionResovler提供了将异常映射为视图的能力，高度可定制化。其提供的能力有： 根据异常的类型，将异常映射到视图； 可以为不符合处理条件没有被处理的异常，指定一个默认的错误返回； 处理异常时，记录log信息； 指定需要添加到Modle中的Exception属性，从而在视图中展示该属性。在Springmvc配置文件中配置SimpleMappingExceptionResovler12345678910111213&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt;&lt;property name=\"exceptionMappings\"&gt; &lt;!--在props标签中配置所有异常后对应的页面,其中: key表示异常，应该写异常的全类名 &lt;prop&gt;标签体写该异常映射的视图名，只写视图名即可，SpringMVC的视图处理器会自动拼串 --&gt; &lt;props&gt; &lt;prop key=\"java.lang.NullPointerException\" &gt;error&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--指定取出错误信息的key--&gt;&lt;property name=\"exceptionAttribute\" value=\"ex\"/&gt; 这样，我们把SimpleMappingExceptionResolver配置好了，这个类在配置的时候还有很多的属性可以配置，如下:","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"Spring MVC 资源国际化","date":"2019-08-15T06:13:39.000Z","path":"2019/08/15/SpringMVC资源国际化/","text":"国际化开发概述软件的国际化：软件开发时，要使它能同时应对世界不同地区和国家的访问，并针对不同地区和国家的访问，提供相应的、符合来访者阅读习惯的页面或数据。国际化(internationalization)又称为 i18n(读法为i 18 n，据说是因为internationalization(国际化)这个单词从i到n之间有18个英文字母，i18n的名字由此而来) 国际化的基本规则国际化信息”也称为“本地化信息”，一般需要两个条件才可以确定一个特定类型的本地化信息，它们分别是“语言类型”和“国家/地区的类型”。如中文本地化信息既有中国大陆地区的中文，又有中国台湾、中国香港地区的中文，还有新加坡地区的中文。Java通过java.util.Locale类表示一个本地化对象，它允许通过语言参数和国家/地区参数创建一个确定的本地化对象。 语言参数使用ISO标准语言代码表示，这些代码是由ISO-639标准定义的，每一种语言由两个小写字母表示。在许多网站上都可以找到这些代码的完整列表，下面的网址是提供了标准语言代码的信息：http://www.loc.gov/standards/iso639-2/php/English_list.php。 国家/地区参数也由标准的ISO国家/地区代码表示，这些代码是由ISO-3166标准定义的，每个国家/地区由两个大写字母表示。用户可以从以下网址查看ISO-3166的标准代码：http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html。下面是常用的国家/地区语言参数： 实现一个简单的国际化编写国际化资源文件国际化资源文件就是用一种key-value的形式把要显示的信息的不同语言的翻译版本写到properties资源文件中：针对美式英文的资源文件： 1234567login_en_US.properties:welcomeInfo=Welcome to my personal blog LoveITerusername=USERNAMEpassword=PASSWORDloginbtn=LOGINplaceholder_username=please input usernameplaceholder_password=please input password 针对简体中文的资源文件： 1234567login_zh_CN.propertieswelcomeInfo=欢迎访问我的个人博客LoveITerusername=用户名password=密码loginbtn=登录placeholder_username=请输入用户名placeholder_password=请输入密码 注意：一般情况下我们用._zh_CN.properties表示中文资源文件，.properties表示默认的资源文件。 在springmvc配置文件中简单的配置一下，把我们的资源文件交给SpringMVC管理 1234 &lt;!--配置国际化资源文件--&gt;&lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basename\" value=\"login\"/&gt;&lt;/bean&gt; 编写一个用户登录表单 12345678910111213141516171819&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;fmt:message key=\"welcomeInfo\"/&gt;&lt;/h3&gt;&lt;form action=\"checkLogin\" method=\"post\" &gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key=\"username\"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=\"text\" placeholder=\"&lt;fmt:message key='placeholder_username'/&gt;\"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key=\"password\"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=\"password\" placeholder=\"&lt;fmt:message key='placeholder_password'/&gt;\"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;input type=\"submit\" value=\"&lt;fmt:message key=\"loginbtn\"/&gt;\"/&gt;&lt;/th&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中用到了JSTL中的fmt标签&lt;fmt:message&gt;,因此需要导入对应的jar包。 测试结果：我的浏览器默认就是中文，因此显示的就是中文的欢迎信息： 在火狐浏览器中手动更改语言为英文 英文环境下就显示的是英文信息： 资源文件的编码问题一般我们采用properties文件来保存资源文件。properties文件是以key-value的形式来保存文件的。login_zh_CN.properties中保存的是经过utf-8编码字后的ASCII字符，Unicode字符中不允许出现中文、日文等其他字符的文字。但是Unicode编码后的文字阅读起来比较困难，在IDEA中，可以在File-&gt;Settings-&gt;Editor-&gt;File Encodings设置中勾选Transparent native-to-ascii conversion,如下图，设置好后点击Apply,然后回到刚才编写的中文资源文件发现中文字符全部乱码了，这时可以在编辑器中直接重新输入中文。虽然我们输入的是中文，但是IDEA已经帮我们做了中文转码。 在程序中获取国际化信息在程序中我们可以通过ResourceBundleMessageSource来获取资源文件的信息： 1234567891011121314151617181920212223242526272829303132package com.xust.iot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Locale;@Controllerpublic class UserController &#123;@Autowiredprivate MessageSource messageSource;/** * SpringMVC会自动把locale信息注入 * @param locale * @return */@RequestMapping(\"/toLogin\")public String logIn(Locale locale) &#123; System.out.println(locale); String welcomeInfo=messageSource.getMessage(\"welcomeInfo\",null,locale); String userName=messageSource.getMessage(\"username\",null,locale); String password=messageSource.getMessage(\"password\",null,locale); System.out.println(welcomeInfo+\"----\"+userName+\"----\"+password); return \"login\";&#125;&#125; 执行结果：可以看到在不同对语言环境下使用了不同的资源文件。 自定义区域信息解析器3个步骤：1、写一个类实现LocaleResolver接口或他的子接口或继承他的实现类，最主要是要实现它的resolveLocale方法2、在springmvc的配置文件中把我们写的区域信息解析器注册给SpringMVC3、启动测试写一个类实现LocalResolver接口 1234567891011121314151617181920212223242526272829303132333435package com.xust.iot.LocaleResolver;import net.sf.cglib.core.Local;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123;/** * 解析locale信息 * @param request * @return */@Overridepublic Locale resolveLocale(HttpServletRequest request) &#123; Locale locale=null; //通过请求解析请求参数中的locale来让用户可以根据自己的习惯选择语言 String localeStr=null!=request.getParameter(\"locale\")?request.getParameter(\"locale\"):\"\"; if(!\"\".equals(localeStr))&#123; locale=new Locale(localeStr.split(\"_\")[0],localeStr.split(\"_\")[1]); &#125;else&#123; locale=request.getLocale(); &#125; return locale;&#125;@Overridepublic void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;&#125;&#125; 配置自定义的解析器 12&lt;!--自定义区域信息解析器--&gt;&lt;bean id=\"localeResolver\" class=\"com.xust.iot.LocaleResolver.MyLocaleResolver\"/&gt; 注意：解析器的id必须是localeResolver，如果写错了就没有效果了。至于为啥非要这么写请参考SpringMVC源码中的DispatcherServlet这个类。 在页面中加入可以切换语言的链接： 1234567891011121314151617181920&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;fmt:message key=\"welcomeInfo\"/&gt;&lt;/h3&gt;&lt;form action=\"checkLogin\" method=\"post\" &gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key=\"username\"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=\"text\" placeholder=\"&lt;fmt:message key='placeholder_username'/&gt;\"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key=\"password\"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type=\"password\" placeholder=\"&lt;fmt:message key='placeholder_password'/&gt;\"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;input type=\"submit\" value=\"&lt;fmt:message key=\"loginbtn\"/&gt;\"/&gt;&lt;/th&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;a href=\"toLogin?locale=zh_CN\"&gt;&lt;fmt:message key=\"Chinese\"/&gt;&lt;/a&gt;|&lt;a href=\"toLogin?locale=en_US\"&gt;&lt;fmt:message key=\"English\"/&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： SessionLocaleResolver 从SpringMVC的区域信息的继承图中我么看到了几个特别的区域信息解析器： 1、AcceptHeaderLocaleResolver：它是SpringMVC默认装配的区域信息解析器，他会默认从 accept-language请求头信息进行解析处理，通常这个头信息包含客户端操作信息的本地标示。它不支持通过链接的方式改变locale信息。 2、FixedLocaleResolver：从字面意思就可以知道，这也是一个不支持通过链接的方式改变locale信息的一个解析器，它默认会从操作系统拿locale信息。 3、SessionocaleResolver：从session中拿locale信息，允许设置区域信息。 4、CookieLocaleResolver：从Cookie中拿locale信息，允许设置区域信息。 下面我们借助SessionLocaleResolver来实现我们上面自定义区域信息解析器的功能： 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.util.Locale;@Controllerpublic class UserController &#123;@Autowiredprivate MessageSource messageSource;@RequestMapping(\"/toLogin\")public String logIn( @RequestParam(value = \"locale\",defaultValue = \"zh_CN\") String localeStr, Model model, Locale locale, HttpSession session) &#123; Locale l=null; if(null!=localeStr&amp;&amp;!\"\".equals(localeStr))&#123; l=new Locale(localeStr.split(\"_\")[0],localeStr.split(\"_\")[1]); &#125;else&#123; l=locale; &#125; session.setAttribute(SessionLocaleResolver.class.getName() + \".LOCALE\",l); return \"login\";&#125;&#125; 测试结果： 使用LocaleChangeInterceptor通过配置LocaleChangeInterceptor，我们可以动态改变本地语言。从他的名字就可以知道他是一个可改变Locale信息的拦截器，熟悉Spring MVC拦截器的同学都知道，如果配置了拦截器，Spring MVC会在处理请求之前调用拦截器的preHandle方法，而LocaleChangeInterceptor就是在真正开启处理请求之前先调用LoacleResolver的方法setLocal()设置了本地化信息。 既然是拦截器，要使用他就需要在springmvc配置文件中配置它，配置也很简单： 123&lt;mvc:interceptors&gt; &lt;bean id=\"localeChangeInterceptor\" class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 然后在配合SessionLocaleResovler，实现动态的改变本地信息 1234567&lt;!--SessionLocaleResolver--&gt;&lt;bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\"/&gt;&lt;!--资源国际化拦截器--&gt;&lt;mvc:interceptors&gt; &lt;bean id=\"localeChangeInterceptor\" class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 控制器层的代码瞬间变得极其简练，就一个跳转页面对返回语句 12345678910@Controllerpublic class UserController &#123;@RequestMapping(\"/toLogin\")public String logIn() &#123; return \"login\";&#125;&#125; 测试结果：","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC拦截器","date":"2019-08-14T10:13:01.000Z","path":"2019/08/14/SpringMVC拦截器(Interceptor)/","text":"拦截器概述什么是拦截器？Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），但是比过滤器的功能更加强大，它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义：1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。 2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。 #### 实现第一个拦截器 以实现HandlerInterceptor接口方式为例，自定义拦截器类的代码如下： 123456789101112131415161718192021222324252627282930package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"1.执行目标方法之前......\"); //返回true表示放行，可以去执行目标方法，否者表示不允许执行目标方法 return true;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"3.执行目标方法之后......\");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"5.来到页面之后......\");&#125;&#125; 上述代码中，自定义拦截器实现了HandlerInterceptor接口，并实现了接口中的三个方法： preHandle()：在目标方法执行之前回执行，有个boolean类型的返回值，当返回true表示放行，即允许执行目标方法;当返回false，表示不放行，即不运行执行目标方法，此时会中断以后的所有过程 postHandle()：在目标方法执行结束后会执行，且解析视图之前执行 afterCompletion()：在请求到达页面，即视图渲染完成后执行 开发拦截器就像开发servlet或者filter一样，都需要在配置文件进行配置，配置代码如下： 12345&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id=\"myInterceptor\" class=\"com.xust.iot.interceptor.MyFirstInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 上面的代码中，&lt;mvc:interceptors&gt;元素用于配置一组拦截器，子元素&lt;bean&gt;中定义的是全局拦截器，它会拦截所有的请求；而也可以使用&lt;mvc:interceptor&gt;元素中定义指定路径的拦截器，它会对指定路径下的请求生效。&lt;mvc:interceptor&gt;元素的子元素&lt;mvc:mapping&gt;用于配置拦截器作用的路径，该路径在其属性path 中定义。如果在请求路径中包含不需要拦截的内容，还可以通过&lt;mvc:exclude-mapping&gt;元素进行配置。注意：&lt;mvc:interceptor&gt;中的子元素必须按照上述代码中的配置顺序进行编写，即&lt;mvc:mapping&gt; &lt;mvc:exclude-mapping&gt; &lt;bean&gt;，否则文件会报错。 下面写一个控制器来测试一下正常情况下单个拦截器的工作流程： 123456789101112131415161718package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IntercrtorTestController &#123;@RequestMapping(value = \"/test01\")public String handler01(Model model)&#123; System.out.println(\"2.执行了目标方法......\"); model.addAttribute(\"msg\",\"你好啊！！!\"); return \"success\";&#125;&#125; 目标页面success.jsp 1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(\"4.来到了success.jsp页面\");%&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 测试结果 单个拦截器正常情况下的工作流程： 1. 拦截器preHandle方法执行，返回true继续以后的过程 2. 控制器目标方法执行 3. 拦截器postHandle方法执行 4. 页面渲染完成来到页面 5. 拦截器afterCompletion方法执行 单个拦截器非正常情况下的工作流程：单个拦截器的非正常情况分为两种情况：&nbsp;&nbsp;&nbsp;&nbsp;1、拦截器中的preHandler方法返回false;&nbsp;&nbsp;&nbsp;&nbsp;2、虽然preHandler方法返回了true，但是其中有一个过程“炸了”，比如发生了异常没有处理接下来通过代码来测试： 第一种情况：preHandler返回false123456789101112131415161718192021222324252627282930package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"1.执行目标方法之前......\"); //返回true表示放行，可以去执行目标方法，否者表示不允许执行目标方法 return false;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"3.执行目标方法之后......\");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"5.来到页面之后......\");&#125;&#125; 测试结果：可以看到，后面的过程直接无法执行 第二种情况：preHandle方法放行了，但是有一个过程“炸了”,比如我们在控制器目标方法中制造一个异常：12345678910111213141516171819package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IntercrtorTestController &#123;@RequestMapping(value = \"/test01\")public String handler01(Model model)&#123; int i=30/0; System.out.println(\"2.执行了目标方法......\"); model.addAttribute(\"msg\",\"你好啊！！!\"); return \"success\";&#125;&#125; 测试结果： 可以看到，只要拦截器的prehandle方法放行了，拦截器的afterCompletion方法总会执行/font> 多个拦截器正常情况下的工作流程：第二个拦截器： 1234567891011121314151617181920212223242526package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MySecondInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"1.执行目标方法之前......MySecondInterceptor\"); return true;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"3.执行目标方法之后......MySecondInterceptor\");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"5.来到页面之后......MySecondInterceptor\");&#125;&#125; 配置第二个拦截器 12345678910111213&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--拦截器1--&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id=\"myInterceptor\" class=\"com.xust.iot.interceptor.MyFirstInterceptor\"/&gt; &lt;!--拦截器2--&gt; &lt;!--使用&lt;mvc:interceptor&gt;可以具体配置拦截器拦截那些请求&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/test01\"/&gt; &lt;bean class=\"com.xust.iot.interceptor.MySecondInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 执行结果： 交换拦截器在springmvc配置文件中的定义顺序： 12345678910111213&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--拦截器2--&gt; &lt;!--使用&lt;mvc:interceptor&gt;可以具体配置拦截器拦截那些请求&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/test01\"/&gt; &lt;bean class=\"com.xust.iot.interceptor.MySecondInterceptor\"/&gt; &lt;/mvc:interceptor&gt; &lt;!--拦截器1--&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id=\"myInterceptor\" class=\"com.xust.iot.interceptor.MyFirstInterceptor\"/&gt;&lt;/mvc:interceptors&gt; 执行结果： 测试结果表明： 多个拦截器是有执行的先后顺序的，这个顺序就是定义的先后顺序 拦截器的preHandle方法：按照定义顺序顺序执行的 拦截器的postHandle方法：按照定义顺序逆序执行的 拦截器的preHandle方法：按照定义顺序顺逆序执行的 多个拦截器非正常情况下的工作流程：1、一个拦截器的preHandle方法返回false的情况： 2、所有拦截器的preHandle方法都返回true,但是中间有过程发生了异常： 小结单拦截器的执行顺序 正常情况下会按照：preHandle--->目标方法--->postHnadle--->页面渲染--->afterCompetion执行 当preHandle返回false,就没有以后流程的事儿了 当preHandler返回了true,但是中间过程发生异常，会直接结束以后的流程但是afterCompetion总会执行 多个拦截器的执行顺序正常情况 会按照配置中定义的顺序顺序执行所有拦截器的preHandle方法，然后执行控制器中目标方法，之后按照定义顺序的逆序执行postHandle方法，然后渲染页面，最后按照定义的顺序的逆序执行afterComprtion方法 有拦截器返回false 在多个拦截器中只要有一个拦截器的preHandle方法返回了false,那么以后的流程都没有了，会直接回按照这些拦截器配置的定义顺序的逆序执行afterCompetion方法","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC文件下载和上传","date":"2019-08-13T14:33:06.000Z","path":"2019/08/13/SpringMVC文件下载和上传/","text":"文件下载文件下载的最重要的一点是设置响应头的Content-disposition为attachmen;filename=要下载的文件的名字,然后得到文件的输入流写入本地即可1. 常规方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 第一种文件下载的方法：使用原生的Servlet API * * @param filename 下载的文件名，SpringMVC会根据请求参数自动注入 * @param request * @param response * @throws UnsupportedEncodingException */@RequestMapping(value=\"/download1\",method=RequestMethod.GET)public void download(@ResuestParam(\"filename\")String fileName, HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123; response.setContentType(\"text/html;charset=utf-8\"); //解析文件在服务器中的真实路径 String filePath = request.getServletContext().getRealPath(\"/download/\" + fileName); //System.out.println(filePath); BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //设置响应头告诉客户端浏览器，这个请求是要下载文件 long fileLength = new File(filePath).length(); response.setContentType(\"application/x-msdownload;\"); response.setHeader(\"Content-disposition\", \"attachment;filename=\" + fileName); response.setHeader(\"Content-Length\", String.valueOf(fileLength)); //向客户端浏览器写文件数据 bis = new BufferedInputStream(new FileInputStream(filePath)); bos = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[1024]; int len; while (-1 != (len = bis.read(buff, 0, buff.length))) &#123; bos.write(buff, 0, len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != bis) &#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null != bos) &#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2. 使用SpringMVC提供的 ResponseEntity&lt;T&gt;类型，使用它可以很方便地定义返回的HttpHeaders和HttpStatus。 123456789101112131415161718192021222324252627282930313233343536/** *第二种文件下载的方式：使用SpringMVC提供的esponseEntity类型 * @param filename 下载的文件的名字，通过前端页面的请求参数带过来后SpringMVC会自动注入 * @param request * @return * @throws IOException */@RequestMapping(value = \"/download2\",method = RequestMethod.GET)public ResponseEntity&lt;byte[]&gt; download(String filename, HttpServletRequest request) throws IOException &#123; System.out.println(filename); //得到文件在服务器上的真实物理路径 String filePath = request.getServletContext().getRealPath(\"/download/\" + filename); /** * 两个把下载文件转成byte[]的办法：一种是把要下载的文件封装成一个File对象，把这个对象交给FileCopyUtils.copyToByteArray(file) */ File file = new File(filePath); /** * 另一种方法是：自己写一个转换的方法，如下 */ /*FileInputStream fis = new FileInputStream(filePath); byte[] file = new byte[fis.available()]; fis.read(); fis.close();*/ String downFileName = new String(filename.getBytes(\"utf-8\"), \"iso-8859-1\"); HttpHeaders headers = new HttpHeaders(); //这是文件下载关键:设置contentDisposition为attachment headers.setContentDispositionFormData(\"attachment\", downFileName); headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity&lt;byte[]&gt;(FileCopyUtils.copyToByteArray(file), headers, HttpStatus.OK);&#125; 下载页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%pageContext.setAttribute(\"ctp\",request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;下载高清图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;高清壁纸下载&lt;/h2&gt;&lt;table&gt;&lt;tr&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/18.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=18.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=18.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/13.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=13.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=13.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/14.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=14.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=14.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/15.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=15.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=15.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/16.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=16.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=16.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src=\"../..$&#123;ctp&#125;/download/17.jpg\" width=\"420px\" height=\"320px\"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href=\"download1?filename=17.jpg\"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href=\"download2?filename=17.jpg\"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 测试结果 文件上传文件上传这里使用的是commons-fileupload-1.4,他需要依赖commons-io,他们的Maven依赖如下： 12345678910111213&lt;!--文件上传--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 1. 单文件上传上传表单页面文件上传需要将表单的提交方法设置为post，将enctype的值设置为”multipart/form-data”。 1234567&lt;!--单文件上传--&gt;&lt;h3&gt;单文件上传&lt;/h3&gt;&lt;form action=\"$&#123;ctp&#125;/uploadImg\" method=\"post\" enctype=\"multipart/form-data\"&gt; 头像： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt; 控制器在Controller的处理方法中，使用MultipartFile对象作为参数接收前端上传过来的文件 12345678910111213141516171819202122232425262728293031323334353637383940//单个文件上传@RequestMapping(\"/uploadImg\")public String ImgUpload( @RequestParam(\"username\") String userName, @RequestParam(\"headerImg\") MultipartFile file, HttpServletRequest request, Model model) &#123; String date = new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date()); try &#123; //得到服务器上传文件的文件夹物理路径 String realPath = request.getServletContext().getRealPath(\"/upload/\"); File dir=new File(realPath+date+\"//\"); if(!dir.exists())&#123; boolean res=dir.mkdir(); if(!res)&#123; model.addAttribute(\"msg\", \"文件上传失败！请重试！\"); return null; &#125; &#125; //解析文件后缀名 String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(\".\"), fileName.length()); if(\".jpg\".equals(suffix)||\".png\".equals(suffix)||\".gif\".equals(suffix)||\".jpeg\".equals(suffix)||\"bmp\".equals(suffix)) &#123; //给上传的文件重新命名 File newFileName = new File(dir.toString() + \"//\" + System.currentTimeMillis() + suffix); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute(\"msg\", \"文件上传成功！\"); &#125;else&#123; model.addAttribute(\"msg\",\"文件上传失败！只支持jpeg, jpg, png, gif, bmp 格式的图片文件\"); &#125; &#125; catch (Exception e) &#123; model.addAttribute(\"msg\", \"文件上传失败！\"); &#125; return \"fileUpLoad\";&#125; 在springmvc配置文件中注册文件上传组件使用MultipartFile对象接收前端上传过来的文件，还需要在springmvc的配置文件中进行如下配置： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;!--文件上传解析器的id是固定的，必须是multipartResolver--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--上传的文件总大小50M--&gt; &lt;property name=\"maxUploadSize\" value=\"#&#123;1024*1024*50&#125;\"/&gt; &lt;!--单个文件最大5M--&gt; &lt;property name=\"maxUploadSizePerFile\" value=\"#&#123;1024*1024*5&#125;\"/&gt; &lt;!--默认的字符编码：utf-8--&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt;&lt;/bean&gt;&lt;/beans&gt; 多文件上传其实多文件上传也很简单，单文件上传是在Controller的处理方法中使用MultipartFile对象作为参数接收前端上传过来的文件，而多文件上传则使用MultipartFile对象数组来接收。 页面该页面中有几个name值一样的file类型的input标签，其他跟单文件上传的页面没区别。 123456789&lt;h3&gt;一次选一个文件，一次提交上传多个文件&lt;/h3&gt;&lt;form action=\"$&#123;ctp&#125;/upload2\" method=\"post\" enctype=\"multipart/form-data\"&gt; 头像： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; 图片： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; 资料： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; 文件： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt; 控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Controllerpublic class FileUpLoadController &#123;@RequestMapping(\"/upload2\")public String upload(@RequestParam(\"username\") String userName, @RequestParam(\"headerImg\") MultipartFile[] files, HttpServletRequest request, Model model) &#123; String realPath = request.getServletContext().getRealPath(\"/upload/\"); File dir = new File(realPath + date +\"//\"+userName+\"//\"); if (!dir.exists()) &#123; boolean res = dir.mkdirs(); if (!res) &#123; model.addAttribute(\"msg\", \"文件上传失败！请重试！\"); return null; &#125; &#125; for (MultipartFile file : files) &#123; uploadFile(dir.toString(), file, model); &#125; return \"fileUpLoad\";&#125;public void uploadFile(String path, MultipartFile file, Model model) &#123; try &#123; if (!file.isEmpty()) &#123; String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(\".\"), fileName.length()); //给上传的文件重新命名 File newFileName = new File(path + \"//\" + System.currentTimeMillis() + suffix); System.out.println(newFileName); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute(\"msg\", \"文件上传成功！\"); &#125; &#125; catch (Exception e) &#123; model.addAttribute(\"msg\", \"文件上传失败！\" + e); &#125;&#125;&#125; 同样的，使用MultipartFile数组接收前端上传过来的多个文件，也需要在springmvc的配置文件进行配置，具体配置与上述单文件上传的springmvc.xml配置没差别。这样，就可以进行多文件上传了。 多种文件上传情景综合当然，项目开发中，场景可能并不是这么简单，上述的多文件上传是一个个文件选择后一起上传（即多个name相同的input标签），那要是我项目中只要一个input标签就可以一次性多个文件呢？又或者一个页面中既要一个个选择的多文件上传，又要一次性选择的多文件上传，还要有单文件上传呢？没问题，MultipartFile[]通吃，代码也很easy，下面直接上代码。 页面 1234567891011121314151617181920212223242526&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% pageContext.setAttribute(\"ctp\",request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"$&#123;ctp&#125;/upload3\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;!--一次选择一个文件的多文件上传--&gt; 头像： &lt;input type=\"file\" name=\"headerImg\"/&gt;&lt;br/&gt; &lt;!--一次选择一个文件的多文件上传 --&gt; &lt;input type=\"file\" name=\"img\"/&gt;&lt;br/&gt; &lt;input type=\"file\" name=\"img\"/&gt;&lt;br/&gt; &lt;input type=\"file\" name=\"img\"/&gt;&lt;br/&gt; &lt;!--一次选多个文件的多文件上传 --&gt; 图片：&lt;input type=\"file\" name=\"pic\" multiple/&gt;&lt;br/&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RequestMapping(\"/upload3\")public String upload(@RequestParam(\"username\") String userName, @RequestParam(\"headerImg\") MultipartFile[] files1, @RequestParam(\"img\") MultipartFile[] files2, @RequestParam(\"pic\") MultipartFile[] files3, HttpServletRequest request, Model model) &#123; String realPath = request.getServletContext().getRealPath(\"/upload/\"); File dir = new File(realPath + date +\"//\"+userName+\"//\"); if (!dir.exists()) &#123; boolean res = dir.mkdirs(); if (!res) &#123; model.addAttribute(\"msg\", \"文件上传失败！请重试！\"); return null; &#125; &#125; for (MultipartFile file : files1) &#123; uploadFile(dir.toString(), file, model); &#125; for (MultipartFile file : files2) &#123; uploadFile(dir.toString(), file, model); &#125; for (MultipartFile file : files3) &#123; uploadFile(dir.toString(), file, model); &#125; return \"fileUpLoad\";&#125;public void uploadFile(String path, MultipartFile file, Model model) &#123; try &#123; if (!file.isEmpty()) &#123; String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf(\".\"), fileName.length()); //给上传的文件重新命名 File newFileName = new File(path + \"//\" + System.currentTimeMillis() + suffix); System.out.println(newFileName); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute(\"msg\", \"文件上传成功！\"); &#125; &#125; catch (Exception e) &#123; model.addAttribute(\"msg\", \"文件上传失败！\" + e); &#125;&#125; 测试结果 MultipartFile[]就是如此强大，不管单个多个，逻辑处理一样，所以建议在项目开发中使用MultipartFile[]作为文件的接收参数。 拓展1、MutipartFile类的一些常用方法： String getContentType() //获取文件MIME类型 InputStream getInputStream() //获取文件流 String getName() //获取表单中文件组件的名字 String getOriginalFilename() //获取上传文件的原名 long getSize() //获取文件的字节大小，单位byte boolean isEmpty() //是否为空 void transferTo(File dest) //保存文件到服务器指定路径 2、CommonsMultipartResolver的属性解析 defaultEncoding：表示用来解析request请求的默认编码格式，当没有指定的时候根据Servlet规范会使用默认值ISO-8859-1。当request自己指明了它的编码格式的时候就会忽略这里指定的defaultEncoding。 uploadTempDir：设置上传文件时的临时目录，默认是Servlet容器的临时目录。 maxUploadSize：设置允许上传的总的最大文件大小，以字节为单位计算。当设为-1时表示无限制，默认是-1。 maxUploadSizePerFile：跟maxUploadSize差不多，不过maxUploadSizePerFile是限制每个上传文件的大小，而maxUploadSize是限制总的上传文件大小。 maxInMemorySize：设置在文件上传时允许写到内存中的最大值，以字节为单位计算，默认是10240。 resolveLazily：为true时，启用推迟文件解析，以便在UploadAction中捕获文件大小异常。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC对Ajax异步请求的支持","date":"2019-08-11T15:46:55.000Z","path":"2019/08/11/SpringMVC对Ajax异步请求的支持/","text":"Ajax异步请求概念AJAX: Ansyc Javascript And Xml (异步请求).异步是指基于Ajax的应用与服务器通信的方法。对于传统的Web应用，每次用户发送请求或向服务器请求获得新数据时，浏览器都会完全丢弃当前页面，而等待重新加载的页面。在服务器完全响应之前，用户浏览器将是一片空白，用户的动作必须中断。异步是指用户发送请求后，完全无须等待，请求在后台发送，不会阻塞用户的当前活动，用户无须等待第一次请求得到完全响应，就可以立即发送第二次请求。简单的说,异步请求不会刷新当前html页面。异步指的是服务器端响应数据的获取方式。 同步： 异步： 异步&amp;同步的区别1.同步请求： 请求的过程：浏览器(当前的html页面会丢弃) —&gt; http协议 —&gt; Web服务器(tomcat) 响应的过程：Web服务器(tomcat) —&gt; http协议 –&gt; 返回一个新html页面. 2.异步请求： 请求的过程：浏览器(当前的html页面不会丢弃) —&gt; Ajax引擎(http协议) —&gt; Web服务器(tomcat) 响应的过程：Web服务器(tomcat) —&gt; 准备部分数据 –&gt; Ajax引擎(http协议) –&gt; DOM编程. 总而言之，异步请求只是局部刷新页面，同步请求会全部刷新当前的页面 jQuery框架的异步请求和处理1.$.ajax([settings]) —jQuery核心处理异步请求的方法：语法： $.ajax([settings]) 最简单的情况下，$.ajax() 可以不带任何参数直接使用。具体语法格式都有哪些参数请参照：https://www.w3school.com.cn/jquery/ajax_ajax.asp 2.$.post() $.post() 方法通过 HTTP POST 请求从服务器上请求数据。语法： $.post(url, data, function(data, status){// status(状态码): success 、error// data : 响应数据}, dataType); 必需的 URL 参数规定您希望请求的 URL。可选的 data 参数规定连同请求发送的数据。可选的 function 参数是请求成功后所执行的函数名,其中data是响应的数据，status是状态码可选的dataType参数是服务器响应返回的数据 3.$.get() $.get() 方法通过 HTTP GET 请求从服务器上请求数据。 $.get(url, data, function(data, status){// status(状态码): success 、error// data : 响应数据}, dataType); 必需的 URL 参数规定您希望请求的 URL。可选的 data 参数规定连同请求发送的数据。可选的 function 参数是请求成功后所执行的函数名,其中data是响应的数据，status是状态码可选的dataType参数是服务器响应返回的数据 springMVC支持ajax异步请求和处理返回json数据数据绑定@RequestBody/@ResponseBody&lt;/font size=4&gt;@RequestBody&nbsp;&nbsp;&nbsp;&nbsp;功能 ：用于将HttpServletRequest的getInputStream()的内容绑定到方法入参例如： @RequestMapping(value = “/hello”) public String handleRequest(@RequestBody String body){ //body参数就被请求参数自动绑定} &lt;/font size=4&gt;@ResponseBody&nbsp;&nbsp;&nbsp;&nbsp;功能：被ResponseBody修饰的方法的返回值会被作为响应体 @RequestMapping(value = “/hello”)@ResponseBody public User handleRequest(Ueser user){ return User; //返回值会被作为响应体，而且如果返回值是对象时SpringMVC会自动转换成JSON给页面} 使用@RequestBody/@ResponseBody来支持Ajax可以使用@RequestBody来自动获取Ajax上传的数据，同时也可以使用@ResponseBody，把要返回的对象自动拼成JSON的格式返回。当然，需要加入几个jackson的包，这里加入了：jackson-core-2.9.3.jar、jackson-annotations-2.9.3.jar、jackson-databind-2.9.3.jar，Maven依赖如下： 12345678910111213141516171819 &lt;!--jackson的三个依赖包--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt; Controller 123456789101112131415161718192021222324252627282930313233343536373839 /** * ResponseBody:用于将ResponseBody方法的返回值作为响应体 * RequestBody:用于将HttpServletRequest的getInputStream()内容绑定到入参 * * @param users * @return */@ResponseBody@RequestMapping(value = \"/getAllUserByAJAX\", produces = \"application/json;charset=UTF-8\")public List&lt;User&gt; getAllUserByAJAX(@ModelAttribute(\"users\") List&lt;User&gt; users) &#123; return users;&#125;/** * RequestBody：将请求体的数据绑定到入参 * * @param user * @return */@ResponseBody@RequestMapping(\"/testRequestBody\")public User testRequestBody(@RequestBody User user, Model model) &#123; System.out.println(\"请求的数据：\"+user); model.addAttribute(\"requestInfo\", user); return user;&#125;/** * 提前把全部信息查询好放在隐含模型中 * @param model */@ModelAttribute(\"users\")public void getAll(Model model) &#123; IUserService userService = new IUserServiceImpl(); List&lt;User&gt; lists = userService.getUser(null, null, null); model.addAttribute(\"users\", lists);&#125; 1. 通过AJAX获得服务器数据的页面： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% pageContext.setAttribute(\"ctp\", request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;ajax&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $().ready(function () &#123; $(\"#first\").click(function () &#123; alert(\"adacd\"); $.ajax(&#123; url: \"$&#123;ctp&#125;/getAllUserByAJAX\", type: \"GET\", success: function (data) &#123; //console.log(data) $.each(data, function () &#123; var userInfo = this.name + \"---\" + this.age + \"---\" + this.email; $(\"#user\").append(userInfo + \"&lt;br/&gt;\"); &#125;) &#125; &#125;); return false; &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%=new Date()%&gt;&lt;div id=\"user\"&gt;&lt;/div&gt;&lt;a id=\"first\" href=\"$&#123;ctp&#125;/getAllUserByAJAX\"&gt;获取全部用户信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 测试结果 2. 通过AJAX向服务器发JSON数据，服务器返回JSON数据 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;% pageContext.setAttribute(\"ctp\", request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$().ready(function () &#123; $(\"#first\").click(function () &#123; //点击发送JSON数据给服务器 $.ajax(&#123; url: \"$&#123;ctp&#125;/testRequestBody\", type: \"POST\", contentType:\"application/json\", //请求的文本格式：json data: JSON.stringify(&#123;name: $(\"#username\").val(), age: $(\"#userage\").val(), email: $(\"#userEmail\").val()&#125;), //给服务器提交的数据 dataType: \"json\", //服务器返回的数据类型 success: function (data) &#123; var userInfo = data.name + \"---\" + data.age + \"---\" + data.email; $(\"#users\").append(userInfo + \"&lt;br/&gt;\"); &#125; &#125;); return false; &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"$&#123;ctp&#125;/testRequestBody\" method=\"post\"&gt;&lt;input id=\"username\" name=\"username\" type=\"text\"/&gt;&lt;input id=\"userage\" name=\"age\" type=\"text\"/&gt;&lt;input id=\"userEmail\" name=\"enail\" type=\"email\"/&gt;&lt;/form&gt;&lt;button type=\"button\"&gt;&lt;a id=\"first\" href=\"$&#123;ctp&#125;/testRequestBody\"&gt;AJAX发送JSON数据给服务器&lt;/a&gt;&lt;/button&gt;&lt;div id=\"users\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试结果","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC 数据绑定、数据格式化、数据校验","date":"2019-08-09T10:29:31.000Z","path":"2019/08/09/SpringMVC 数据绑定、数据格式化、数据校验/","text":"数据绑定流程 Spring MVC将ServletRequest对象及目标方法的入参实例传给WebDataBinderFactory实例，创建出DataBinder(数据绑定的核心部件) DataBinder调用转配在SpringMVC上下文中的ConversionService组件进行数据类型转换、数据格式化。并将servlet中的请求信息填充到入参对象中 调用Validator组件对已经绑定好的请求消息的入参进行数据合法性校验，并最终生成数据绑定结果BindingResult对象 Spring MVC抽取BindingResult中的入参对象和检验错误对象，将他们赋给处理方法的响应入参 Spring MVC通过反射机制对目标方法进行解析，将请求消息绑定到处理方法的入参中。 数据转换2.1 ConversionService Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作。 Spring3.0 添加了一个通用的类型转换模块，位于 org.springframework.core.convert 包中 ConversionService 接口是类型转换的核心接口 Modifier and Type Method and Description boolean canConvert(Class sourceType, Class targetType)判断是否可以将一个 java 类转换为另一个 java 类 boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) 需转换的类将以成员变量的方式出现在宿主类中，TypeDescriptor 不但描述了需转换类的信息，还描述了从宿主类的上下文信息，如成员变量 上的注解，成员是否是数组、集合或 Map 的方式呈现等 &lt;T&gt;&nbsp;T convert(Object source, Class&lt;T&gt; targetType) 将原类型对象转换为目标类型对象. Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) 将对象从原类型对象转换为目标类型对象，此时往往会用到所在宿主类的上下文信息 2.2 自定义类型转换器Spring 在 org.springframework.core.convert.converter 包中定义了 3 种类型转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到 ConversionServiceFactroyBean 中： Converter&lt;S,T&gt;：将S类型对象转换为T类型对象 ConverterFactory：将相同系列多个Converter封装在一起.如果希望将一种类型的对象转换为另一种类型及其子类的对象（例如将 String 转换为 Number 及Number 子类（Integer、Long、Double 等）对象）可使用该转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类找那个的上下文信息进行类型转换 ConverstionServiceFactoryBean 的 converters 属性可以接受 Converter、ConverterFactory、GenericConverter 或 ConditionalGenericConverter 接口的实现类，并把这些转换器的转换逻辑统一封装到一个 ConverstionService 实例对象中(GenericConversionService),Spring 在 Bean属性配置及 Spring MVC 请求消息绑定时将利用这个 ConversionService 实例完成类型转换工作。 实际应用中常用的是Converter&lt;S,T&gt;，下面通过他实现一个自定义的类型转换器：关键步骤： 实现Converter接口，他有两个泛型，S:是转换前的了类型，T:是转换后的类型 ，实现Converter接口的conver方法，在方法中定制对S类型如何转换换成T类型的规则 在springmvc配置文件中将自定义的Converter配置在ConversionService中 告诉SpringMVC使用我们自定义的类型转换器 假设处理方法有一个 User 类型的入参，我们希望将一个格式化的请求字符串直接转为 User对象，该字符串格式如（小明:男:软件工程:软工3306班:1134556） 编写自定义类型转换器 1234567891011121314151617181920212223package com.xzy.converter;import com.xzy.bean.Student;import org.springframework.core.convert.converter.Converter;public class StringToStudentConverter implements Converter&lt;String, Student&gt; &#123; //在这个方法中定义转换的规则 @Override public Student convert(String param) &#123; Student student = new Student(); //param==&gt;小明:男:软件工程:软工3306班:17033309 if (null != param &amp;&amp; !\"\".equals(param)) &#123; String[] pa=param.split(\":\"); student.setName(pa[0]); student.setGender(pa[1]); student.setSclass(pa[2]); student.setMajor(pa[3]); student.setSid(pa[4]); &#125; return student; &#125;&#125; 在SpringMVC配置文件中将自定义的Converter方在IOC容器中交给Spring管理 1234567891011&lt;!--该 标 签 会 创 建 并 注 册 一 个 默 认 的 DefaultAnnotationHandlerMapping 和一个ReqeustMappingHandlerAdpter实现，除此之外&lt;mvc:annotaion-driven/&gt;标签还会注册一个默认的ConversionService（FormattingConversionServiceFactoryBean）以满足大多数类型转换 的需求 ，当用到自定义类型转换器时，需要用&lt;mvc:annotation-driven conversion-service=”xxx”/&gt;覆盖默认--&gt;&lt;!--配置自定义的类型转换器--&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"com.xzy.converter.StringToStudentConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 用&lt;mvc:annotation-driven conversion-service=”xxx”/&gt;覆盖默认的类型转换器 12&lt;!--在&lt;mvc:annotation-driver中配置conversion-service覆盖默认的转换器&gt;--&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 控制器： 123456789101112131415161718package com.xzy.contorller;import com.xzy.bean.Student;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class StudentController &#123; @RequestMapping(\"/addStudent\") public String addStudent(@RequestParam(\"stuInfo\") Student student, Model model) &#123; System.out.println(\"封装的\" + student); model.addAttribute(\"stuinfo\",student); return \"success\"; &#125;&#125; 测试结果： 数据格式化Spring 使用转换器进行源类型对象到目标类型对象的转换，Spring 的转换不提供输入及输出信息格式化工作，像日期、时间、数字、货币等数据都具有一定格式的，在不同的本地化环境中，同一类型的数还会相应地呈现不同的显示格式。如何从格式化的数据中获取真正的数据以完成数据绑定，并将处理完成的数据输出为格式化的数据，是 spring 格式化框架要解决的问题，Spring 引入了一个新的格式化框架，这个框架位于 org.springframework.format 类包中，其中最重要的一个接口 FormatterSpring 的 org.springframework.format.datetime 包中提供了一个用于时间对象格式化的DateFormatter 实现类，而 org.springframework.format.number 包中提供了 3 个用于数字对象格式化的实现类。 NumberFormatter:用于数字类型对象的格式化 CurrencyFormatter:用于货币类型对象的格式化 PercentFormatter: 用于百分数数字类型对象的格式化 示例：有一个员工类employee.java 1234567891011121314151617181920212223242526272829303132package com.xzy.bean;import org.springframework.format.annotation.DateTimeFormat;import org.springframework.format.annotation.NumberFormat;import java.math.BigDecimal;import java.util.Date;public class employee &#123; private String mame; @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birth; //生日 //表示3位一个逗号，保留两位小数 @NumberFormat(pattern = \"#,###.##\") private Double salary; //薪水 //省略getter、setter @Override public String toString() &#123; return \"employee&#123;\" + \"mame='\" + mame + '\\'' + \", birth=\" + birth + \", salary=\" + salary + '&#125;'; &#125;&#125; 要使注解可以发挥作用还需要在注解中配置如下信息： 12345678&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\"com.xzy.converter.StringToStudentConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; &nbsp;&nbsp;&nbsp;&nbsp;对属性对象的输入/输出进行格式化，从其本质上讲依然属于 “类型转换” 的范畴。Spring 在格式化模块中定义了一个实现 ConversionService 接口的FormattingConversionService 实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能。&nbsp;&nbsp;&nbsp;&nbsp;FormattingConversionService 拥有FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者FormattingConversionServiceFactroyBean 内部已经注册了 :NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解装配了 FormattingConversionServiceFactroyBean 后，就可 以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。&lt;mvc:annotation-driven/&gt;默认创建的ConversionService 实例即为 FormattingConversionServiceFactroyBean. 数据校验应用程序在执行业务逻辑前，必须通过数据校验保证接收到的输入数据是正确合法的，如代表生日的日期应该是一个过去的时间、工资的数值必须是一个整数等。一般情况下，应用程序的开发时分层的，不同层的代码由不同的开发人员负责。很多时候，同样的数据验证会出现在不同的层中，这样就会导致代码冗余，违反了DRY原则。为了避免这样的情况，最好将验证逻辑和响应的域模型进行绑定，将代码验证的逻辑集中起来管理。 JSR-303 JSR-303是Java为Bean数据合法校验锁提供的标准框架，它已经包含在JavaEE 6.0中。JSR-303通过在Bean属性上标注类似于@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。可以通过http://jcp.org/en/jsr/detail?id=303了解更多详细内容。JSR-303定义了一套可标注在成员变量、属性方法上的校验注解： JSR-303 支持 XML 风格的和注解风格的验证，接下来我们首先看一下如何和 Spring 集成。 1. 导入jar包,此处使用 Hibernate-validator 实现（版本：hibernate-validator-6.0.17.Final-dist.zip），他的Maven依赖如下： 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.17.Final&lt;/version&gt;&lt;/dependency&gt; 在Spring配置中添加JSR-303验证框架支持 1234&lt;!--配置对JSR-303的支持--&gt;&lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\"/&gt;&lt;/bean&gt; 通过 ConfigurableWebBindingInitializer 注册 validator 12345&lt;!--注册validator--&gt;&lt;bean id=\"webBinding\" class=\"org.springframework.web.bind.support.ConfigurableWebBindingInitializer\"&gt; &lt;property name=\"conversionService\" ref=\"conversionService\"/&gt; &lt;property name=\"validator\" ref=\"validator\"/&gt;&lt;/bean&gt; 使用 JSR-303 验证框架注解为模型对象指定验证信息 123456789101112131415161718192021222324252627282930313233343536 package com.xzy.bean;import javax.validation.constraints.*;public class Student &#123;@NotEmptyprivate String name;@Size(min = 7,max=10)private String sid; //学号@Pattern(regexp = \"/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/\")private String phone; //手机号码@NotBlankprivate String sclass;@NotEmptyprivate String major; //省略getter、setter @Overridepublic String toString() &#123; return \"Student&#123;\" + \"姓名：'\" + name + '\\'' + \", 学号：'\" + sid + '\\'' + \", 手机：'\" +phone + '\\'' + \", 班级：'\" + sclass + '\\'' + \", 专业：'\" + major + '\\'' + '&#125;'; &#125;&#125; 控制器 123456789101112131415161718192021222324252627//@Vaild就是告诉SpringMVC 把数据绑定好后要根据Bean里面的校验规则校验@RequestMapping(value = \"/addStudent\", method = RequestMethod.POST)public String addStudent2( @Valid @ModelAttribute Student student, Errors error, Model model) &#123; logger.info(student); model.addAttribute(\"student\", student); if (error.hasErrors()) &#123; System.out.println(error); logger.error(error); return \"add\"; //如果有错误，就返回填写页面重新填写 &#125; return \"success\";&#125;@RequestMapping(value=\"/&#123;formName&#125;\")public String loginForm( @PathVariable String formName, Model model)&#123; System.out.println(formName); Student student= new Student(); model.addAttribute(\"student\",student); // 动态跳转页面 return formName;&#125; 通过在命令对象上注解@Valid 来告诉 Spring MVC 此命令对象在绑定完毕后需要进行 JSR-303验证，如果验证失败会将错误信息添加到 Errors 错误对象中。 验证失败后回到填写表单的页面（/WEB-INF/jsp/pages/add.jsp）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt;&lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form modelAttribute=\"student\" method=\"post\" action=\"addStudent.htm\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"name\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"name\" cssStyle=\"color:red\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;学号:&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"sid\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"sid\" cssStyle=\"color:red\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机:&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"phone\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"phone\" cssStyle=\"color:red\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;班级:&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"sclass\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"sclass\" cssStyle=\"color:red\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;专业:&lt;/td&gt; &lt;td&gt;&lt;form:input path=\"major\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path=\"major\" cssStyle=\"color:red\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： 自定义国际化错误消息提示在上面的程序中有一个不好的地方，错误消息不是 我们自定义的，而且都是英文的，下面我们来看看如何在通过国际化配置文件实现自定义国际化错误消息提示。使用 System.out.println(&quot;错误码：&quot;+fieldError.getCodes());可以得到错误的错误码，每种错误都定义了4中错误码，如下： 他们从上到下所包含的范围由小到大，我们在写国际化配置文件的时候，每条配置的key必须是4个code中的一个code。 error_en_US.properties 12345NotBlank.student.name=name must not be emptySize.student.sid=the length must between &#123;2&#125; and &#123;1&#125;Pattern.student.phone=please write a right phone numberNotBlank.student.sclass=class must not be emptyNotEmpty.student.major=major must not be empty error_zh_CN.properties 12345NotBlank.student.name=姓名不能为空!Size.student.sid=长度应该在&#123;2&#125;和&#123;1&#125;之间!Pattern.student.phone=请填写正确的手机号码!NotBlank.student.sclass=班级不能为空!NotEmpty.student.major=专业不能为空! 在springmvc.xml文件中配置国际化资源： 123456789101112131415161718&lt;!--配置国际化资源--&gt; &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"&gt; &lt;property name=\"basenames\" value=\"error\"/&gt; &lt;!-- &lt;property name=\"basenames\" value=\"message\"/&gt;--&gt; &lt;property name=\"useCodeAsDefaultMessage\" value=\"false\"/&gt; &lt;property name=\"cacheSeconds\" value=\"0\"/&gt; &lt;!--配置字符编码为UTF-8：注意properties的编码格式也应该是UTF-8的，否者即使你设置了字符编码过滤器也会乱码--&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;!-- 主要用于获取请求中的locale信息，将其转为Locale对像，获取LocaleResolver对象--&gt; &lt;mvc:interceptors&gt; &lt;bean id=\"localeChangeInterceptor\" class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"/&gt; &lt;/mvc:interceptors&gt; &lt;!-- 配置SessionLocaleResolver用于将Locale对象存储于Session中供后续使用 --&gt; &lt;bean id=\"SessionLocaleResolver\" class=\"org.springframework.web.servlet.i18n.SessionLocaleResolver\"/&gt; 测试结果：","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC自定义视图和视图解析器","date":"2019-08-08T14:36:02.000Z","path":"2019/08/08/SpringMVC自定义视图和视图解析器/","text":"自定义视图解析器：123456789101112131415161718192021222324252627282930313233343536package com.xzy.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;/** * 自定义视图解析器 */public class MyViewResolver implements ViewResolver, Ordered &#123; private int order = 0; @Overridepublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; if (viewName.startsWith(\"my:\")) &#123; //返回自定义的视图对象 return new MyView(); &#125; else &#123; //不能处理就不要强行处理了，返回null让别的视图处理器来处理 return null; &#125; &#125;@Overridepublic int getOrder() &#123; return order;&#125;public void setOrder(int order) &#123; this.order = order; &#125;&#125; 自定义视图：1234567891011121314151617181920212223242526272829303132333435363738package com.xzy.view;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.List;import java.util.Map;/** * 自定义视图 */public class MyView implements View &#123; //返回的文本类型：text/html @Override public String getContentType() &#123; return \"text/html\"; &#125; // 渲染视图:在这个方法中写你对这个视图的渲染效果 @Override public void render(Map&lt;String, ?&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(\"方法中保存的数据：\" + map); httpServletResponse.setContentType(\"text/html\"); PrintWriter out = httpServletResponse.getWriter(); out.write(\"&lt;h3&gt;精彩内容即将呈现...Loading&lt;/h3&gt;\"); List&lt;Object&gt; lists= (List&lt;Object&gt;) map.get(\"video\"); out.write(\"&lt;ul&gt;\"); for(Object object:lists)&#123; out.write(\"&lt;li&gt;&lt;a href='download'&gt;\"+object+\"&lt;/a&gt;&lt;/li&gt;\"); &#125; out.write(\"&lt;/ul&gt;\"); &#125;&#125; 好了，现在视图处理和视图都定义好，这样我们的视图解析器就可以工作了吗？非也！虽然我们实现了ViewRelover接口.但是对于SpringMVC来说他就是一个普通的java类，SpringMVC如何知道去哪里调用我们的视图解析器呢?解决的方法是：在springmvc配置文件中配置我们的视图解析器，交给Spring IOC容器管理。 1234567&lt;!--配置自定义的视图解析器: springmvc中视图解析器得到视图时优先级高的会先去尝试解析，order的数值越小，优先级越高 自定义的视图解析器需要实现Orderd接口，默认的视图解析器InternalResourceViewResolver的优先级最低 --&gt; &lt;bean class=\"com.xzy.view.MyViewResolver\"&gt; &lt;property name=\"order\" value=\"0\"/&gt; &lt;/bean&gt; 注意：自定义的视图解析器必须要实现ordered接口，以给我们自定义的视图解析器指定优先级，优先级的规则是值越小，优先级高；SpringMVC默认的视图解析器InternalResourceViewResolver的优先级是最低的。 编写控制器123456789101112131415161718192021222324package com.xzy.contorller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.List;@Controllerpublic class MyViewController &#123; @RequestMapping(\"/viewhandler\") public String myViewTest(Model model)&#123; List&lt;String&gt; vnames=new ArrayList&lt;String&gt;(); vnames.add(\"java疯狂讲义300集\"); vnames.add(\"java从入门到如入土！！！\"); vnames.add(\"Spring,SpringMVC从入门到放弃！！！\"); vnames.add(\"MySql从删库到跑路！！！\"); model.addAttribute(\"video\",vnames); return \"my:/hello\"; &#125;&#125; 测试结果：总结自定义视图处理器和视图的步骤： 编写视图处理器（实现ViewReslover接口的resolveViewName方法）和视图（实现View接口的两个方法：getContentType()、render()） 视图解析器必须放在IOC容器中 视图处理器除了要实现ViewReslover接口，还应该实现ordered接口，已给我们定义的视图解析器指定优先级，这个很关键.","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC视图解析","date":"2019-08-07T06:41:44.000Z","path":"2019/08/07/SpringMVC视图解析/","text":"SpringMVC视图解析 &nbsp; &nbsp; &nbsp;对于控制器的目标方法，无论其返回值是String、View、ModelMap或是ModelAndView，SpringMVC都会在内部将它们封装为一个ModelAndView对象进行返回。 &nbsp; &nbsp; &nbsp; Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是JSP也可是Excell、 JFreeChart等各种表现形式的视图。 视图（View） 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。 为了实现视图模型和具体实现技术的解耦，Spring在org.springframework.web.servlet包中定义了一个高度抽象的View接口。 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题。所谓视图是无状态的，是指对于每一个请求，都会创建一个View对象。 JSP是最常见的视图技术。 视图解析器（ViewResolver）和视图（View） springMVC用于处理视图最重要的两个接口是ViewResolver和View。 所以视图解析器的作用就是通过视图名（处理方法的返回值）生成View对象，所有的视图解析器都必须实现ViewResolver接口。 SpringMVC为逻辑视图名的解析提供了不同的策略，可以在Spring WEB上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。程序员可以选择一种视图解析器或混用多种视图解析器。可以通过order属性指定解析器的优先顺序，order越小优先级越高，SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则抛出ServletException异常。在项目中可以配置InternalResourceViewResolver作为视图解析器,在springmvc.xml中可以做如下配置： 12345&lt;!--配置视图解析器--&gt;&lt;bean id=\"viewHandler\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; forward: 和redirect:一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理，会经过视图解析器拼串，但如果返回的字符串中带forward:或redirect:前缀时，SpringMVC会对它们进行特殊处理：将forward: 和redirect: 当成指示符，其后的字符串作为URL 来处理。示例如下：index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href=\"handler1\"&gt;handler1&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler2\"&gt;handler2&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler3\"&gt;handler3&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler4\"&gt;handler4&lt;/a&gt;&lt;br/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; hello.jsp，在当前项目的根路径下，和index.html同级 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;这是hello.jsp&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ViewTestController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xzy.Contorller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ViewTestController &#123; /** * handler1把请求转发到hello.jsp页面 * @return */ @RequestMapping(\"/handler1\") public String handler1()&#123; System.out.println(\"handler1\"); return \"forward:/hello.jsp\"; &#125; /** * handler把请求转发给handler1 * @return */ @RequestMapping(\"/handler2\") public String handler2()&#123; System.out.println(\"handler2\"); return \"forward:handler1\"; &#125; /** * 重定向到hello.jsp * @return */ @RequestMapping(\"/handler3\") public String handler3()&#123; System.out.println(\"handler3\"); return \"redirect:/hello.jsp\"; &#125; /** * 重定向到handler3 * @return */ @RequestMapping(\"/handler4\") public String handler4()&#123; System.out.println(\"handler4\"); return \"redirect:handler3\"; &#125;&#125; 测试结果: 按F12打开开发者工具，可以看到确实两次重定向 SpringMVC视图的解析流程(结合源码分析) 源码中把任何返回返回值封装为ModelAndView的实现：123456789101112131415161718192021222324 protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; this.checkRequest(request); ModelAndView mav; if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized(mutex) &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; if(!response.containsHeader(\"Cache-Control\")) &#123;if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; this.applyCacheSeconds(response,this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; this.prepareResponse(response); &#125; &#125; return mav; &#125; 这里以发出了一个GET请求为例：首先FrameworkServlet类会来处理这个GET请求doGet 123protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.processRequest(request, response); &#125; processRequest 123456789101112131415protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //省略..... try &#123; //它本类中的这个方法是个抽象方法，实现这个方法的类是DispatcherServlet this.doService(request, response); &#125; catch (IOException | ServletException var16) &#123; failureCause = var16; throw var16; &#125; catch (Throwable var17) &#123; //省略.....var17); &#125; finally &#123; //省略..... &#125; &#125; DispatcherServlet 类doService方法 12345678910111213protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略..... //给request域中设置了一些东西 try &#123; //调用doDispatch方法处理 this.doDispatch(request, response); &#125; finally &#123; ...... &#125; &#125; doDispatch方法 12345protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... this.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); //省略...... &#125; processDispatchResult方法,这个方法就是最终将数据交给页面的方法 12345678910111213141516171819202122232425 private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; //如果这里出现了异常就处理异常 if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123;this.logger.debug(\"ModelAndViewDefiningException encountered\", exception); mv = ((ModelAndViewDefiningException)exception).getModelAndView(); &#125; else &#123; Object handler = mappedHandler != null ? mappedHandler.getHandler() : null; //如果自己配置了自定义的HandlerExceptionResolver将会在这个方法里处理 mv = this.processHandlerException(request, response, handler, exception); errorView = mv != null; &#125; &#125; if (mv != null &amp;&amp; !mv.wasCleared()) &#123; //调用render方法进行视图渲染 this.render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else if (this.logger.isTraceEnabled()) &#123; this.logger.trace(\"No view rendering, null ModelAndView returned.\"); &#125; //省略...... &#125; DispatcherServlet 类 的render方法并没有继承View接口的render,和View接口的render不是一回事，这个render仅仅是为了命名统一而起的一个名字 123456789101112131415161718192021222324252627protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... //从ModelView中拿到视图名 String viewName = mv.getViewName(); View view; if (viewName != null) &#123; //这一步就是得到一个View对象，resolveViewName的实现看下边 view = this.resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(\"Could not resolve view with name '\" + mv.getViewName() + \"' in servlet with name '\" + this.getServletName() + \"'\"); &#125; &#125; else &#123; view = mv.getView(); if (view == null) &#123; throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a View object in servlet with name '\" + this.getServletName() + \"'\"); &#125; &#125; //省略...... try &#123; //省略...... //调用了View接口的render方法，这里实际上调用的是视图在渲染时会把Model传入 view.render(mv.getModelInternal(), request, response); &#125; catch (Exception var8) &#123; //省略...... &#125;&#125; resolveViewName方法，循环遍历你配置的视图解析器，viewResolvers是进过order排序的，这一步就是ViewResolvers是如何通过视图名产生View对象的关键 1234567891011protected View resolveViewName(String viewName,Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; //遍历我们配置的视图解析器 for (ViewResolver viewResolver : this.viewResolvers) &#123; //ViewResolver根据方法的返回值，得到一个View对象，这块又有一个resolveViewName，具体的实现请往下看 View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; return null;&#125; InternalResourceViewResolver继承了AbstractCachingViewResolver，resolveViewName方法首先会判断有没有缓存，要是有缓存，它会先去缓存中通过viewName查找是否有View对象的存在，要是没有，它会通过viewName创建一个新的View对象，并将View对象存入缓存中，这样再次遇到同样的视图名的时候就可以直接在缓存中取出View对象了 12345678910111213141516171819202122232425262728293031@Overridepublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; //判断有缓存中有没有view对象，有就直接拿来用 if (!isCache()) &#123; return createView(viewName, locale); &#125; else &#123; Object cacheKey = getCacheKey(viewName, locale); View view = this.viewAccessCache.get(cacheKey); if (view == null) &#123; synchronized (this.viewCreationCache) &#123; view = this.viewCreationCache.get(cacheKey); if (view == null) &#123; //根据方法的返回值创建出View对象 view = createView(viewName, locale); if (view == null &amp;&amp; this.cacheUnresolved) &#123; view = UNRESOLVED_VIEW; &#125; if (view != null) &#123; this.viewAccessCache.put(cacheKey, view); this.viewCreationCache.put(cacheKey, view); if (logger.isTraceEnabled()) &#123; logger.trace(\"Cached view [\" + cacheKey + \"]\"); &#125; &#125; &#125; &#125; &#125; return (view != UNRESOLVED_VIEW ? view : null); &#125;&#125; createView的实现细节： 12345678910111213141516171819202122232425protected View createView(String viewName, Locale locale) throws Exception &#123; if (!this.canHandle(viewName, locale)) &#123; return null; &#125; else &#123; String forwardUrl; //如果方法得到返回值是以redirect：开始的 if (viewName.startsWith(\"redirect:\")) &#123; forwardUrl = viewName.substring(\"redirect:\".length()); RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible()); String[] hosts = this.getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return this.applyLifecycleMethods(\"redirect:\", view); //如果方法的返回值是以forward:开始的 &#125; else if (viewName.startsWith(\"forward:\")) &#123; forwardUrl = viewName.substring(\"forward:\".length()); InternalResourceView view = new InternalResourceView(forwardUrl); return this.applyLifecycleMethods(\"forward:\", view); &#125; else &#123; //其他情况的处理,这里又有一个createView，它调用了父类的createView创建了一个默认的View对象 return super.createView(viewName, locale); &#125; &#125;&#125; 以下都是解析视图名的实现细节，感兴趣的可以看一下。 父类AbstractCachingViewResolver类的createView实现细节： 123protected View createView(String viewName, Locale locale) throws Exception &#123; return loadView(viewName, locale);&#125; InternalResourceViewResolver继承了UrlBasedViewResolverUrlBasedViewResolver类中loadView方法的实现： 12345protected View loadView(String viewName, Locale locale) throws Exception &#123; AbstractUrlBasedView view = buildView(viewName); View result = applyLifecycleMethods(viewName, view); return (view.checkResource(locale) ? result : null); &#125; UrlBasedViewResolver的buildView方法会获取一个View对象，这个对象会将视图以什么格式呈现给用户，例如如果是jsp显示呈现给用户的话，那这个view对象就是JstlView，默认的是JstlView。在这个方法中我们看到了getPrefix() + viewName + getSuffix()这样一段代码，这就是对视图路径的一个拼接了，getPrefix()方法获取前缀，也就是我们在配置文件中配置的&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/PAGE/&quot;/&gt;的value中的值了,getSuffix()方法就是获取后缀值了，也就是我们在配置文件中配置的&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;的value中的值。这样就将将视图的物理路径找到了，并赋值到View的URL属性中去。 123456789101112131415161718192021222324252627protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; Class&lt;?&gt; viewClass = this.getViewClass(); Assert.state(viewClass != null, \"No view class\"); AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(viewClass); view.setUrl(this.getPrefix() + viewName + this.getSuffix()); String contentType = this.getContentType(); if (contentType != null) &#123; view.setContentType(contentType); &#125; view.setRequestContextAttribute(this.getRequestContextAttribute()); view.setAttributesMap(this.getAttributesMap()); Boolean exposePathVariables = this.getExposePathVariables(); if (exposePathVariables != null) &#123; view.setExposePathVariables(exposePathVariables); &#125; Boolean exposeContextBeansAsAttributes = this.getExposeContextBeansAsAttributes(); if (exposeContextBeansAsAttributes != null) &#123; view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes); &#125; String[] exposedContextBeanNames = this.getExposedContextBeanNames(); if (exposedContextBeanNames != null) &#123; view.setExposedContextBeanNames(exposedContextBeanNames); &#125; return view;&#125; 就这样我们得到了一个View对象，这个视图的name就是逻辑视图名，因为当将View对象放在缓存的时候，我们可以通过逻辑视图名在缓存中找出View对象。我们在获取到View对象的时候，我们还要将View进行渲染，并呈现给用户。 View是个接口,AbstractView实现了render方法: 1234567891011public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"View \" + this.formatViewName() + \", model \" + (model != null ? model : Collections.emptyMap()) + (this.staticAttributes.isEmpty() ? \"\" : \", static attributes \" + this.staticAttributes)); &#125; //主要是将一些属性填充到Map中 Map&lt;String, Object&gt; mergedModel = this.createMergedOutputModel(model, request, response); //对response头进行了一些属性设置 this.prepareResponse(request, response); //渲染给页面输出的所有model数据 this.renderMergedOutputModel(mergedModel, this.getRequestToExpose(request), response);&#125; 最后一行的renderMergedOutputModel方法由AbstractView的孙子类InternalResourceView实现InternalResourceView的renderMergedOutputModel方法帮我们获取到视图的物理路径，然后将这段路径传给RequestDispatcher对象，再调用RequestDispatcher的forward方法将页面呈现给用户，这样就走完了视图的解析了。 12345678910111213141516171819202122232425262728293031@Overrideprotected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(\"Could not get RequestDispatcher for [\" + getUrl() + \"]: Check that the corresponding file exists within your web application archive!\"); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Including resource [\" + getUrl() + \"] in InternalResourceView '\" + getBeanName() + \"'\"); &#125; rd.include(request, response); &#125;else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(\"Forwarding to resource [\" + getUrl() + \"] in InternalResourceView '\" + getBeanName() + \"'\"); &#125; //对请求进行转发，至此结束了视图解析解析过程 rd.forward(request, response); &#125;&#125; 最后一句话总结：视图解析器只是为了得到视图对象；视图对象才是真正的转发（将模型数据发在request域中数据）或重定向到页面（视图对象才是真正的渲染视图）。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC处理模型参数","date":"2019-08-07T06:14:42.000Z","path":"2019/08/07/SpringMVC-处理模型参数/","text":"SpringMVC 提供了以下几种途径输出模型数据: ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据 Map、Model以及ModelMap:入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 Java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中。 @SessionAttributes: 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性 @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中。 当然，除了上面这些SpringMVC提供的几种方法，SpringMVC支持直接使用Servlet几个原生API来给页面传值: HttpServletRequest request、HttpservletResponse response、HttpSession session、InputStream/Reader 对应request.getInputStream()、OutputStream/Writer 对应response.getOutputStram() servlet原生API给页面传值123456789101112131415/** * 使用servlet原生API给页面输出数据 * @param request * @param session * @return */ @RequestMapping(\"handler01\") public String handler01(HttpServletRequest request, HttpSession session) throws IOException &#123; request.setAttribute(\"msg\",\"你好，这是HelloController\"); session.setAttribute(\"msg\",\"json123\"); return \"success\"; &#125; 页面测试代码:success.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;table border=\"1px\" width=\"70%\" &gt; &lt;tr&gt; &lt;th&gt;域&lt;/th&gt; &lt;th&gt;值&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;requestScope&lt;/th&gt; &lt;td&gt;$&#123;requestScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;applicationScope&lt;/th&gt; &lt;td&gt;$&#123;applicationScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;pageScope&lt;/th&gt; &lt;td&gt;$&#123;pageScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： Model、Map、ModelMap首先通过通过源码看看他们三者的关系：ModelMap类 Model接口 ExtendModelMap类 BindingAwareModelMap类 通过打开源码，我们不难总结出如下继承关系 ： 接下来看看他们的用法：示例代码 123456789101112131415161718192021222324252627282930313233343536373839/** * 使用Model * @param model * @return */ @RequestMapping(\"/handler02\") public String handler02(Model model)&#123; System.out.println(\"Model\"+model.getClass()); model.addAttribute(\"msg\",\"大家好！这是handler02\"); model.addAttribute(\"id\",18); return \"success\"; &#125; /** * 使用Map * @param map * @return */ @RequestMapping(\"/handler03\") public String handler03(Map&lt;String,String&gt; map)&#123; System.out.println(\"Map:\"+map.getClass()); map.put(\"msg\",\"handler03\"); map.put(\"logged\",\"admin\"); return \"success\"; &#125; /** * 使用ModelMap * @param modelMap * @return */ @RequestMapping(\"/handler04\") public String handler04(ModelMap modelMap)&#123; System.out.println(\"ModelMap:\"+modelMap.getClass()); modelMap.addAttribute(\"msg\",\"handler04\"); return \"success\"; &#125; 页面代码和上面样 测试结果：页面的显示： 控制台打印的信息: 从测试结果可以总结出：Model(SpringMVC接口)其中一个实现类是ExtendedModelMapModelMap是Map(JDK的接口)Map的一个实现类,并且ModelMap被ExtendedModelMapExtendedModelMap被BindingAwareModelMap继承Model、Map、ModelMap不论用哪个，最终工作的都是BindingAwareModelMap,而且从测试结果可以看到通过这三个设置的值，SpringMVC都把他们放在了request域中。 ModelAndView 目标方法的返回值可以是ModelAndView类型，从名字上就可以看到，这是一个既包括模型(Model)又有视图(View)的一个类， 然而事实也确实如此，他的model就可以理解为送给页面的数据，他的View可以理解为目标页面地址。但我们在他的model中放入值后，SpringMVC会把ModelAndView的model中数据放在request域对象中。 示例代码 123456789101112 /** * 方法的返回值可以是 ModelAndView类型，这样我们可以把值设置在model中 * 然后springmvc会把ModelAndView的model中数据放在request域对象中 * @return */@RequestMapping(\"/handler05\")public ModelAndView handler05()&#123; ModelAndView mv=new ModelAndView(\"success\"); mv.addObject(\"msg\",\"handler05\"); return mv;&#125; 测试结果： 使用@SessionAttributes注解如果希望在多个请求之间共用某个模型属性数据，则可以在控制器类标注一个 @SessionAttributes，SpringMVC 会将模型中对应的属性暂存到 HTTPSession 中。@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中。 @SessionAttributes(types=User.class)会将隐含模型中所有类型为 User 的属性添加到会话中 @SessionAttributes(value={“user1”, “user2”})将名为 user1 和 user2 的模型属性添加到会话中 @SessionAttributes(types={“User.class”, “Dept.class”})将模型中所有类型为 User 及 Dept 的属性添加到会话中 @SessionAtributes(value={“user1”, “user2”}, types={Dept.class})将名为 user1 和 user2 的模型属性添加到会话中，同时将所有类型为 Dept 的模型属性添加到会话中总之：当使用@SessionAttributes注解时就是告诉SpringMVC,当@SessionAttributes中的value值和BindingAwareModelMap的key一样时，那么在session也你也给我保存一份相同的值示例代码：1234567891011121314//使用的时候一定要注意@SessionAttributes只能用在类上@SessionAttributes(value=&#123;\"id\",\"logged\"&#125;)@Controllerpublic class HelloController &#123; @RequestMapping(\"/handler0\") public String sessionAttributesTest(Model model)&#123; model.addAttribute(\"msg\",\"handler0\"); //这个会在request中显示 model.addAttribute(\"logged\",new Date()); //会在session中显示 model.addAttribute(\"id\",\"001\"); //会在session中显示 return \"success\"; &#125;&#125; 页面代码对success.jsp中的sessionScope稍作修改： 1234 &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125; | $&#123;sessionScope.id&#125; |$&#123;sessionScope.logged&#125;&lt;/td&gt;&lt;/tr&gt; 测试结果： 使用@ModelAttribute注解先来看看ModelAttribute的定义：查看 @ModelAttribute注解定义可以看到这个注解可以用在方法和参数中。 在 SpringMVC 的 Controller 中使用 @ModelAttribute 时，应用情况包括下面几种：1、应用在方法上。2、应用在方法的参数上。3、应用在方法上，并且方法也使用了@RequestMapping 示例代码：修改图书信息的页面： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;!-- &lt;a href=\"handler01\"&gt;原生API输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler02\"&gt;Model输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler03\"&gt;Map输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler04\"&gt;ModelMap输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler05\"&gt;ModelAndView带回返回值&lt;/a&gt;&lt;br/&gt;--&gt; &lt;h3&gt;更新图书信息&lt;/h3&gt; &lt;form action=\"update\" method=\"post\"&gt; 书名：&lt;label&gt;西游记&lt;/label&gt;&lt;br/&gt; 作者：&lt;label&gt;吴承恩&lt;/label&gt;&lt;br/&gt; 价格：&lt;input type=\"text\" name=\"price\" placeholder=\"输入价格...\"/&gt;&lt;br/&gt; 库存：&lt;input type=\"text\" name=\"stock\" placeholder=\"输入库存...\"/&gt;&lt;br/&gt; 销量：&lt;input type=\"text\" name=\"sales\" placeholder=\"输入销量...\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交图书修改信息后的页面： 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/8/7 Time: 10:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;更新图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style=\"height: 200px;width: 100%\"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border=\"1px\" width=\"50%\"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 如果没有使用@ModelAttribute，那么要更新数据信息，必须要全字段更新，即使你不需要更新的的字段，你也要填写，这显然不和常理，因为如果你不填写这个值，值就会为null。最主要是因为SpringMVC在封装提交的信息的时候只会new一个Book对象，里面的属性的值初始就是null。你没有填写也只会以null存到数据库。不使用@ModelAttribute进行非全字段更新 12345678@Controllerpublic class BookController &#123; @RequestMapping(\"/update\") public String update(Book book)&#123; System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; &#125; 测试结果:页面的显示： 看看控制台的打印信息： 可以看到果然不出预料的出问题了，更新信息后书名和作者的信息没了。这就相当于你更改了一下你的QQ密码，然后你的QQ号没了！这是很可怕的事情。使用@ModelAttribute解决问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class BookController &#123; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中查询图书数据 Book book=new Book(); book.setName(\"西游记\"); book.setPrice(9.98); book.setAuthor(\"吴承恩\"); book.setSales(300); book.setStock(400); System.out.println(\"数据库中查询到Book的信息：\"+book); map.put(\"book\",book); System.out.println(\"ModelAttribute将查询到的图书信息保存起来.......：\"); &#125;&#125; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute(\"book\")，就是告诉SpringMVC，去拿一个key为 * book的值，你不要重新new一个Book对象了，这样做的好处是可以只更改有更新的数据，没有更新的就保持原始值 * @param book * @return */ @RequestMapping(\"/update\") public String update(@ModelAttribute(\"book\") Book book)&#123; System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; 测试结果：页面展示的结果： 控制台打印的信息： 而且从控制台打印的信息来看，被@ModelAttribute标识的方法确实是在处理器方法之前执行了 @Modelattribute的原理废话不多说，直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;/** * @Author: HuangXin * @Date: Created in 10:33 2019/8/7 * @Description: */@Controllerpublic class BookController &#123; private Object obj1; private Object b1; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute(\"book\")，就是告诉SpringMVC，你去拿一个key为book的值， * 你不要重新new一个Book对象了 * @param book * @return */ @RequestMapping(\"/update\") public String update(@ModelAttribute(\"book\") Book book, Map&lt;String,Object&gt; model)&#123; System.out.println(\"处理器方法的map:\"+model.getClass()); System.out.println(\"book==b1=&gt;\"+(book==b1)); System.out.println(\"obj1==model=&gt;\"+(obj1==model)); System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中拿数据 Book book=new Book(); book.setName(\"西游记\"); book.setPrice(9.98); book.setAuthor(\"吴承恩\"); book.setSales(300); book.setStock(400); System.out.println(\"数据库中查询到Book的信息：\"+book); obj1=map; b1=book; map.put(\"book\",book); System.out.println(\"@ModelAttribute中的map:\"+map.getClass()); System.out.println(\"ModelAttribute将查询到的图书信息保存起来.......：\"); &#125;&#125; 测试结果： 最后总结为一张图：","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC获取请求参数","date":"2019-08-06T11:24:59.000Z","path":"2019/08/06/Springmvc/","text":"第一种方式：方法的形参上给一个和请求参数同名的参数1.获得普通类型的参数值示例代码 123456789101112131415/** * 第1种获得请求参数的方式：在方法的形参上给一个和请求参数同名的参数， * 之后SpringMVC会帮我们自动注入参数值 * @param username * @param model * @return */@RequestMapping(value = \"/welcome\")public String welcome(String username, Model model)&#123; System.out.println(\"用户名：\"+username); model.addAttribute(\"username\",username); return \"success\";&#125; 2.获得POJO类型的值示例代码：新建Book.java以及Address.java两个POJOBook.java 12345678910111213package com.xzy.bean;public class Book &#123; private String name; private Double price; private Integer stock; //库存 private Integer sales; //销量 private String author; private Address address; //地址 //省略getter、setter方法，并且重写toString()方法&#125; Address.java 123456789package com.xzy.bean;public class Address &#123; private String province; private String county; private String city; //省略getter、setter方法，并且重写toString()方法 写一个简单的表单：index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMvc获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h3&gt;录入书籍信息&lt;/h3&gt; &lt;form action=\"book\" method=\"post\"&gt; 书名：&lt;input type=\"text\" name=\"name\" placeholder=\"输入书名...\"/&gt;&lt;br/&gt; 作者：&lt;input type=\"text\" name=\"author\" placeholder=\"输入作者...\"/&gt;&lt;br/&gt; 价格：&lt;input type=\"text\" name=\"price\" placeholder=\"输入价格...\"/&gt;&lt;br/&gt; 库存：&lt;input type=\"text\" name=\"stock\" placeholder=\"输入库存...\"/&gt;&lt;br/&gt; 销量：&lt;input type=\"text\" name=\"sales\" placeholder=\"输入销量...\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"address.province\" /&gt;省&amp;nbsp; &lt;input type=\"text\" name=\"address.city\" /&gt;市&amp;nbsp; &lt;input type=\"text\" name=\"address.county\" /&gt;(区/县)&amp;nbsp;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交后的页面：book.jsp 12345678910111213141516171819202122232425&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" import=\"com.xzy.bean.*\"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style=\"height: 200px;width: 100%\"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border=\"1px\" width=\"50%\"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;地区&lt;/th&gt;&lt;td&gt;$&#123;book.address&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提供一个控制器：BookContorller.java 1234567891011121314151617181920212223242526package com.xzy.controller;import com.xzy.bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;@Controllerpublic class BookContorller &#123; /** * SprningMVC帮我们自动注入参数到POJO类型中，而且还可以级联注入 * @param book * @param request * @return */ @RequestMapping(\"/book\") public String addbook(Book book, HttpServletRequest request)&#123; //打印得到的book信息 System.out.println(book); request.setAttribute(\"book\",book); return \"book\"; &#125;&#125; 测试结果： 第二种方式：使用Spring提供的注解1. 使用@RequestParam 获取参数分析@RequestParam的源码： 123456789101112131415public @interface RequestParam &#123; //默认值就是它，表示请求参数的key @AliasFor(\"name\") String value() default \"\"; //请求参数的值 @AliasFor(\"value\") String name() default \"\"; //设置这个参数是否必须，required=false表示这个参数不是必须的 boolean required() default true; //参数的默认值 String defaultValue() default \"\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n\"; &#125; 示例代码： 12345678910111213141516171819/** * RequestParam设置获取参数的key为user,required=false表示这个参数不是必须的， * defaultValue是这个参数的默认值 * @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username； * 等价于以前写的： * String user=null!=request.getParameter(\"user\")?request.getParameter(\"user\"):\"\"; * @param username * @param model * @return */@RequestMapping(\"/welcome3\")public String welocme3( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, Model model) &#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"username\", username); return \"success\";&#125; 2.使用@RequestHeader获得请求的头部信息@RequestHeader和@ReuqestParma的实现方式如出一辙，使用方法也基本相同。示例代码1：使用RequestHeader注解获得浏览器的信息 123456789101112131415161718192021/** * @RequestHeader(value = \"User-Agent\",required = false,defaultValue = \"\") String userAgent * 获取请求头中的值，相当于以前写的： * String header=null!=request.getHeader(\"User-Agent\")? request.getHeader(\"User-Agent\"):\"\"; * @param username * @param userAgent * @param model * @return */ @RequestMapping(\"/welcome4\") public String welocme4( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @RequestHeader(value = \"User-Agent\",defaultValue = \"\") String userAgent, Model model) &#123; System.out.println(\"用户名：\" + username); System.out.println(\"User-Agent\"+userAgent); model.addAttribute(\"userAgent\",userAgent); model.addAttribute(\"username\", username); return \"success\"; &#125; 示例代码2：使用RequestHeader注解获取请求头部的Cookie信息 123456789101112131415161718/** * 使用RequestHeader获得请求头中的Cookie的全部信息 * @param username * @param cookie * @param model * @return */ @RequestMapping(\"/welcome5\") public String welocome5( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @RequestHeader(value = \"Cookie\",required = false,defaultValue = \"\") String cookie, Model model)&#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"cookie\",cookie); model.addAttribute(\"username\", username); return \"success\"; &#125; 3.使用CookieValue获得请求头部的JSESSIONID示例代码： 123456789101112131415161718192021/** * 使用SpringMVC提供的@CookieValue注解，可以只获的JSESSIONID的值 * @param username * @param cookie * @param model * @return */ @RequestMapping(\"/welcome6\") public String welocome6( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @CookieValue(value = \"JSESSIONID\" ,required = false,defaultValue = \"\") String cookie, Model model)&#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"cookie\",cookie); model.addAttribute(\"username\", username); System.out.println(\"cookie：\"+cookie); return \"success\"; &#125;","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC 对Ant风格和Rest风格支持","date":"2019-08-04T10:16:40.000Z","path":"2019/08/04/SpringMVC支持的几种风格的URL形式/","text":"Ant风格的URL形式Ant风格的URL指的是URL的路径可以写成模糊路径，然后Spring MVC会帮我们匹配， ?：匹配一个字符 *: 匹配多个字符以及一层URL路径 **:可以匹配多个字符以及多层路径 匹配的规则：以最精确的路径为准，就是说当有多个路径可以匹配的时候，以最精确的路径为目标去访问 示例代码：新建AntTestServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * * Ant风格的URL指的是URL的路径可以写成模糊路径，然后Spring MVC会帮我们匹配 * ?：匹配一个字符 * *: 匹配多个字符以及一层URL路径 * **:可以匹配多个字符以及多层路径 * 匹配的规则：以最精确的路径为准，就是说当有多个路径可以匹配的时候，以最精确的路径为目标去访问 */@RequestMapping(\"/ant\")@Controllerpublic class AntTestServlet &#123; @RequestMapping(\"/handler1\") public String handler1()&#123; System.out.println(\"访问了handler1()\"); return \"index\"; &#125; //?可以匹配一个字符（“/”除外）,0个和多个都不行 @RequestMapping(\"/handler?\") public String handler2()&#123; System.out.println(\"访问了handler2()\"); return \"index\"; &#125; //*可以匹配任意多个字符 @RequestMapping(\"/handler*\") public String handler3()&#123; System.out.println(\"访问了handler3()\"); return \"index\"; &#125; /** * 匹配一层路径 * @return */ @RequestMapping(\"test/*/handler*\") public String handler4()&#123; System.out.println(\"访问了handler4()\"); return \"index\"; &#125; /** *匹配多层路径 * @return */ @RequestMapping(\"test/**/handler*\") public String handler5()&#123; System.out.println(\"访问了handler5()\"); return \"index\"; &#125;&#125; 测试结果: @PathVariable 路径占位符使用@PathVariable 注解可以获得路径中占位符的值示例代码: 测试结果： REST风格的URL形式编写一个控制器BooKContorller，模拟业务处理，里面写上增删改查的基本方法，然后定义不同的方法只有不同的请求才可以访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class BookContorller &#123; /** * 增加一本书 * @param model * @param bookId * @return */ @RequestMapping(value = \"book/&#123;bookId&#125;\",method = RequestMethod.PUT) public String addBook(Model model,@PathVariable String bookId)&#123; model.addAttribute(\"msg\",\"添加了一本书,书的Id是：\"+bookId); return \"index\"; &#125; /** * 删除一本书 * @param model * @param bookId * @return */ @RequestMapping(value = \"book/&#123;bookId&#125;\",method = RequestMethod.DELETE) public String deleteBook(Model model,@PathVariable String bookId)&#123; model.addAttribute(\"msg\",\"删除了一本书,书的Id是：\"+bookId); return \"index\"; &#125; /** * 更新一本书 * @param model * @param bookId * @return */ @RequestMapping(value = \"book/&#123;bookId&#125;\",method = RequestMethod.POST) public String updateBook(Model model,@PathVariable String bookId)&#123; model.addAttribute(\"msg\",\"更新了一本书,书的Id是：\"+bookId); return \"index\"; &#125; /** * 查询一本书 * @param model * @param bookId * @return */ @RequestMapping(value = \"book/&#123;bookId&#125;\",method = RequestMethod.GET) public String getBook(Model model,@PathVariable String bookId)&#123; model.addAttribute(\"msg\",\"查询了一本书,书的Id是：\"+bookId); return \"index\"; &#125;&#125; 但是页面上只能发出GET 和POST两种请求，如何解决delete和put请求呢？对于这个问题，SpringMVC中也给予了支持，即org.springframework.web.filter.HiddenHttpMethodFilter这个过滤器，只需要我们在web.xml中配置一个关于请求方法的过滤器： 123456789&lt;!--配置Http所有method的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在一个带有POST请求的表单里加入&lt;input name=&quot;_method&quot; value=&quot;请求方法名&quot;&gt;，value后面就填写需要的请求方法名即可。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"book/1\" method=\"get\"&gt; &lt;input name=\"bookId\"/&gt; &lt;button type=\"submit\"&gt;查询一本书&lt;/button&gt; &lt;/form&gt; &lt;form action=\"book/1\" method=\"post\"&gt; &lt;input name=\"_method\" value=\"delete\"&gt; &lt;button type=\"submit\"&gt;删除一本书&lt;/button&gt; &lt;/form&gt; &lt;form action=\"book/1\" method=\"post\"&gt; &lt;input name=\"_method\" value=\"put\"&gt; &lt;button type=\"submit\"&gt;增加一本书&lt;/button&gt; &lt;/form&gt; &lt;form action=\"book/1\" method=\"post\"&gt; &lt;button type=\"submit\"&gt;更新一本书&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 运行后会有一个问题：GET和POST的参数可以正常处理，但是当DELETE和PUT请求的时候，就会有下面的异常： 这是由于8.0以上的Tomcat不允许除了POST和GET以外的其他请求来访问JSP页面，解决的办法也很简单，如下： 解决这个问题后，最终的测试结果如下图：","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"RequestMapping注解","date":"2019-08-04T10:14:34.000Z","path":"2019/08/04/SpringMVC RequestMapping注解/","text":"@RequestMapping注解是一个十分强大的注解，Spring MVC使用@RequestMapping注解为控制器指定可以处理那些URL请求，在控制器的类上或类中的方法上均可以使用这个注解： 在类上使用可以提供初步的映射信息。相当于一个根路径 在方法上使用提供更进一步的细分映射信息。 这是一个只在方法上使用的例子： 1234567891011121314151617package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloServlet0 &#123; @RequestMapping(\"/hello\") public String sayHello(Model model)&#123; System.out.println(\"收到请求，正在处理.......\"); model.addAttribute(\"msg\",\"This is a Spring MVC Web\"); return \"success\"; &#125;&#125; 这是一个在类和方法同时使用的例子： 1234567891011121314151617181920package com.xzy.controller;import com.xzy.bean.Teacher;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(\"/welcome\") //这个相当于是基准路径public class HelloServlet &#123; @RequestMapping(\"/hello\") public String sayHello(Model model)&#123; System.out.println(\"收到请求，正在处理......\"); model.addAttribute(\"msg\",\"Welcome to SpringMVC!\"); return \"hello\"; &#125;&#125; @Requestmapping的属性: 属性作用 value 默认的属性就是value,他就是一个URL路径，可以在一个方法上或类上给多个value值 method 用来定义接收浏览器发来的何种请求。在Spring中，使用枚举类RequestMethod来封装了HTTP协议的所有请求方式。最基本的有GET、POST、DELETE、PUT params 表示请求参数，也就是追加在URL上的键值对，多个请求参数以&隔开 headers 该属性表示请求头，通过 @RequestMapping 中的 headers 属性，可以限制客户端发来的请求 consumes 规定请求头的Content-Type produces 告诉浏览器返回的内容是什么，给响应头中加上Content-Type 示例代码：method:限定请求方法 12345678910111213141516171819202122232425262728HelloServlet.java /** * 指定只有GET请求才可一访问 * @param model * @return */ @RequestMapping(value=\"/handler1\",method= RequestMethod.GET) public String handler1(Model model)&#123; System.out.println(\"收到请求，正在处理......\"); model.addAttribute(\"msg\",\"这是一个只有GET请求才可以访问页面\"); return \"success\"; &#125; /** * 指定只有POST请求才可以来访问 * @param model * @return */ @RequestMapping(value = \"/handler2\",method = RequestMethod.POST) public String handler2(Model model)&#123; System.out.println(\"收到请求，正在处理......\"); model.addAttribute(\"msg\",\"这是一个只有POST请求才可以访问页面\"); return \"success\"; &#125; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href=\"hello\"&gt;1.只在方法方法上用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href=\"home/hello\"&gt;2.在类和方法上同时用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href=\"home/handler1\"&gt;3.通过GET方法来访问&lt;/a&gt;&lt;br/&gt; &lt;form action=\"home/handler2\" method=\"post\"&gt; &lt;button type=\"submit\"&gt;4.POST提交&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; parmars:限定参数parmars支持简单的表达式计算，例如:eg1:params = {“username”} ,表示请求的路径中必须要有username这个关键字，如果没有就会报异常 eg2:params = {“!username”} ,表示请求的路径中不能有username这个关键字，如果有这个参数就会报异常eg2:params = {“username”,”age=20”,”pwd”} ,表示请求的路径中必须要有username、age、pwd这三个关键字，并且age必须是20，如果没有或age的值不等就会报异常 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href=\"hello\"&gt;1.只在方法方法上用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href=\"home/hello\"&gt;2.在类和方法上同时用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href=\"home/handler1\"&gt;3.通过GET方法来访问&lt;/a&gt;&lt;br/&gt; &lt;form action=\"home/handler2\" method=\"post\"&gt; &lt;button type=\"submit\"&gt;4.POST提交&lt;/button&gt; &lt;/form&gt; &lt;a href=\"home/handler3?username=hx\"&gt;5.限定请求参数1&lt;/a&gt;&lt;br/&gt; &lt;a href=\"home/handler4?username=hx&amp;age=20&amp;pwd=123456\"&gt;5.限定请求参数2&lt;/a&gt;&lt;br/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; headers:限定请求头部示例一： 测试结果：","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"SpringMVC的运行流程","date":"2019-08-03T15:24:58.000Z","path":"2019/08/03/SpringMVC入门/","text":"Spring MVC体系结构：SpringMVC 是基于 Model2 实现的技术框架 一个请求在SpringMVC中经历的过程： 请求旅程的第一站是 Spring 的 DispatcherServlet。与大多数基于 Java 的 Web 框架一样，Spring MVC 所有的请求都会通过一个前端控制器（front controller）Servlet。前端控制器是常用的 Web 应用程序模式，在这里一个单实例的 Servlet 将请求委托给应用程序的其他组件来执行实际的处理。在 Spring MVC 中，DispatcherServlet 就是前端控制器。 DispatcherServlet 的任务是将请求发送给 Spring MVC 控制器（controller）。控制器是一个用于处理请求的 Spring 组件。在典型的应用程序中可能会有多个控制器，DispatcherServlet 需要知道应该将请求发送给哪个控制器。所以 DispatcherServlet 以会查询一个或多个处理器映射（handler mapping） 来确定请求的下一站在哪里。处理器映射会根据请求所携带的 URL 信息来进行决策。 一旦选择了合适的控制器，DispatcherServlet 会将请求发送给选中的控制器 。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。） 控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。不过仅仅给用户返回原始的信息是不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML。所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且标示出用于渲染输出的视图名。它接下来会将请求连同模型和视图名发送回 DispatcherServlet 。 这样，控制器就不会与特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。实际上，它甚至并不能确定视图就是 JSP。相反，它仅仅传递了一个逻辑名称，个名字将会用来查找产生结果的真正视图。DispatcherServlet 将会使用视图解析器（viewResolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP。 既然 DispatcherServlet 已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是 JSP） ，在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端（不会像听上去那样硬编码） 。 可以看到，请求要经过很多的步骤，最终才能形成返回给客户端的响应。大多数的步骤都是在 Spring 框架内部完成的，也就是上图所示的组件中。 第一个SpringMVC程序第一步：配置环境（新建Web工程+导包+配置Tomcat）在IDEA中新建MavenWeb工程，新建好后导包，使用SpringMVC所需要的基本的Maven依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110pom.xml中的依赖&lt;properties &lt;spring.version&gt;5.1.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--Servlet JSP依赖 --&gt;&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;&lt;dependency&gt;&lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 第二步：配置DispatcherServlet通过DispatcherServlet这个名字可以大概了解到，这就是一个servlet,因此要想使一个sevlet起作用无非两种方法：一种是在servle类的头部加@WebServlet注解，二是在web.xml文件中配置&lt;servlet&gt;和servlet-mapping，第一种方法在这里显然不可行，人家源码肯定不能让改，那就需要在web.xml配置它，配置如下: 12345678910111213141516171819&lt;!--配置前段控制器DispatcherServlet到web.xml--&gt;&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--初始化参数：是springMVC配置文件的类路径，也可以不配这个，在笔记最后有说明--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;!--url路径表示拦截所有的请求 /和/*都是拦截所有的请求 /*的拦截范围更大，会拦截*.jsp,而/不会拦截*.jsp --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 接着在src/resources下新建springmvc.xml，配置springmvc： 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt;&lt;mvc:annotation-driven/&gt;&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;context:component-scan base-package=\"com.xzy.contorller\"/&gt;&lt;!-- 当请求的中径没有对应的controller 那么就访问静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--配置一个视图解析器：会帮我们拼接页面地址--&gt;&lt;bean id=\"jspViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步：在webapp包下新建一个index.html以及hello.jsp，随便写点啥123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href=\"hello\"&gt;hello&lt;/a&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=\"center\"&gt;第一个Spring mVC&lt;/h1&gt;&lt;center&gt; $&#123;msg&#125;&lt;br/&gt; $&#123;teacher.name&#125; &lt;hr/&gt; &lt;img src=\"img/a1.jpg\"/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 第四步：新建一个Controller，比如就叫HelloController1234567891011121314151617181920212223package com.xzy.controller;import com.xzy.bean.Teacher;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String sayHello(Model model)&#123; System.out.println(\"收到请求，正在处理......\"); model.addAttribute(\"msg\",\"Welcome to SpringMVC!\"); /* &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; 在xml配置的视图解析器会自动帮我们拼接页面地址：prefix+返回值+suffix */ return \"hello\"; &#125;&#125; 测试结果： 总结在做的时候的几细节1. Spring MVC 下Web项目的运行流程：1).点击http://localhost/SpringMVC_01_war_exploded/后浏览器把请求给服务器2).服务器中由于配置了SpringMVC的Dispatcherservlet，他可以拦截到所有的请求3).Dispatcherservlet拦截到请求后查看请求地址和@RequestMapping()中的那个地址(对应的方法)匹配，如果没找到，又没有配置&lt;mvc:defalut-servlet-handler/&gt;那就“炸了”!4).如果前端控制器找到目标处理器和方法后，在执行目标方法前拦截器的preHnalde方法会执行，然后利用反射调用方法5).方法执行完成会有返回值（视图名），SpringMVC认为这就是方法执行完后要去的页面，最终会把它封装成一个ModelAndView对象6).拿到ModelAndView对象后，视图解析器(ViewResolver)会根据ModelAndView解析出实际的视图(View)对象7).得到视图对象后，调用该View对象的render方法来渲染视图，视图渲染完成后前段控制器就会使用转发的方式到目标页面，之后拦截器的afterCompletion方法会被调用 2.关于springmvc.xml配置文件的配置：在web.xml配置前段控制器又这么一段配置，他的作用是告诉服务器去哪里加载对于前端控制器的配置文件： 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 如果我们没有写他会发生什么呢？会发生异常： 12345672019-08-03 15:07:16 [INFO]-[org.springframework.web.servlet.DispatcherServlet] Initializing Servlet 'app' 2019-08-03 15:07:16 [ERROR]-[org.springframework.web.servlet.DispatcherServlet] Context initialization failed org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from ServletContext resource [/WEB-INF/app-servlet.xml]; nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/app-servlet.xml] at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:344) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) 一大堆异常信息反正就是告诉中我们启动的时候没有找不到配置文件的路径，SpringMVC默认会在/WEB-INF目录下默认加载一个文件叫app-servlet.xml的文件，然而也没有找到，从而无法完成初始化。从这里我们知道，在web.xml中配置前端控制器的时候也可以不写初始化参数，但是我们必须将springmvc配置文件放在WEB-INF目录下，并且文件的必须名字是：在web.xml中前端控制器的&lt;servlet-name&gt;+-servlet.xml,这是规定，不可随便来，你想节省一些操作就得按人家的要求来。","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://easyblog.top/tags/SpringMVC/"}]},{"title":"Spring AOP详细配置与使用","date":"2019-08-03T15:18:35.000Z","path":"2019/08/03/Spring AOP详细配置与使用/","text":"AspectJ 通知类型 AOP 联盟定义通知类型，AOP联盟的jar都是接口，必须要有实现类。AspectJ通知类型只定义类型名称，以及方法格式，总共有6种；1.before：前置通知(应用：各种校验) 在方法执行前执行，如果通知抛出异常，将不会执行方法2.afterReturning：后置通知（应用：常规数据处理） 方法正常返回后执行，如果方法中抛出异常，通知将无法执行3. around：环绕通知（应用：十分强大，可以做任何事） 方法执行前后分别执行，可阻止方法执行4.afterThrowing：抛出异常通知（应用：包装异常信息） 方法抛出异常后执行，如果方法没有抛出异常，无法执行5.after：最终通知（应用：清理现场） 方法执行完毕后执行，无论方法中是否出现异常都会执行（类似于finally代码块） 基于XML配置AOP在上一篇笔记Spring AOP两种配置方式(半自动vs全自动)中讲了如何使用xml的方式配置和使用Spring的AOP，这里我们再回顾一下： 首先编写一个service接口,模拟要处理的业务 123456789101112131415161718192021package com.xzy.service;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public int deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 实现service接口： 12345678910111213141516171819package com.xzy.service;public class UserSeviceImpl implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println(\"增加了1个用户\"); &#125; @Override public int deleteUser(int id) &#123; System.out.println(\"删除了id为\"+id+\"的用户\"); return id; &#125; @Override public void updateUser(int id) &#123; System.out.println(\"id为\"+id+\"的用户更新了\"); &#125;&#125; 编写切面类：写一个方法before()，他是在目标方法执行需要增强的功能 1234567891011121314package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;public class MyAspect2 &#123; /* *前置通知 *JoinPoint：连接点 */ public void before(JoinPoint jp)&#123; System.out.println(\"前置通知........\"+jp.getSignature().getName()); //得到方法的名字 &#125;&#125; applicationContext2.xml中的配置如下： 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--配置bean--&gt; &lt;bean id=\"userService\" class=\"com.xzy.service.UserSeviceImpl\"&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=\"aspect\" class=\"com.xzy.Aspect.MyAspect2\"&gt;&lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref=\"aspect\"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id=\"poincut1\" expression=\"execution(* com.xzy.service.*.*(..))\"/&gt; &lt;!--前置通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"poincut1\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试： 12345678910111213141516171819package com.xzy;import com.xzy.service.UserSeviceBase;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AppTest &#123; @Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"ApplicationContext2.xml\"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean(\"userService\"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125;&#125; 测试结果：如下图所示，前置通知确实起作用了，在目标方法执行之前就执行了 下面我们在来测测&lt;aop:advisor&gt;中的其他通知方式 &lt;aop:after-returning&gt;&nbsp;&nbsp;&nbsp;&nbsp;在切面类中增加方法：afterReturning(JoinPoint jp,Object obj),其中第一个参数是连接点，第二个参数是目标方法运行后的返回值。要获得返回返回值需要在配置中设置returning=”obj”，就是把这个第二个参数的名字放进去，Spring就会把返回值注入。 1234567891011121314151617181920212223package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;public class MyAspect2 &#123; /* *方法执行前的通知 */ public void before(JoinPoint jp)&#123; System.out.println(\"前置通知........\"+jp.getSignature().getName()); //得到方法的名字 &#125; /* *方法返回后的通知 */ public void afterReturning(JoinPoint jp,Object obj)&#123; System.out.println(\"后置通知........\"+jp.getSignature().getName()); //得到方法的名字 System.out.println(\"方法的返回值是：\"+obj); System.out.println(\"----------------------------------\"); &#125;&#125; 配置新增的切面类方法： 1234567891011121314151617181920&lt;!--配置bean--&gt; &lt;bean id=\"userService\" class=\"com.xzy.service.UserSeviceImpl\"&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id=\"aspect\" class=\"com.xzy.Aspect.MyAspect2\"&gt;&lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref=\"aspect\"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id=\"poincut1\" expression=\"execution(* com.xzy.service.UserServiceImpl.*(..))\"/&gt; &lt;!--前置通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"poincut1\"/&gt; &lt;!--后置通知--&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"poincut1\" returning=\"obj\"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试代码不变，测试结果如下： &lt;aop: around&gt;around具有before和after-returning两者的功能，这里就不在重复测试了。所以一般使用了around就不在使用brfore和after-returning &lt;aop: after-throwing&gt;、&lt;aop: after&gt;切面类中增加方法afterThrowing和after 1234567891011121314/** * 抛出异常后通知 * @param jp 连接点 * @param e 异常 */public void afterThrowing(JoinPoint jp,Throwable e)&#123; System.out.println(\"抛出异常通知.....\"+jp.getSignature().getName()+e.getMessage());&#125;public void after(JoinPoint jp)&#123; System.out.println(\"最终通知......\"+jp.getSignature().getName());&#125; 配置xml 12345678910111213141516&lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref=\"aspect\"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id=\"poincut1\" expression=\"execution(* com.xzy.service.UserSeviceImpl.*(..))\"/&gt; &lt;!--环绕通知--&gt; &lt;aop:around method=\"around\" pointcut-ref=\"poincut1\"&gt;&lt;/aop:around&gt; &lt;!--异常通知:当目标方法发生异常后会执行 --&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"poincut1\" throwing=\"e\"/&gt; &lt;!--最终通知:无论方法有没有发生异常，都会执行--&gt; &lt;aop:after method=\"after\" pointcut-ref=\"poincut1\"/&gt; &lt;/aop:config&gt; 并在deleteUser方法中主动抛出异常： 12345@Overridepublic int deleteUser(int id) &#123; System.out.println(\"删除了id为\" + id + \"的用户\"); throw new RuntimeException(new Exception(\"自定义异常....\"));&#125; 测试结果如下： 如果去掉异常的测试结果如下： 基于Annotation配置AOP既然使用注解配置，那就全部用注解，包括配置文件都用注解+Java类来实现 编写配置类ApplicationConfig.java替代xml文件12345678910111213package com.xzy;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration //告诉spring这是配置文件@EnableAspectJAutoProxy //开启aop自动代理@ComponentScan(basePackages = &#123;\"com.xzy\"&#125;) //告诉spring去哪里扫描注解public class AppConfig &#123; //这里头以后可以写各种配置，这个类的作用就和XML文件的作用一样&#125; 当然这段java代码可以用下面这段XML配置文件替代 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--开启注解功能--&gt; &lt;context:annotation-config/&gt; &lt;!--告诉Spring去哪里扫描注解--&gt; &lt;context:component-scan base-package=\"com.xzy\"/&gt; &lt;!--配置aop自动代理--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 编写一个日志记录的切面类LoggerApsect.java在切面类中可以使用如下几个注解来定制一个切面： @Aspect：告诉Spring这是切面类 @Brfore：前置通知 @AfterRuning：返回后通知 @Around：环绕通知，是@Brfore和@AfterRuning的结合，功能十分强大 @After-Throwing：抛出异常后的通知，没有异常不会执行 @After：最终通知，无论有没有异常一定会执行的 @PointCut：定义切点 具体用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Date;/** * 一个记录各种操作的日志切面类 */@Component //告诉Spring你要把这个类给我实例化了@Aspect //告诉Spring这是一个切面类public class LoggerAspect &#123; //声明一个公共的切点：将com.xzy.service包下的所有以Impl结尾的方法作为切入点，切入点中可以没有任何代码实现，只是让他在形式上存在即可 @Pointcut(\"execution(* com.xzy.service.*Impl.*(..))\") public void pointcut() &#123; &#125; @Before(\"execution(* com.xzy.service.*Impl.*(..))\") public void before(JoinPoint joinPoint) &#123; System.out.println(\"before给\" + joinPoint.getSignature().getName() + \"方法作前日志..........\" + new Date()); &#125; @AfterReturning(pointcut = \"pointcut()\", returning = \"retValue\") public void afterReturning(JoinPoint joinPoint, Object retValue) &#123; System.out.println(\"afterReturning给\" + joinPoint.getSignature().getName() + \"方法作后日志..........\" + new Date()); System.out.println(\"方法的返回值是：\" + retValue); &#125; @Around(\"pointcut()\") public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(\"around给\" + joinPoint.getSignature().getName() + \"方法作前日志..........\" + new Date()); Object retValue = joinPoint.proceed(); System.out.println(\"around给\" + joinPoint.getSignature().getName() + \"方法作前后志..........\" + new Date()); return retValue; &#125; @AfterThrowing(pointcut = \"pointcut()\", throwing = \"e\") public void afterThrowing(JoinPoint joinPoint, Throwable e) &#123; System.out.println(\"给\" + joinPoint.getSignature().getName() + \"方法作异常日志：\" + new Date() + \"抛出\" + e.getMessage()); &#125; @After(\"pointcut()\") public void afterAll(JoinPoint joinPoint) &#123; System.out.println(\"给\" + joinPoint.getSignature().getName() + \"方法作最终日志..........\" + new Date()); &#125;&#125; 测试类如下： 1234567891011121314151617181920212223242526package com.xzy;import com.xzy.service.UserSeviceBase;import org.apache.log4j.Logger;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= &#123;AppConfig.class&#125;)public class AppTest &#123; private static Logger log= Logger.getLogger(AppTest.class); @Autowired UserSeviceBase userSevice; @Test public void test3()&#123; userSevice.deleteUser(12); userSevice.updateUser(34); &#125;&#125; 测试结果: 现在去掉before、after-return以及在deleteUser中抛出一个异常：","tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://easyblog.top/tags/Spring-AOP/"}]},{"title":"Spring AOP两种配置方式(半自动vs全自动)","date":"2019-08-03T14:21:56.000Z","path":"2019/08/03/SpringAOP半自动和全自动配置方式/","text":"Spring AOP半自动编程 核心步骤：1. 创建一个接口以及它的实现类2. 编写切面类，实现MethodInterceptor接口的invoke方法3. 配置Spring的配置文件，xml文件中的配置重要是：【重要】 &nbsp;&nbsp; 1).配置目标类的bean &nbsp;&nbsp;&nbsp;2).配置切面类的bean &nbsp;&nbsp;&nbsp;3).配置代理对象，其中代理对象中主要的配置如下’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.配置接口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.配置目标类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.配置切面类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.还可以用&lt;property name=&quot;optimize&quot; value=&quot;true&quot;/&gt;,指明使用cglib的代理对象 1.首先编写一个接口 123456789101112131415161718192021package com.xzy.service;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public void deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 接口的实现类： 123456789101112131415161718package com.xzy.service;public class UserSeviceImpl implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println(\"增加了1个用户\"); &#125; @Override public void deleteUser(int id) &#123; System.out.println(\"删除了id为\"+id+\"的用户\"); &#125; @Override public void updateUser(int id) &#123; System.out.println(\"id为\"+id+\"的用户更新了\"); &#125;&#125; 编写一个切面类：让这个切面类实现MethodInvocation接口的invoke方法 1234567891011121314151617181920package com.xzy.Aspect;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import java.util.Date;//切面类public class MyAspect implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println(\"执行操作前日志......\" + new Date()); Object obj = methodInvocation.proceed(); System.out.println(\"执行操作后日志......\" + new Date()); return obj; &#125;&#125; 在Spring的配置文件Application.xml中注册代理对象 123456789101112131415&lt;!--注册目标对象UserService--&gt;&lt;bean id=\"userService\" class=\"com.xzy.service.UserSeviceImpl\"&gt;&lt;/bean&gt;&lt;!--注册切面类--&gt;&lt;bean id=\"myAspect\" class=\"com.xzy.Aspect.MyAspect\"&gt;&lt;/bean&gt;&lt;!--注册代理对象--&gt;&lt;bean id=\"proxyService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt; &lt;!--接口--&gt; &lt;property name=\"interfaces\" value=\"com.xzy.service.UserSeviceBase\"/&gt; &lt;!--目标对象--&gt; &lt;property name=\"target\" value=\"#&#123;userService&#125;\"/&gt; &lt;!--切面类--&gt; &lt;property name=\"interceptorNames\" value=\"myAspect\"/&gt; &lt;!--配置使用cglib,当没有配置的时候默认是false,也就是使用JDk的Proxy--&gt; &lt;property name=\"optimize\" value=\"true\"/&gt;&lt;/bean&gt; 测试： 123456789101112131415161718192021222324package com.xzy;import com.xzy.service.UserSeviceBase;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Unit test for simple App. */public class AppTest &#123; @Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"ApplicationContext.xml\"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean(\"proxyService\"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125;&#125; 测试结果： Spring AOP 全自动编程 主要步骤：1）.实现切面类2）.在bean配置文件中吧切点和切面关联起来 实现一个切面类,继承MethodInterceptor接口实现它的invoke方法 123456789101112131415161718192021package com.xzy.Aspect;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import java.util.Date;//切面类public class MyAspect implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println(\"执行操作前日志......\" + new Date()); Object obj = methodInvocation.proceed(); System.out.println(\"执行操作后日志......\" + new Date()); return obj; &#125;&#125; 接着在Spring配置文件Application.xml中配置aop的schema文件，如下红框的配置： 接着在配置文件中添加如下内容： 123456789101112131415&lt;!--配置UserService--&gt;&lt;bean id=\"userService\" class=\"com.xzy.service.UserSeviceImpl\"&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=\"myAspect\" class=\"com.xzy.Aspect.MyAspect\"&gt;&lt;/bean&gt;&lt;!--配置全自动AOP代理--&gt;&lt;aop:config &gt; &lt;!--配置切点expression：表达式，就是用来切入的业务类--&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* com.xzy.service.*.*(..))\"/&gt; &lt;!--配合通知 通知要关联切点和切面类 advice-ref:切面类 pointcut-ref:切点 --&gt; &lt;aop:advisor advice-ref=\"myAspect\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 对于配置全自动AOP代理的一点说明，如下图所示&lt;aop:config&gt;标签中重要的三种元素：切点：&lt;aop:pointcut&gt;、切面：&lt;aop:aspect&gt;、通知：&lt;aop:advisor&gt; 其中通知：``又有一下5种： 测试： 1234567891011@Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(\"ApplicationContext.xml\"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean(\"userService\"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125; 测试结果： 写在最后：&nbsp;&nbsp;&nbsp;&nbsp;通过实际的操作可以明显感受到第二种方式实现AOP是省事儿又简单的一种方式，然而第二种方式也是Spring中使用到AOP是常用到的一种配置方式。既然有全自动xml的配置方式，那么一定就会有对应对一套使用注解配置对方式。下一节就讲讲如何用注解配置使用Spring AOP。","tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://easyblog.top/tags/Spring-AOP/"}]},{"title":"Spring AOP原理与手撕AOP[重要]","date":"2019-08-03T12:57:26.000Z","path":"2019/08/03/SpringAOP原理/","text":"AOP概述（Spring AOP是什么?AOP有什么用？） 1） 在软件行业，AOP为Aspect Oriented programming 的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的同一维护的一种技术。2） AOP是OOP（面向对象编程）的延续，是软件开发的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生。3）利用AOP可以对业务逻辑的各个部分进行分离，从而使得业务逻辑各个部分之间的耦合度降低，Tiga程序的可重用性，同时提高了开发效率。4）AOP采用横向抽取机制，取代了传统继承体系的纵向机制。5）AOP的经典应用场景：事务管理、性能监视、安全、缓存、日志…..6）Spring AOP 使用纯Java代码实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码。7）AspectJ是一个基于Java的AOP框架，Spring2.0开始，Spring AOP引入AspectJ的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入。 AOP的一些术语【了解】&nbsp;&nbsp;&nbsp;&nbsp;AOP(Aspect Oriented Programming)像大多数技术一样形成了自己的术语，而且这些术语比较难理解，不论是理解还中不理解都对编程影响不太大。1）连接点（Joinpoint）&nbsp;&nbsp;&nbsp;&nbsp;程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring 仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。2）切点（Pointcut）&nbsp;&nbsp;&nbsp;&nbsp;每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP 通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。3）通知或增强（Advice）&nbsp;&nbsp;&nbsp;&nbsp;增强是织入到目标类连接点上的一段程序代码，在 Spring 中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。4）目标对象（Target）&nbsp;&nbsp;&nbsp;&nbsp;增强逻辑的织入目标类。如果没有 AOP，目标业务类需要自己实现所有逻辑，而在 AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用 AOP 动态织入到特定的连接点上。5）引介（Introduction）&nbsp;&nbsp;&nbsp;&nbsp;引介是一种特殊的增强，它为类添加一些属性和方法。这样 ，即使一个业务类原本没有实现某个接口，通过 AOP 的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。6）织入（Weaving）&nbsp;&nbsp;&nbsp;&nbsp;织入是将增强添加对目标类具体连接点上的过程。AOP 像一台织布机，将目标类、增强或引介通过 AOP 这台织布机天衣无缝地编织到一起。根据不同的实现技术，AOP 有三种织入的方式： a、编译期织入，这要求使用特殊的 Java 编译器。b、类装载期织入，这要求使用特殊的类装载器。c、动态代理织入，在运行期为目标类添加增强生成子类的方式。Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 7）代理（Proxy）&nbsp;&nbsp;&nbsp;&nbsp;一个类被 AOP 织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。8）切面（Aspect）&nbsp;&nbsp;&nbsp;&nbsp;切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 对于 Spring 中的 AOP 术语，确实不好理解，为了帮助大家理解这些术语，我们想象一 下这样的场景： 1、有 2 条高速公路可以通向北京，分别为 A,B（相当于 2 个目标个业务 Target（功能） 2、每条高速公路上有 3 个服务站（相当于每个业务上的连接点（Joinpoint）有 3 个） 3、在每条高速公路的第 2 个服务站需要测速（相当于一个切点（Pointcut），匹配了 3 个连接点） 4、在第一条(A)进入服务站之前进行测速，在第二条(b)进入服务站之后测速（通知或增强 Advice，其实也定义了调用测速功能进行测速，以及怎么测） 5、每条高速路第 2 个服务站加入测速功能，这件事情相当于切面 Aspect，它包含了测速功能的定义与切点的定义 6、将测速功能应用到服务站上，这个过程叫织入（Weaving） AOP的实现原理接下来是重点，我们来学习一下AOP的实现原理，并利用原理自己手动实现AOP。AOP底层采用代理机制进行实现，具体的实现方法有以下两种: 1）接口+实现类：采用jdk的动态代理 2）使用实现类：Spring采用了cglib字节码增强 接下来我们就用这两个原理分别自己手动实现AOP。 使用jdk的动态代理实现实现思路：使用jdk中的Proxy类的newProxyInstance方法来获得一个代理对象，在使用的时候就使用这个代理对象而不直接去new对象，关于方法的细节如下： 1234public static Object newProxyInstance( ClassLoader loader, 类加载器，写当前类的类加载器 Class&lt;?&gt;[] interfaces, 接口，就是你要增强的业务类的接口 InvocationHandler h)&#123;&#125; 处理器，可以自己实现InvocationHandler接口的invkoe方法实现一个处理器 步骤：1.写一个普通的接口以及这个接口的实现类2.写一个切面类（就是一个普通的java类，里面的方法写要增强的功能）3.上面的操作完成后，在工厂类（为了方便，当然也可以不写这个工厂类）中首先创建一个目标类对象（就是new一个业务类的对象），接着new一个切面类对象，使用动态代理把切面类中的增强功能织入到目标方法的前后，下面是示例代码：一个业务类接口：UserServiceBase.java 123456789101112131415161718192021package com.xzy.sevice;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public void deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 业务类接口实现类：UserSeviceImpi.java 123456789101112131415161718package com.xzy.sevice;public class UserSeviceImpi implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println(\"增加了1个用户\"); &#125; @Override public void deleteUser(int id) &#123; System.out.println(\"删除了id为\"+id+\"的用户\"); &#125; @Override public void updateUser(int id) &#123; System.out.println(\"id为\"+id+\"的用户更新了\"); &#125;&#125; 写一个切面类：MyAspect.java 1234567891011121314151617package com.xzy.aspect;import java.util.Date;//切面类:就是一段增强功能的代码public class MyAspect &#123; public void before()&#123; System.out.println(\".......执行操作前日志.......\"+new Date()); &#125; public void after()&#123; System.out.println(\".......执行操作后日志.......\"+new Date()); &#125;&#125; 写一个工厂类，专门用于生产代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.xzy.sevice;import com.xzy.aspect.MyAspect;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ServiceFactory &#123; /** * 产生一个 UserSevice * * @return */ public static UserSeviceBase createUserService() &#123; //1.创建目标对象 final UserSeviceBase userSevice = new UserSeviceImpl(); //2.声明切面类 final MyAspect aspect = new MyAspect(); //3.使用动态代理来把切面类中的增强方法切入目标方法前后 UserSeviceBase proxyService = (UserSeviceBase) Proxy.newProxyInstance( ServiceFactory.class.getClassLoader(), userSevice.getClass().getInterfaces(), //InvocationHandler是一个接口，它里面只有一个invoke方法，这里也可以在外面单独写一个类实现InvocationHandler接口，然后在这里new这个类的对象也可以 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //目标方法开始前的增强代码 aspect.before(); //通过反射调用目标方法 Object obj = method.invoke(userSevice, args); //目标方法执行后的增强代码 aspect.after(); return obj; &#125; &#125; ); return proxyService; //返回代理对象 &#125;&#125; 测试： 1234567891011121314151617181920212223package com.xzy;import com.xzy.sevice.ServiceFactory;import com.xzy.sevice.UserSeviceBase;import org.junit.Test;/** * Unit test for simple App. */public class AppTest &#123; /** * 使用Java的动态代理机制，手动实现AOP编程 */ @Test public void test1()&#123; //直接从工厂中拿代理对象 UserSeviceBase userSevice= ServiceFactory.createUserService(); userSevice.deleteUser(10); userSevice.updateUser(3); userSevice.addUser(); &#125;&#125; 测试结果： 使用Cglib实现&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，可能需要对没有实现接口的类增强，用JDK动态代理的方式就没法实现。采用Cglib动态代理可以对没有实现接口的类产生代理，实际上是生成了目标类的子类来增强。 首先，需要导入Cglib所需的jar包，Maven依赖写法如下： 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 还是需要一个业务类（这次不需要接口了）以及一个切面类，前面写过，这里就跳过了。接着在刚才的工厂类中再写一个方法createUserService2()，步骤还是那几步，只不过这次是用cglib提供的api来写，具体如下： 123456789101112131415161718192021222324252627282930/* *使用cglib实现AOP * */ public static UserSeviceBase createUserService2() &#123; //1.创建目标对象 final UserSeviceImpl userSevice = new UserSeviceImpl(); //2.声明切面类 final MyAspect aspect = new MyAspect(); //3.cglib核心类Enhancer Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(userSevice.getClass()); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; aspect.before(); /* *proxy代理是目标类的子类 */ Object obj = methodProxy.invoke(userSevice, args); aspect.after(); return obj; &#125; &#125;); UserSeviceImpl proxy = (UserSeviceImpl) enhancer.create(); return proxy; //返回代理对象 &#125; 测试： 1234567891011121314151617181920212223package com.xzy;import com.xzy.sevice.ServiceFactory;import com.xzy.sevice.UserSeviceBase;import org.junit.Test;/** * Unit test for simple App. */public class AppTest &#123; /** * 使用cglib手动实现AOP编程 */ @Test public void test2()&#123; UserSeviceBase userSevice= ServiceFactory.createUserService2(); userSevice.deleteUser(10); userSevice.updateUser(3); userSevice.addUser(); &#125;&#125; 测试结果： 可以看到结果和刚才用JDK动态代理的结果一样，但是这里要特别注意： jdk代理只能动态代理接口+实现类的形式； Cglib代理的优势是可以直接代理普通的类，但同时接口也可以","tags":[{"name":"Spring AOP","slug":"Spring-AOP","permalink":"http://easyblog.top/tags/Spring-AOP/"}]},{"title":"Spring IOC高级依赖注入","date":"2019-08-02T08:35:05.000Z","path":"2019/08/02/SpringIOC高级依赖注入/","text":"环境与 Profile&nbsp;&nbsp;&nbsp;&nbsp;在开发中我们测试用一套数据库，开发用一套数据库，而且要将应用程序从一个环境迁移到 另一个环境，Spring 允许我们定义多套配置，可以配置声明应用哪套配置的 Bean 1 Profile Spring中的Profile是什么？ &nbsp;&nbsp;&nbsp;&nbsp;Spring中的Profile功能其实早在Spring 3.1的版本就已经出来，它可以理解为我们在Spring容器中所定义的Bean的逻辑组名称，只有当这些Profile被激活的时候，才会将Profile中所对应的Bean注册到Spring容器中。举个更具体的例子，我们以前所定义的Bean，当Spring容器一启动的时候，就会一股脑的全部加载这些信息完成对Bean的创建；而使用了Profile之后，它会将Bean的定义进行更细粒度的划分，将这些定义的Bean划分为几个不同的组，当Spring容器加载配置信息的时候，首先查找激活的Profile，然后只会去加载被激活的组中所定义的Bean信息，而不被激活的Profile中所定义的Bean定义信息是不会加载用于创建Bean的。 Profile有什么用？ &nbsp;&nbsp;&nbsp;&nbsp;由于我们平时在开发中，通常会出现在开发的时候使用一个开发数据库，测试的时候使用一个测试的数据库，而实际部署的时候需要一个数据库。以前的做法是将这些信息写在一个配置文件中，当我把代码部署到测试的环境中，将配置文件改成测试环境；当测试完成，项目需要部署到现网了，又要将配置信息改成现网的，真的好烦。。。而使用了Profile之后，我们就可以分别定义3个配置文件，一个用于开发、一个用户测试、一个用户生产，其分别对应于3个Profile。当在实际运行的时候，只需给定一个参数来激活对应的Profile即可，那么容器就会只加载激活后的配置文件，这样就可以大大省去我们修改配置信息而带来的烦恼。 方式一：用xml配置profile 123456789101112131415161718192021222324252627Application.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;beans profile=\"dev\"&gt; &lt;jdbc:embedded-database id=\"dataSource\" type=\"H2\"&gt; &lt;jdbc:script location=\"classpath:schema.sql\" /&gt; &lt;jdbc:script location=\"classpath:dev-data.sql\" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=\"prod\"&gt; &lt;jdbc:embedded-database id=\"dataSource\" type=\"H2\"&gt; &lt;jdbc:script location=\"classpath:schema.sql\" /&gt; &lt;jdbc:script location=\"classpath:prod-data.sql\" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt;&lt;/beans&gt; 方式二：用Annotation配置profile，这种方式配置和用xml配置是等价的 12345678910111213141516171819202122232425@Configurationpublic class DataSourceConfig &#123; //Spring 引入@Profile 制定某个bean属于哪个profile //在方法级别上使用@Profile注解 @Bean @Profile(\"dev\") public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript(\"classpath:schema.sql\") .addScript(\"classpath:dev-data.sql\") .build(); &#125; @Bean @Profile(\"prod\") public DataSource embeddedDataSourceDev() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript(\"classpath:schema.sql\") .addScript(\"classpath:prod-data.sql\") .build(); &#125;&#125; 在同一个类的不同方法上使用@Profile注解与@Bean一起使用激活profileSpring在确定哪个profile处于激活状态时，需要依赖两个独立属性：sping.profiles.active和spring.profiles.default。Spring提供了@ActiveProfiles用来指定运行测试时要激活哪个profile,如果没有指定sping.profiles.active，会采用spring.profiles.default的默认值。 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xzy;import static org.junit.Assert.*;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.myapp.DataSourceConfig;public class DataSourceConfigTest &#123; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=DataSourceConfig.class) @ActiveProfiles(\"dev\") public static class DevDataSourceTest &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query(\"select id, name from Things\", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong(\"id\") + \":\" + rs.getString(\"name\"); &#125; &#125;); assertEquals(1, results.size()); assertEquals(\"1:A\", results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(\"classpath:datasource-config.xml\") @ActiveProfiles(\"prod\") public static class ProductionDataSourceTest_XMLConfig &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query(\"select id, name from Things\", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong(\"id\") + \":\" + rs.getString(\"name\"); &#125; &#125;); assertEquals(1, results.size()); assertEquals(\"1:B\", results.get(0)); &#125; &#125;&#125; 条件化Bean&nbsp;&nbsp;&nbsp;&nbsp;Spring 4 引入了一个新的@Conditional 注解，它可以用到带@Bean 注解的方法上，如果条件计算结果为 true，就会创建个 Bean设置给@Conditional 的类可以是任意实现了 Condition 接口的类型,如果matches()方法返回true，那么就会创建带有@Conditional注解的bean。若返回false，将不会创建这些bean。其中: ConditionContext ： getRegistry()：返回的 BeanDefinitionRegistry 检查 Bean 定义： getBeanFactory()：返回 ConfigurableListableBeanFactory 检查 Bean 是否存在 getEnvironments()：返回 Environment 检查环境变量是否存在以及它的值是什么 getResourceLoader()：返回 ResourceLoader 所加载的瓷源 getClassLoader()：返回 ClassLoder 加载并检查是否存在 AnnotatedTypeMetadata ：可以让我们检查带@Bean 注解的方法上还有什么其它注解，它也是一个接口 举个栗子：写个条件类，实现Condition接口的matches方法，简单的判断一下当前的系统是不是Windows 7的，如果是返回true,否则返回false 12345678910111213141516171819package com.xzy.utils;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class StudentCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env = context.getEnvironment(); System.out.println(env.toString()); if(\"Windows 7\".equals(env.getProperty(\"os.name\")))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 测试代码： 123456789101112131415161718192021package com.xzy.utils;import com.xzy.bean.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;@Configurationpublic class ConditionTest &#123; //只用这个条件为true才能产生Student,否则spring压根就不会理他 @Bean @Conditional(StudentCondition.class) public Student appConfig()&#123; Student student=new Student(); student.setName(\"晓明\"); student.setAge(34); return student; &#125;&#125; 测试代码： 程序运行结果： 如果把“Windows 7”改成“Windows 10”就是条件Bean就会返回false,由于无法正常的注入就会出现以下的异常： 1org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.xzy.AppTest': Unsatisfied dependency expressed through field 'student'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.xzy.bean.Student' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=appConfig)&#125;","tags":[{"name":"Spring IOC","slug":"Spring-IOC","permalink":"http://easyblog.top/tags/Spring-IOC/"}]},{"title":"Spring IOC Container","date":"2019-08-02T06:16:15.000Z","path":"2019/08/02/SpringIOC/","text":"什么是Spring IOC 和DI 控制反转（Inversion of Control，IoC） 所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 依赖注入（Dependency Injection，DI） 在运行期，由外部容器动态地将依赖对象注入到组件中。换句话说，就是在运行时能 Bean对象设置属性值 bean标签 一个bean标签代表一个spring容器中的java对象，可以在bean中经常使用的属性如下:1. id 属性 ：起名称 不能包含特殊符号 根据id 获得配置对象 2. class属性：创建对象所在全路径 3. name属性：功能和id一样 ，id不能包含特殊符号，name可以（基本不用，为了满足struts1遗留问题） 4. scope属性：Bean的作用范围，scope常用的值有：-singleton 和 -prototype，分别表示单例和多例,如果没写默认就是单例 Bean的3种实例化方式 1.直接使用bean标签来实例化pojo，这中方法Spring默认调用的是这个pojo的无参构造器来实例化bean对象的 首先创建一个EmailDaoImpl.java 12345678910package com.xzy.dao.Impl;import com.xzy.dao.EmailDao;public class EmailDaoImpl implements EmailDao &#123; @Override public void sent() &#123; System.out.println(\"发送email&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); &#125;&#125; 在ApplicationContext.xml文件中使用&lt;bean id=“” class=”” /&amp;gt标签配置bean: 12 &lt;!--1.直接使用bean class来实例化--&gt;&lt;bean id=\"email\" class=\"com.xzy.dao.Impl.EmailDaoImpl\"/&gt; 经过这两步就配置好了一个bean,测试代码简单，就是调用了一下sent方法，下面是执行的结果： 2.使用静态工厂实例化pojo 首先新建一个静态工厂DaoFactory.java 12345678910111213package com.xzy.dao;import com.xzy.dao.Impl.EmailDaoImpl;public class DaoStaticFactory &#123; /** * 静态工厂实例化bean * @return */ public static EmailDao createInstance()&#123; return new EmailDaoImpl(); &#125;&#125; 接着在xml中配置如下： 1&lt;bean id=\"email1\" class=\"com.xzy.dao.DaoStaticFactory\" factory-method=\"createInstance\"/&gt; 执行结果和上面的的一样，这里不再展示了。 3.使用实例化工厂实例化pojo 首先新建一个实例化工厂： 123456789101112package com.xzy.dao;import com.xzy.dao.Impl.EmailDaoImpl;/** * 实例工厂实例化bean */public class DaoInstanceFactory &#123; public EmailDao createInstance()&#123; return new EmailDaoImpl(); &#125;&#125; 在xml文件中配置如下： 123&lt;!--3.通过实例工厂实例化bean--&gt;&lt;bean id=\"factory\" class=\"com.xzy.dao.DaoInstanceFactory\"/&gt;&lt;bean id=\"email2\" factory-bean=\"factory\" factory-method=\"createInstance\"/&gt; 依赖注入的2种常用方式 1. 构造方法注入2. setter方法注入 首先，新建学生实体类Student: 123456789101112131415161718192021222324252627package com.xzy.bean;import org.springframework.stereotype.Component;import java.util.Properties;public class Student &#123; private int age; private String name; private Teacher tea; private Properties info=null; public Student()&#123; System.out.println(\"默认调用无参构造方法实例化bean\"); &#125; public Student(int age, String name) &#123; this.age = age; this.name = name; &#125; public Student(String name, Teacher tea) &#123; this.name = name; this.tea = tea; &#125; //省略getter,setter...... 1. 使用构造方法注入在xml中配置如下，正常情况下只用指定参数的名字和参数的值：&lt;constructor-arg name=”” value=”” /&gt;,name就是构造方法中的参数名，value即使这个参数的值 12345 &lt;!--1.构造方法注入--&gt;&lt;bean id=\"student\" class=\"com.xzy.bean.Student\"&gt; &lt;constructor-arg name=\"age\" value=\"20\" /&gt; &lt;constructor-arg name=\"name\" value=\"小明\" /&gt;&lt;/bean&gt; 程寻运行的结果： 当构造方法出现命名冲突的时候，可以使用type属性指定参数对java类型： 12345 &lt;!--当构造方法中出现命名冲突的时候，还可以使用type属性指定参数的类型--&gt;&lt;bean id=\"student\" class=\"com.xzy.bean.Student\"&gt; &lt;constructor-arg value=\"20\" type=\"int\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"小红\" type=\"java.lang.String\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 程寻运行的结果： 2. settrt方法注入,这种方法和实例化bean相同，都是用了property属性 1234567891011&lt;bean id=\"student\" class=\"com.xzy.bean.Student\"&gt; &lt;property name=\"age\" value=\"#&#123;25*7-20*7&#125;\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"#&#123;'aaaaaaa'.toUpperCase()&#125;\"&gt;&lt;/property&gt; &lt;property name=\"tea\" value=\"#&#123;teacher&#125;\"&gt;&lt;/property&gt; &lt;property name=\"info\"&gt; &lt;value&gt; jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 程寻运行的结果： SpEL（Spring表达式）&nbsp;&nbsp;&nbsp;&nbsp;SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言。为什么要总结SpEL，因为它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构。个人认为很有用。&nbsp;&nbsp;&nbsp;&nbsp;SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。下面说一下它最基础最重要的一种用法：xml配置法。（使用注解的方式的语法和xml方式的语法一样的，只是使用注解会更方便）SpEL的基本语法有以下几条 语法格式`` #{123}、#{'字符串'} ：数字、字符串 #{beanId}：对另一个bean的引用，类似ref属性 #{beanId.propName}:：操作数据 #{beanId.toString()}：执行方法 #{T(类).字段|方法}：静态方法或字段 Spring表达式支持大多数的数学操作符、逻辑操作符、关系操作符。1.关系操作符包括：等于 (==, eq)，不等于 (!=, ne)，小于 (&lt;, lt),，小于等于(&lt;= ,le)，大于(&gt;, gt)，大于等于 (&gt;=, ge)2.逻辑操作符包括：and，or，and not(!)3.数学操作符包括：加 (+)，减 (-)，乘 (*)，除 (/)，取模 (%)，幂指数 (^)。 新建一个实体Customer 12345678910111213141516171819202122package com.xzy.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Customer &#123; private String name; private String sex=\"男\"; private double pi;@Override public String toString() &#123; return \"Customer&#123;\" + \"name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", pi=\" + pi '&#125;'; &#125; 在配置文件中如下配置： 1234567&lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;!--操作字段：#&#123;ref.Field&#125;--&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;!--静态字段：#&#123;T.(TYPE).staticField&#125;--&gt; &lt;property name=\"pi\" value=\"#&#123;T(Math).PI&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt; 程序的执行结果如下： 剩下的各种运算就不在这里试了，有兴趣的话可以自己尝试。 集合类型注入&nbsp;&nbsp;&nbsp;&nbsp;官方的一句话:In the &lt;list/&gt;, &lt;set/&gt;, &lt;map/&gt;, and &lt;props/&gt; elements, you set the properties and arguments of the Java Collection types List, Set, Map, and Properties, respectively.就是说，你可以用&lt;list&gt;、set、map、props来配置对应的Java集合类型：List、Set、Map、以及Array(数组),以及Properties也可以配置。举个栗子： 在上例Customer实体类的基础上修改，分别增加List属性、Set属性、Map属性和数组属性一个，具体代码如下： 1234567891011121314151617181920212223242526272829package com.xzy.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Customer &#123; private String name; private String sex=\"男\"; private List&lt;String&gt; shopCar; //购物车 private Set&lt;String&gt; price; //价格 private Map&lt;String,Double&gt; goods; //物品 private String[] address; //地址 //省略getter、setter.... @Override public String toString() &#123; return \"Customer&#123;\" + \"name='\" + name + '\\'' + \", sex='\" + sex + '\\'' + \", shopCar=\" + shopCar + \", price=\" + price + \", goods=\" + goods + \", address=\" + Arrays.toString(address) + '&#125;'; &#125;&#125; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--List注入使用&lt;list&gt;元素 --&gt; &lt;property name=\"shopCar\"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;set&gt;标签给Set类型注入初始值： 123456789101112131415&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--Set注入使用&lt;set&gt;元素 --&gt; &lt;property name=\"price\"&gt; &lt;set&gt; &lt;value&gt;\"#&#123;3.5*6&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;2000*2&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;100*6&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;5000*1&#125;\"&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;map&gt;标签给Map类型注入初始值： 12345678910111213141516&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--Map输注入 使用&lt;map&gt;元素，特别注意，使用&lt;entry&gt;来指定一条数据的key和value --&gt; &lt;property name=\"goods\"&gt; &lt;map&gt; &lt;entry key=\"p1\" value=\"23\"&gt;&lt;/entry&gt; &lt;entry key=\"p2\" value=\"24\"&gt;&lt;/entry&gt; &lt;entry key=\"p3\" value=\"25\"&gt;&lt;/entry&gt; &lt;entry key=\"p4\" value=\"26\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--List注入使用&lt;list&gt;元素 --&gt; &lt;property name=\"shopCar\"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--数组注入使用&lt;array&gt;元素 --&gt; &lt;property name=\"address\"&gt; &lt;array&gt; &lt;value&gt;西安&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;南京&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 最后，对于customer的DI配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!--bean的集合注入--&gt; &lt;bean id=\"customer\" class=\"com.xzy.bean.Customer\"&gt; &lt;property name=\"name\" value=\"#&#123;student.name&#125;\"&gt;&lt;/property&gt; &lt;property name=\"sex\" value=\"#&#123;'女'&#125;\"&gt;&lt;/property&gt; &lt;!--List注入 使用&lt;list&gt;元素 --&gt; &lt;property name=\"shopCar\"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Set注入 使用&lt;set&gt;元素 --&gt; &lt;property name=\"price\"&gt; &lt;set&gt; &lt;value&gt;\"#&#123;3.5*6&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;2000*2&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;100*6&#125;\"&lt;/value&gt; &lt;value&gt;\"#&#123;5000*1&#125;\"&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Map输注入 使用&lt;map&gt;元素，特别注意，使用&lt;entry&gt;来指定一条数据的key和value --&gt; &lt;property name=\"goods\"&gt; &lt;map&gt; &lt;entry key=\"p1\" value=\"23\"&gt;&lt;/entry&gt; &lt;entry key=\"p2\" value=\"24\"&gt;&lt;/entry&gt; &lt;entry key=\"p3\" value=\"25\"&gt;&lt;/entry&gt; &lt;entry key=\"p4\" value=\"26\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--数组注入 使用&lt;array&gt;元素 --&gt; &lt;property name=\"address\"&gt; &lt;array&gt; &lt;value&gt;西安&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;南京&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 程序执行结果： 使用Annotation自动装配扫描要使用Anntation配置spring容器，首先需要在ApplicationContext.xml文件中配置如下信息： 1234&lt;!--开启注解--&gt;&lt;context:annotation-config/&gt;&lt;!--告诉Spring去扫描哪里--&gt;&lt;context:component-scan base-package=\"com.xzy\"&gt;&lt;/context:component-scan&gt; 设置组件与bean命名 1.@Repository, @Service, and @Controller,@Component 这 四 个 Annotation 功 能 相 同都是声明一个bean组件，不同的是 @Repository 用于持久层，也就是Dao层。 @Service 用于服务层（业务层）。 @controller 用于控制器层。 @Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。例如对pojo实体可以使用他 都是用在类上的 Annotation，说明让Spring 实例化此类的对像，并放入 spring 容器中 2.@componet(“id”)其中 id 声明 bean 对像的名字 举个栗子：新建Student.java 12345678910111213141516171819202122232425package com.xzy.bean;import org.springframework.stereotype.Component;@Component //这一句就是告诉Spring这是个普通的组件public class Student &#123; private int age; private String name; public Student() &#123; System.out.println(\"1.实例化了bean。。。。。\"); &#125; //省略getter、setter @Override public String toString() &#123; return \"Student&#123;\" + \"age=\" + age + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; 测试代码： 12345678910111213141516171819202122232425262728package com.xzy;import com.xzy.bean.Student;import org.apache.log4j.Logger;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * Unit test for simple App. */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value=&#123;\"/ApplicationContext.xml\"&#125;)public class AppTest &#123; private static Logger log=Logger.getLogger(AppTest.class); @Autowired //自动注入，Spring会为我们自动从容器中找到student的对象然后注入这里的变量 private Student student; @Test public void test01()&#123; System.out.println(student); &#125;&#125; 程序运行结果： @Repository, @Service, and @Controller新建StudentDao以及StudentDaoImpl 1234567891011121314StudentDaopackage com.xzy.Dao;import com.xzy.bean.Student;public interface StudentDao &#123; /** * 增加一个学生 * @param stu * @return */ public void addStudent(Student stu);&#125; 写一个StudentDaoImpi，模拟DAO层，并使用@Respositiry告诉Spring这是DAO层的组件 1234567891011121314151617181920212223StudentDaoImplpackage com.xzy.Dao.DaoImpi;import com.xzy.Dao.StudentDao;import com.xzy.bean.Student;import org.springframework.stereotype.Repository;@Repositorypublic class StudentDaoImpi implements StudentDao &#123; public StudentDaoImpl() &#123; System.out.println(\"Repository层实例化\"); &#125; @Override public void addStudent(Student stu) &#123; System.out.print(\"3.Dao层处理数据：\"); System.out.println(\"向数据库发一条insert语句添加一个学生:\"+stu.getName()); &#125;&#125; 新建StudentService.java，模拟Service层，使用@Service注解告诉Spring这是一个Service的组件 1234567891011121314151617181920212223StudentService.javapackage com.xzy.Service;import com.xzy.Dao.StudentDao;import com.xzy.bean.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class StudentService &#123; public StudentService() &#123; System.out.println(\"Service层实例化\"); &#125; @Autowired private StudentDao stuImp; public void add(Student stu)&#123; System.out.println(\"2.service层收到控制层的数据后发给Dao层\"); stuImp.addStudent(stu); &#125;&#125; 新建StudentServlet.java，模拟控制器层，并使用@Controller注解告诉Spring这是控制器。 123456789101112131415161718192021222324252627StudentServlet.javapackage com.xzy.Servlet;import com.xzy.Service.StudentService;import com.xzy.bean.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class StudentServlet &#123; public StudentServlet() &#123; System.out.println(\"Controller层实例化\"); &#125; @Autowired private StudentService stuService; @Autowired private Student stu; public void addAction() &#123; System.out.println(\"1.控制层发数据给sevice层\"); stu.setAge(23); stu.setName(\"狗子\"); stuService.add(stu); &#125;&#125; 最终的执行结果： 注意注入的顺序：把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到controller中 设置组件扫描的base-packages @Configuration@ComponentScan(“基包名”)Public class AppConfig{} @Configuration@ComponentScan(basepackages=“基包名”)Public class AppConfig{} @Configuration@ComponentScan(basepackages={“基包名”,”…”})Public class AppConfig{} @Configuration@ComponentScan(basePackageClasses={App1Config.class,App2Config.class})Public class AppConfig{}以上 App1Config 与 App2Config 所在的包作为组件扫描的基础包 Annotation 自动装配 1.@Autowired 自动装配和 JSR 330’s @Inject 对应，可用在构造方法、属性 setter 方法，有属性@Autowired(required=false)@Primary 用于声明 bean 的首先，用在多个 bean，无法选择装配谁的情况可以指明使用哪个 2.@Required 声明依赖必须提供 用在 setter 方法@Requiredpublic void setMovieFinder(MovieFinder movieFinder) {this.movieFinder = movieFinder;} 3.@Qualifiers 注明要装配 bean 的标识，用于多个 bean 无法确定装配哪个的情况 处理自动装配的歧义Spring提供的自动装配是非常好用，可是用这么个问题：比如，一个接口有三个实现类，当要将接口类型自动装配置时，就出现不唯一的问题，Spring 会抛出 NoUniqueBeanDefinitionException。正如下面这种情况：写一个接口： 123456789package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic interface ReadData &#123; public void read();&#125; 接口的三个实现类： 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class USBRead implements ReadData &#123; @Override public void read() &#123; System.out.println(\"USB读取数据.....\"); &#125;&#125; 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class SSDRead implements ReadData &#123; @Override public void read() &#123; System.out.println(\"SSD读取数据......\"); &#125;&#125; 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class BlueRead implements ReadData &#123; @Override public void read() &#123; System.out.println(\"蓝牙读取数据.......\"); &#125;&#125; 这时如果让Spring给我们自动装配，他都懵逼了，因为这个接口有3个实现类，都可以装配，他不知道装配那个，如下图所示： 此时如果直接运行就会发生如下异常： 122019-08-01 21:49:51 [ERROR]-[org.springframework.test.context.TestContextManager] Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@685cb137] to prepare test instance [com.xzy.AppTest@50a638b5] org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.xzy.AppTest': Unsatisfied dependency expressed through field 'read'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.xzy.utils.ReadData' available: expected single matching bean but found 3: blueRead,SSDRead,USBRead 解决办法解决方法1：在实现类的头上使用@Primary注解告诉Spring首选哪个装配，比如在USBRead类的头上加上@Primary： 解决方法2：使用@Qualifier 注解限定自动装配的 Bean","tags":[{"name":"Spring IOC","slug":"Spring-IOC","permalink":"http://easyblog.top/tags/Spring-IOC/"}]},{"title":"认识Spring框架","date":"2019-08-01T11:24:59.000Z","path":"2019/08/01/认识Spring框架/","text":"Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring?1). Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。2).Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring3).适用范围：任何 Java 应用4).Spring 的根本使命：简化 Java 开发 Spring 中常用术语：框架：是能完成一定功能的半成品。框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 非侵入式设计： 从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 轻量级和重量级： 轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 JavaBean： 即符合 JavaBean 规范的 Java 类 POJO：即 Plain Old Java Objects，简单老式 Java 对象它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 > 注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。 容器： 在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 Spring 的优势低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring能帮我们做什么?①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。③.Spring 能非常简单的帮我们管理数据库事务。④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring的框架体系结构： Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 下面介绍这5个部分的jar以及依赖关系 Core core部分包含4个模块: spring-core：这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心。外部依赖Commons Logging， (Log4J)。 spring-beans：这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。 spring-context：spring的context上下文即IoC容器 spring-expression：一个强大的表达式语言，用于在运行时查询和处理对象图。该语言支持设置和获取属性值；属性赋值，方法调用，访问数组的内容，收集和索引器，逻辑和算术运算，命名变量，并从Spring的IOC容器的名字对象检索，它也支持列表选择和投影以及常见的列表聚合。 它们的依赖关系 Maven依赖写法如下： 12345678910111213141516171819202122232425262728293031&lt;!--Core：spring-core、spring-beans、spring-content、spring-expression--&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; AOP aop部分包含4个模块: spring-aop：这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes) spring-aspects：提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中，比如Eclipse AJDT。 spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 它们的依赖关系 Maven依赖写法如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!--AOP：spring-aop、spring-aspectj、spring-instrument、spring-instrument-tomcat--&gt;&lt;!--spring aop：外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Data Accessdata access部分包含5个模块 spring-jdbc：这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。 spring-tx：为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。 spring-orm：包含Spring对DAO特性集进行了扩展，使其支持iBatis(MyBatis)、JDO、OJB、TopLink， 因为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。 spring-oxm：Spring 对Object/XMl的映射支持,可以让Java与XML之间来回切换。 spring-jms：这个jar包提供了对JMX 1.0/1.2的支持类。java消息服务与Spring-massaging对应。外部依赖spring-beans，spring-aop， JMXAPI。 它们的依赖关系 Maven依赖写法如下： 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Webweb部分包含4个模块 spring-web：这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心基础类，包括自动载入Web ApplicationContext 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。 spring-webmvc：这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。外部依赖spring-web, (spring-support，Tiles，iText，POI)。 spring-webmvc-portlet：基于portlet的mvc实现 spring-websocket：Spring4以后为web应用提供的高效通信工具 spring-messaging：Spring4以后提供用于构建基于消息的应用程序 spring-struts：与struts的集成，不推荐，spring4不再提供 它们的依赖关系 Maven依赖写法如下： 1234567891011&lt;!--Spring Web：spring-web、spring-webmvc、spring-webmvc-portlet--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Testtest部分只有一个模块，我将spring-context-support也放在这吧 spring-test：Spring-test支持spring组建junit或TestNG的集成测试和单元测试。它提供了一致spring ApplicationContext的加载和上下文的缓存。他还提供了可以用来测试代码隔离的模拟对象。 spring-context-support：包含支持缓存Cache（ehcache）、JCA、JMX、 邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。 它们的依赖关系 Maven依赖写法如下： 1234567891011&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"http://easyblog.top/tags/Spring/"}]},{"title":"Mybatis分页插件PageHelper","date":"2019-07-29T15:56:22.000Z","path":"2019/07/29/Mybatis分页插件PageHelper/","text":"PageHelper简介这是一个基于MyBatis开源的分页插件，使用非常方便，支持各种复杂的单表、多表分页查询，让你在写sql时无需考虑分页问题，PageHelper帮你搞定。项目托管在github上https://github.com/pagehelper/Mybatis-PageHelper。 在项目中引入PageHelperPageHelper是一个通用的MyBatis分页插件,在使用的时候除了要导入MyBatis和数据库驱动的jar包外，还要导入PageHelper的jar包。 123456789101112&lt;!--MyBatis通用分页插件pageHelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页插件依赖的包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; 分页插件的配置配置PageHepler拦截器插件对方法有很多种，可以在mybatis-config.xml全局配置文件来配置。也可以在Spring配置文件中配置，配置都很简单，具体如下： 在 MyBatis 配置 xml 中配置拦截器插件123456789101112&lt;!--配置拦截器插件--&gt;&lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt; &lt;property name=\"dialect\" value=\"com.github.pagehelper.PageHelper\"/&gt; &lt;property name=\"offsetAsPageNum\" value=\"false\"/&gt; &lt;property name=\"rowBoundsWithCount\" value=\"false\"/&gt; &lt;property name=\"pageSizeZero\" value=\"false\"/&gt; &lt;property name=\"reasonable\" value=\"false\"/&gt; &lt;property name=\"supportMethodsArguments\" value=\"false\"/&gt; &lt;property name=\"returnPageInfo\" value=\"none\"/&gt; &lt;/plugin&gt;&lt;/pligins&gt; 在 Spring 配置文件中配置拦截器插件1234567891011121314151617&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"plugins\"&gt; &lt;array&gt; &lt;bean class=\"com.github.pagehelper.PageInterceptior\"&gt; &lt;property name=\"properties\"&gt; &lt;value&gt; &lt;!--一行一个参数，可以写多个--&gt; pageSizeZero=false helperDialect=mysql reasonable=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--其他配置--&gt;&lt;/bean&gt; 分页插件参数介绍&nbsp;&nbsp;&nbsp;&nbsp;dialect：默认情况下会使用PageHelper类进行分页，如果想要实现自己的分页逻辑，可以实现Dialect接口,然后配置这个属性未实现类的全限定名。下面的参数都是在默认dialect情况下的参数。使用自定义dialect实现时下面的参数没有任何作用。&nbsp;helpDialect：配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby。一般情况下，分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。&nbsp;offsetAspageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。&nbsp;rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。&nbsp;pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果&nbsp;reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。&nbsp;params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。&nbsp;supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页&nbsp;autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页&nbsp;closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭 在代码中使用PageHelper完成上面的操作后对分页插件的配置就完成了，使用方法也很简单：使用PageHelper.statPage静态方法来分页，使用PageInfo来获取分页信息 123456789101112131415161718@RequestMapping(\"/showAll\") public String showAllBook(@RequestParam(value = \"pageNo\",defaultValue = \"1\") Integer pageNo,Model model) &#123; //官方推荐的两种使用方式 //1.使用PageHelper.startPage(pageNo,10)进行分页，第一个参数是页码，第二个参数是每页的大小,startPage有几个重载的方法，具体下面有说道 PageHelper.startPage(pageNo,20); List&lt;Book&gt; lists = bookService.getAll(); /**2.使用PageHelper.offsetPage(pageNo,20) *PageHelper.offsetPage(pageNo,20); *List&lt;Book&gt; lists = bookService.getAll(); */ //可以有两个参数，第一个参数是查询到的结果、第二个参数是连续显示的页码数 PageInfo&lt;Book&gt; info=new PageInfo&lt;Book&gt;(lists,10); model.addAttribute(\"info\", info); return \"bookInfo\"; &#125; 使用的时应注意：&nbsp;&nbsp;&nbsp;&nbsp;1.只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。&nbsp;&nbsp;&nbsp;&nbsp;2.请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring配置方式，请选择其中一种，不要同时配置多个分页插件)！&nbsp;&nbsp;&nbsp;&nbsp;3.对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。&nbsp;&nbsp;&nbsp;&nbsp;4.由于分页插件是通过拦截器，在原有SQL上进行追加约束条件，所以使用分页插件时，应保证原有SQL不会 受后面追加的条件的影响。给出一个反例:原有SQL中使用变量计算排名时,如果在后面追加了LIMIT的话，那么排名就会受到影响，因为SELECT的优先级在LIMIT之后。&nbsp;&nbsp;&nbsp;&nbsp;5.PageInfo是比Page信息更丰富的一个类;我们可以直接返回Page,也可以使用PageInfo包装一下返回PageInfo，甚至也可以自定义一个类来存放结果信息(只需将返回的Page中的信息取出来,再setter放入我们自己的类即可)。 PageHelper常用的APIPageMethod的APIPageHelper类继承了PageMethod抽象类，而使用PageHelper类进行分页操作的方法实际用的是PageMethod中的方法，具体如下： 1234567891011121314151617/**startPage方法都有下面几个内存pageNum int类型，当前页码pageSize int类型，每页的大小count boolean类型，是否在分页的时候统计记录数 reasonable boolean类型， isReasonable分页合理化,null时用默认配置pageSizeZero boolean类型，isPageSizeZero是否支持PageSize为0，true且pageSize=0时返回全部结果，false时分页,null时用默认配置*/public static &lt;E&gt; Page&lt;E&gt; startPage(Object params)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, String orderBy)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero)//offsetPage方法和startPage一样都是用来分页的，参数中offset相当于pageNum,limit相当于PageSizepublic static &lt;E&gt; Page&lt;E&gt; offsetPage(int offset, int limit)public static &lt;E&gt; Page&lt;E&gt; offsetPage(int offset, int limit, boolean count)//设置排序规则public static void orderBy(String orderBy) PageInfo类中的成员变量每一个成员变量都有对应的get和set方法，使用这些方法可以获得分页的任何信息，这个类十分强大 1234567891011121314151617181920212223242526272829303132333435//两个重要的构造方法，list是查询到的结果，navigatePages是下方显示的导航页码个数public PageInfo(List&lt;T&gt; list)public PageInfo(List&lt;T&gt; list, int navigatePages)//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//第一页private int firstPage;//前一页private int prePage;//是否为第一页private boolean isFirstPage;//是否为最后一页private boolean isLastPage;//是否有前一页private boolean hasPreviousPage;//是否有下一页private boolean hasNextPage;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums;","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"MyBatis集成EhCache缓存","date":"2019-07-28T16:13:38.000Z","path":"2019/07/29/MyBatis集成EhCache缓存框架/","text":"&nbsp;&nbsp;&nbsp;&nbsp;Encache是一个纯粹的Java进程内的缓存框架，具有快速、精干等特点。具体来说，Encache主要特点如下。 快速 简单 多种缓存策略 缓存数据有内存和磁盘两级，无需担心容量问题 缓存数据会在虚拟机重启的过程写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存接口的侦听接口 &nbsp;因为以上诸多优点，MyBatis项目开发者最早提供了EnCache的MyBatis二级缓存实现，该项目名encache-cache，EhCache官方网址是http://www.mybatis.org/ehcache-cache/。下面，按照如下步骤集成EhCache框架。 添加项目依赖除了基本的MyBatis依赖、数据库驱动以外还需要在pom.xml中添加如下依赖： 123456789101112&lt;!--EnCache缓存核心包--&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-ehcache整合包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt; 配置encache.xml和MyBatis一样，EnCache也需要外部的配置文件，而且要求这个文件的名字必须是encache.xml，并且必须放在类路径的根目录下，即src/main/resources目录下 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\"&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=\"E:\\ehcache\"/&gt; &lt;defaultCache maxElementsInMemory=\"1\" maxElementsOnDisk=\"10000000\" eternal=\"false\" overflowToDisk=\"true\" copyOnRead=\"true\" copyOnWrite=\"true\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 如果想增加一个针对某个Mapper映射文件的缓存配置，可以在ehcache.xml文件中添加一个和映射文件命名空间一致的缓存配置，例如针对UserMapper,可以进行如下配置： 12345678910&lt;cache name=\"com.xust.iot.mapper.UserMapper\" maxElementsInMemory=\"3000\" maxElementsOnDisk=\"1000000\" eternal=\"false\" overflowToDisk=\"true\" copyOnWrite=\"true\" copyOnRead=\"true\" timeToIdleSeconds=\"3600\" timeToLiveSeconds=\"3600\" diskPersistent=\"true\"/&gt; EhCache的配置信息 nameCache的名称，必须是唯一的(ehcache会把这个cache放到HashMap里)。 maxElementsInMemory在内存中缓存的element的最大数目 maxElementsOnDisk在磁盘上缓存的element的最大数目，默认值为0，表示不限制。 eternal设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断。 overflowToDisk 如果内存中数据超过内存限制，是否要缓存到磁盘上。 copyOnRead判断从缓存中读取数据是否是返回对象的引用还是赋值一个对象返回。默认是false，即返回数据的引用，这种情况和MyBatis默认的缓存中只读对象是相同的。如果为true，那就是可读写缓存，每次读取缓存是都赋值一个新的实例。 copyOnWrite判断写入缓存时直接缓存对象的引用还是赋值一个对象后缓存，默认值也是false。如果想使用可读写缓存，就需要将这两个属性配置为true，如果使用只读缓存，可以不配置这两个属性。 timeToIdleSeconds 对象空闲时间，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问。 timeToLiveSeconds 对象存活时间，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问。 diskPersistent 是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false。 diskExpiryThreadIntervalSeconds 对象检测线程运行时间间隔。标识对象状态的线程多长时间运行一次。 diskSpoolBufferSizeMB DiskStore使用的磁盘大小，默认值30MB。每个cache使用各自的DiskStore。 memoryStoreEvictionPolicy 如果内存中数据超过内存限制，向磁盘缓存时的策略。默认值LRU，可选FIFO、LFU。 缓存清空策略 : １、FIFO ，first in first out (先进先出). ２、LFU ， Less Frequently Used (最少使用).意思是一直以来最少被使用的。缓存的元素有一个hit 属性，hit 值最小的将会被清出缓存。 ３、LRU ，Least Recently Used(最近最少使用). (ehcache 默认值).缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 修改Mapper映射文件chcache-cache提供了如下两个可选的缓存实现： org.mybatis.caches.ehcache.EhcacheCache org.mybatis.caches.ehcache.LoggingEhcache 这两个缓存中，第二个是带日志的缓存，由于MyBatis初始化时，如果Cache不是继承自LoggingEhcache，MyBatis便会使用LoggingEhcache装饰代理缓存，所以上面两个缓存使用时并没有区别，都会输出命中率的日志。修改后的UserMapper.xml配置如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xust.iot.mapper.UserMapper\"&gt; &lt;!--在UserMapper中开启二级缓存,MyBatis支持集成第三方缓存,方法是使用type属性指定--&gt; &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt; &lt;select id=\"getUserByName\" parameterType=\"string\" resultType=\"user\"&gt; select * from user &lt;where&gt; name=#&#123;username&#125; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 在src/main/test目录下新建测试类AppTest.java测试是否用上了EhCache： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.UserMapper;import net.sf.ehcache.CacheEntry;import net.sf.ehcache.Element;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import org.mybatis.caches.ehcache.EhcacheCache;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123; private static SqlSessionFactory sqlSessionFactory; private static Logger log = Logger.getLogger(AppTest.class); @Before public void init() &#123; String resource = \"mybatis-config.xml\"; try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test02() &#123; //第一个会话 SqlSession session = sqlSessionFactory.openSession(true); UserMapper sm = session.getMapper(UserMapper.class); List&lt;User&gt; user1 = sm.getUserByName(\"小明\"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; session.close(); //第二个会话 System.out.println(\"开启新的会话......\"); SqlSession session2 = sqlSessionFactory.openSession(true); UserMapper sm2 = session2.getMapper(UserMapper.class); List&lt;User&gt; user2 = sm2.getUserByName(\"小明\"); if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125; &#125; session2.close(); &#125;&#125; 测试结果： 在配置的磁盘路径下确实有缓存文件：","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"深入理解MyBatis高级结果映射","date":"2019-07-28T10:26:33.000Z","path":"2019/07/28/深理解MyBatis高级结果映射/","text":"搭建实验环境 1).新建数据库mybatis6 2). 新建表：sys_user、sys_role、sys_user_role,sys_privilege、sys_role_privilege sql脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657create table sys_user( id bigint not null primary key auto_increment, user_name varchar(255) , user_password varchar(255), user_email varchar(255), user_info text comment '用户简介', head_img blob comment '头像', create_time datetime);create table sys_role( id bigint not null primary key auto_increment, role_name varchar(255) , enable int comment '有效标志', create_by bigint comment '创建人', create_time datetime);create table sys_privilege( id bigint not null primary key auto_increment, privilege_name varchar(50) comment '权限名称', privilege_url varchar(255));create table sys_user_role( user_id bigint , role_id bigint);create table sys_role_privilege( role_id bigint, privilege bigint);insert into sys_user values('1','admin','123456','adimin@mybatis.tk','管理员',null,'2019-7-30 10:05:56');insert into sys_user values('1002','testuser','123456','test@mybatis.tk','测试用户',null,'2019-7-30 10:05:56');insert into sys_role values('1','管理员','1','1','2019-7-30 10:05:56');insert into sys_role values('2','普通用户','1','1','2019-7-30 10:05:56');insert into sys_user_role values ('1','1');insert into sys_user_role values ('1','2');insert into sys_user_role values ('1001','2');insert into sys_privilege values('1','用户管理','/user');insert into sys_privilege values('2','角色管理','/roles');insert into sys_privilege values('3','系统管理','/system');insert into sys_privilege values('4','系统维护','/system-a');insert into sys_privilege values('5','单位管理','/company');insert into sys_role_privilege values('1','1');insert into sys_role_privilege values('1','2');insert into sys_role_privilege values('1','3');insert into sys_role_privilege values('2','4');insert into sys_role_privilege values('2','5'); 3).新建每个 表对应的实体JavaBean SysUser.java 1234567891011121314151617package com.orecal.bean;import java.util.Date;import java.util.List;public class SysUser &#123; private Long id; private String userName; private String userPassword; private String userEmail; private String userInfo; private String headImg; private Date createTime; private SysRole role; //用户的角色 private List&lt;SysRole&gt; roleList; //用户角色结合和 //省略getter、setter.... SysRole.java 1234567891011121314package com.orecal.bean;import java.util.Date;import java.util.List;public class SysRole &#123; private Long id; private String roleName; private int enable; private int createBy; private Date createTime; private List&lt;SysPrivilege&gt; privilegeList; //省略getter、setter.... SysUserRole.java 12345678package com.orecal.bean;public class SysUserRole &#123; private Long userId; private Long roleId; //省略getter、setter.... SysPrivilege.java 123456789package com.orecal.bean;public class SysPrivilege &#123; private Long id; private String privilegeName; private String privilegeUrl; //省略getter、setter.... SysRolePrivilege.java 12345678package com.orecal.bean;public class SysRolePrivilege &#123; private Long roleId; private Long privilegeId; //省略getter、setter.... 4).新建SysUserMapper接口 5). 新建mybaits配置文件 一对一映射Mybatis中的映射方式有两种，一种是通过resultType自动映射，另一种是通过resultMap自己设置映射规则。resultMap又有两种映射方式：嵌套结果映射和嵌套查询映射。 嵌套结果映射:给数据库发一条复杂的sql语句把查询到的结果根据映射规则映射到不同的对象中 嵌套查询映射：会发多条sql简单的语句，Mybatis会把多条sql语句的查询据结果封装到一个对象中。如果在mybatis全局配置中设置了延迟加载：` ` 那么还可以按需给数据库发sql语句，即当没有用到这个表中的数据的时候，Mybatis压根就不会给数据库法sql语句，即使已在xml文件中已经配置了sql语句，这是MyBatis中非常强大的一个功能。 配置xml文件：通过resultMap一对一映射，在SysUser实体类中新增一个属性private SysRole role 标识用户的角色，然后在SysUserMapper.xml中写如下映射userRoleMap： 123456789101112131415161718192021222324252627SysUserMapper.xml&lt;resultMap type=\"com.orecla.bean.SysUser\" id=\"userRoleMap\"&gt; &lt;!--sys_user表中原有的属性--&gt; &lt;!-- id:id元素是一个很特殊的元素，如果设置了它，MyBayis会比较每次返回来的数据的id,如果id相同，MyBatis就会认为这是同一条数据，然后就会把这两条数据合并；如果没有设置id,MyBatis会比较resultMap下所有的字段属性，只要有一个不同就不会合并。 --&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"userName\" column=\"user_name\"/&gt; &lt;result property=\"userPassword\" column=\"user_password\"/&gt; &lt;result property=\"userEmail\" column=\"user_email\"/&gt; &lt;result property=\"userInfo\" column=\"user_info\"/&gt; &lt;result property=\"headImg\" column=\"head_img\"/&gt; &lt;result property=\"createTime\" column=\"create_time\"/&gt; &lt;!--role字段在sys_user表中没有，而且role他是一个复杂的类型，没法直接映射，最简单的可以通过如下这种方式来映射--&gt; &lt;result property=\"role.roleName\" column=\"role_name\"/&gt; &lt;result property=\"role.enable\" column=\"enable\"/&gt; &lt;result property=\"role.createTime\" column=\"create_time\"/&gt; &lt;result property=\"role.createBy\" column=\"create_by\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserAndRoleById\" resultMap=\"userRoleMap\"&gt; select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=#&#123;id&#125; and sys_role.role_name=sys_user.user_info&lt;/select&gt; 在SysUserMapper接口中增加方法：public SysUser selectUserAndRoleById(Long id);测试方法： 1234567891011121314@Test public void test1() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); SysUser user = sum.selectUserAndRoleById(1002L); System.out.println(user); //log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 这是日志的打印结果： 123456 2019-07-31 10:16:52 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] ==&gt; Preparing: select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=? and sys_role.role_name=sys_user.user_info 2019-07-31 10:16:52 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] ==&gt; Parameters: 1002(Long) 2019-07-31 10:16:53 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=null, roleName=&apos;普通用户&apos;, enable=0, createBy=0, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 10:16:53 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 10:16:53 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. &nbsp;&nbsp;&nbsp;&nbsp;改进上面的映射方法：上面的映射方法虽然可以使用，但是耦合性太高，而且最大的问题是配置文件不能复用，啥意思?就是说，如果我现在需要一个单独查用户的方法，那我还得专门为查用户写一个sql配置，这样做非常的糟糕，当项目非常大的时候，配置文件的重复配置代码将会非常的多，那么如何解决这个问题呢?我们接着往下看:在SysUserMapper.xml中增加一个专门为查用户的映射userMap： 12345678910111213SysUserMapper.xml&lt;resultMap type=\"com.orecal.bean.SysUser\" id=\"userMap\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"userName\" column=\"user_name\"/&gt; &lt;result property=\"userPassword\" column=\"user_password\"/&gt; &lt;result property=\"userEmail\" column=\"user_email\"/&gt; &lt;result property=\"userInfo\" column=\"user_info\"/&gt; &lt;result property=\"headImg\" column=\"head_img\"/&gt; &lt;result property=\"createTime\" column=\"create_time\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectUser\" resultMap=\"userMap\"&gt; select * from sys_user where id=#&#123;id&#125;; &lt;/select&gt; 然后刚才的上面的userRoleMap就可以修改成下面的样子： 123456789101112131415161718192021SysUserMapper.xml &lt;!-- 使用resultMap可以自定义结果集的映射关系 type:这个样映射到那个pojo id：给这个映射关系起的一个唯一的标识 extends:resultMap可以继承别的map已经定义好的关系，比如下面的userMap在上门已经定义了，在下面可以继承后直接使用 --&gt; &lt;resultMap type=\"com.orecal.bean.SysUser\" id=\"userRoleMap\" extends=\"userMap\"&gt; &lt;result property=\"role.roleName\" column=\"role_name\"/&gt; &lt;result property=\"role.enable\" column=\"enable\"/&gt; &lt;result property=\"role.createTime\" column=\"create_time\"/&gt; &lt;result property=\"role.createBy\" column=\"create_by\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectUserAndRoleById\" resultMap=\"userRoleMap\"&gt; select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=#&#123;id&#125; and sys_role.role_name=sys_user.user_info &lt;/select&gt; 使用association元素替代上面的role.XXX: 1234567891011121314151617SysUserMapper.xml &lt;!--使用association和一个复杂的类型进行关联 property:pojo中对应的属性名，必填 javaType:这个属性对应的pojo类型 resultMap:可以使用这个属性配置已有的map， 如果要引用当前mapper中的resultMap，直接引用 如果引用别的mapper中的resultMap，要指定namespace以及引用的那个map的id --&gt;&lt;resultMap id=\"userRoleMap2\" type=\"com.orecal.bean.SysUser\" extends=\"userMap\"&gt; &lt;association property=\"role\" javaType=\"com.orecal.bean.SysRole\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"enable\" column=\"enable\"/&gt; &lt;result property=\"createTime\" column=\"create_time\"/&gt; &lt;result property=\"createBy\" column=\"create_by\"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 可是这样还是不行，实际的开发中，肯定会有关于单独查询sys_role的需求，而且人家sys_role肯定也会有单独的mapper,这样就又会存在重复配置的问题，解决这个问题需要用到association元素的另一个功能,具体看代码：新建SysRoleMapper.xml,并配置roleMap如下： 123456789101112SysRoleMapper.xml&lt;!--根据id查询角色--&gt;&lt;resultMap type=\"com.orecal.bean.SysRole\" id=\"roleMap\"&gt; &lt;result property=\"id\" column=\"id\"/&gt; &lt;result property=\"roleName\" column=\"role_name\"/&gt; &lt;result property=\"enable\" column=\"enable\"/&gt; &lt;result property=\"createTime\" column=\"create_time\"/&gt; &lt;result property=\"createBy\" column=\"create_by\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectRoleById\" resultMap=\"roleMap\"&gt; select * from sys_role where id=#&#123;id&#125;;&lt;/select&gt; 这样我们在SysUserMapper.xml就可以把刚才的配置彻底抽取了出来： 1234567SysUserMapper.xml&lt;resultMap id=\"userRoleMap\" type=\"com.orecal.bean.SysUser\" extends=\"userMap\"&gt; &lt;!--在association中使用resultMap属性指定要关联的Map resultMap=目标map的namespace.目标map的id 在同一个mapper中也可以这么使用，但是只用指定id就够了 --&gt; &lt;association property=\"role\" resultMap=\"com.orecal.mapper.SysRoleMapper.roleMap\"/&gt;&lt;/resultMap&gt; 这样就彻底把模块与模块分开了,当然我们也可以顺便实现以下selectRoleById,下面是配置后的运行时打印的日志的部分： 12345678 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] ==&gt; Preparing: select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=? and sys_role.role_name=sys_user.user_info 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] ==&gt; Parameters: 1002(Long) 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=1002, roleName=&apos;普通用户&apos;, enable=0, createBy=0, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 10:57:08 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 10:57:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，日志的打印结果相同，但是修改后的方式肯定比一开始的方法要好，因为这样就把各个查询模块化了，就像搭积木，一个个简单的“积木块”最后通过合理的组织，就可以实现不同的复杂查询。一对一的嵌套查询映射上面这种方法是嵌套结果映射，就是直接给数据库发一条sql语句，数据库返回数据后Mybatis根据映射规则，把数据映射到不同的对象中。而嵌套查询映射则是多次给数据库发简单的sql语句，然后把不同的数据映射到一个对象中。 1.association元素的嵌套查询： &nbsp; &nbsp; select :另一个映射查询map的id &nbsp; &nbsp; column：将主查询的那个列的结果作为嵌套查询的参数传给嵌套查询方法 &nbsp; &nbsp; fetchType:数据加载的方式[lazy或eager],即延迟加载或积极加载, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 配置这个属性会覆盖全局配置中飞lazyLoadingEnabled 2.MyBatis的嵌套查询可以实现懒加载，简单点的说就是不用的时候就不给你加载，等用的时候才去给你加载,这样做的好处是可以降低数据库的压力，做到按需响应。那么要用懒加载必须在全局配置文件中设置如下：&lt;settings&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!--vallue=false时按需加载-，否者全部加载-&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--是否开启懒加载，true表示开启--&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt; &lt;!--懒加载模式下如果调用value后的方法将全部加载--&gt; &lt;/settings&gt; 在SysUserMapper.xml中写一个id为userRoleMapSelecct的新的映射关系，并写SQL查询语句如下： 123456789101112131415161718192021222324252627SysUserMapper.xml&lt;resultMap id=\"userRoleMapSelect\" extends=\"userMap\" type=\"com.orecal.bean.SysUser\"&gt; &lt;!-- association的select元素中指定另一个嵌套的子查询 select=子查询Mapper接口中对应方法的全类名 --&gt; &lt;association property=\"role\" select=\"com.orecal.mapper.SysRoleMapper.selectRoleById\" column=\"&#123;id=role_id&#125;\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectUserAndRoleById3\" resultMap=\"userRoleMapSelect\"&gt;SELECT sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id FROM sys_user, sys_user_role WHERE sys_user.id = sys_user_role.user_id AND sys_user.id = #&#123;id&#125;&lt;/select&gt; 配置好后我们在SysUserMapper接口中增加selectUserAndRoleById3方法,然后写测试： 1234567891011121314151617 @Testpublic void test4() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectUserAndRoleById3(1002L); for (SysUser u : user) &#123; System.out.println(u); //System.out.println(u.getUserName() + \",\" + u.getUserEmail() + \",\" + u.getCreateTime()); &#125; log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125;&#125; 日志的打印结果： 123456789101112131415 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Opening JDBC Connection 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 785447854. 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Preparing: select sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id from sys_user,sys_user_role where sys_user.id=sys_user_role.user_id and sys_user.id=? 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Parameters: 1002(Long) 2019-07-31 11:29:54 [WARN]-[org.apache.ibatis.session.AutoMappingUnknownColumnBehavior] Unknown column is detected on &apos;com.orecal.mapper.SysUserMapper.selectUserAndRoleById3&apos; auto-mapping. Mapping parameters are [columnName=role_id,propertyName=role_id,propertyType=null] 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] &lt;== Total: 1 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] ==&gt; Preparing: select * from sys_role where id=?; 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] ==&gt; Parameters: 2(Long) 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=2, roleName=&apos;普通用户&apos;, enable=1, createBy=1, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 11:29:54 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@6580cfdd 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，MyBatis分别给数据库发了两条sql语句，这是因为直接打印，在配置文件的setting中有一个元素lazyLoadTriggerMethods 默认值value=&quot;equals,clone,hashCode,toString&quot;，当程序中调用这些方法的时就会全部加载。但是如果我们在程序中只是用到User的一些属性，那么Mybatis就只发查user的sql语句,把测试代码中的System.out.println(u);改成System.out.println(u.getUserName() + &quot;,&quot; + u.getUserEmail() + &quot;,&quot; + u.getCreateTime()); 再次运行打印的日志部分如下： 12345678910 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Preparing: select sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id from sys_user,sys_user_role where sys_user.id=sys_user_role.user_id and sys_user.id=? 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Parameters: 1002(Long) 2019-07-31 11:27:13 [WARN]-[org.apache.ibatis.session.AutoMappingUnknownColumnBehavior] Unknown column is detected on &apos;com.orecal.mapper.SysUserMapper.selectUserAndRoleById3&apos; auto-mapping. Mapping parameters are [columnName=role_id,propertyName=role_id,propertyType=null] 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] &lt;== Total: 1 testuser,test@mybatis.tk,Tue Jul 30 10:05:56 CST 20192019-07-31 11:27:13 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@6a400542 2019-07-31 11:27:13 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 11:27:13 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，只发了一条sql语句。这就是MyBatis的延迟加载（懒加载），也就是说，当你没用到的时候，MyBatis压根不会帮你去查这个数据。这样一来的好处是会减轻数据库的压力。 一对多映射使用collection实现一对多映射,collection的属性和用法与association基本是一样的，只是collection是专门用来映射数据库中一对多的多方元素的一个集合。比如现在有这样的需求：查询所有用户以及每个用户在本系统中所拥有的角色。这是一个很典型的一对多的例子，一个用户在系统中有多个角色。举个栗子：在SysUser.java中增加属性List&lt;SysRole&gt; roleList 12345678910//其他的属性不变private List&lt;SysRole&gt; roleList; //用户角色结合public List&lt;SysRole&gt; getRoleList() &#123; return roleList;&#125;public void setRoleList(List&lt;SysRole&gt; roleList) &#123; this.roleList = roleList;&#125; 在SysUserMapper.xml中增加reultMapuserRoleListMap,由于roleMap在前面已经定义过了，这里就可以直接使用 12345678910111213141516SysUserMapper.xml&lt;resultMap id=\"userRoleListMap\" extends=\"userMap\" type=\"com.orecal.bean.SysUser\"&gt; &lt;collection property=\"roleList\" resultMap=\"com.orecal.mapper.SysRoleMapper.roleMap\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllUserAndRole\" resultMap=\"userRoleListMap\"&gt;SELECT sys_user.*, sys_role.* FROM sys_user, sys_role, sys_user_role WHERE sys_user_role.user_id = sys_user.id AND sys_user_role.role_id = sys_role.id;&lt;/select&gt; 测试代码： 1234567891011121314151617181920@Testpublic void test5() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectAllUserAndRole(); System.out.println(\"用户数：\" + user.size()); for (SysUser u : user) &#123; System.out.println(\"用户名：\" + u.getUserName()); for (SysRole role : u.getRoleList()) &#123; System.out.println(\"角色名：\" + role.getRoleName()); &#125; &#125; log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125;&#125; 程序运行打印的日志： 12345678910111213141516 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Opening JDBC Connection 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 741669172. 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Preparing: select sys_user.*,sys_role.*,sys_privilege.* from sys_user, sys_role,sys_user_role,sys_privilege,sys_role_privilege where sys_user_role.user_id=sys_user.id and sys_user_role.role_id=sys_role.id and sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Parameters: 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] &lt;== Total: 7 用户数：2用户名：admin角色名：管理员角色名：普通用户用户名：testuser角色名：普通用户2019-07-31 14:47:06 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@38c5cc4c 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2c34f934] 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 741669172 to pool. Process finished with exit code 0 前面这个实现了一层嵌套，就是一个主查询下面只有一个层子查询然后就结束了，下面我们尝试来实现一个两层嵌套：比如现在有这样的需求：查询所有的用户的角色，以及每个角色拥有的权限。很好想，就是一个用户可以有多个角色，每个角色又有不同的权限。 实现： 首先在SysRole中增加一个属性private List&lt;SysPrivilege&gt; privilegeList 12345678910//其他的属性不变private List&lt;SysPrivilege&gt; privilegeList;public List&lt;SysPrivilege&gt; getPrivilegeList() &#123; return privilegeList;&#125;public void setPrivilegeList(List&lt;SysPrivilege&gt; privilegeList) &#123; this.privilegeList = privilegeList;&#125; 新建SysPrivilegeMapper.xml文件，增加一个resultMapprivilegeMap 12345678910111213 &lt;resultMap type=\"com.orecal.bean.SysPrivilege\" id=\"privilegeMap\"&gt; &lt;result property=\"privilegeName\" column=\"privilege_name\"/&gt; &lt;result property=\"privilegeUrl\" column=\"privilege_url\"/&gt; &lt;/resultMap&gt; SELECT sys_privilege.* FROM sys_privilege, sys_role_privilege WHERE sys_role_privilege.privilege_id = sys_privilege.id AND sys_role_privilege.role_id = #&#123;roleId&#125; &lt;/select&gt; 在SysRoleMapper.xml中增加一个resultMaprolePrivilegeListMap，由于roleMap在上面已经定义过了，，用extends继承他就可以直接使用了。 123456789101112131415SysRoleMapper.xml&lt;resultMap id=\"rolePrivilegeListMap\" extends=\"roleMap\" type=\"com.orecal.bean.SysRole\"&gt; &lt;collection property=\"privilegeList\" resultMap=\"com.orecal.mapper.SysPrivilegeMapper.privilegeMap\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllRoleAndPrivilege\" resultMap=\"rolePrivilegeListMap\"&gt; select sys_role.*, sys_privilege.* from sys_role, sys_privilege, sys_role_privilege where sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; &lt;/select&gt; 在SysUserMapper.xml中增加reusltMap:userRoleListMapSelect 12345678910111213141516171819202122SysUserMapper.xml&lt;resultMap id=\"userRoleListMapSelect\" extends=\"userMap\" type=\"com.orecal.bean.SysUser\"&gt; &lt;collection property=\"roleList\" resultMap=\"com.orecal.mapper.SysRoleMapper.rolePrivilegeListMap\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selectAllUserAndRole2\" resultMap=\"userRoleListMap\"&gt; SELECT sys_user.*, sys_role.*, sys_privilege.* FROM sys_user, sys_role, sys_user_role, sys_privilege, sys_role_privilege WHERE sys_user_role.user_id = sys_user.id AND sys_user_role.role_id = sys_role.id AND sys_role_privilege.role_id = sys_role.id AND sys_privilege.id = sys_role_privilege.privilege_id; &lt;/select&gt; 在SysUserMapper接口中增加方法selectAllUserAndRole2，并且编写测试代码： 1234567891011121314151617181920212223@Test public void test6() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectAllUserAndRole(); System.out.println(\"用户数：\" + user.size()); for (SysUser u : user) &#123; System.out.println(\"用户名：\" + u.getUserName()); for (SysRole role : u.getRoleList()) &#123; System.out.println(\"角色名：\" + role.getRoleName()); for (SysPrivilege privilege : role.getPrivilegeList()) &#123; System.out.println(\"权限：\" + privilege.getPrivilegeName()); &#125; &#125; System.out.println(\"--------------------------------------------------------\"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 程寻运行打印的日志的一部分： 1234567891011121314151617181920212223242019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 741669172. 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Preparing: select sys_user.*,sys_role.*,sys_privilege.* from sys_user, sys_role,sys_user_role,sys_privilege,sys_role_privilege where sys_user_role.user_id=sys_user.id and sys_user_role.role_id=sys_role.id and sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Parameters: 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] &lt;== Total: 7 用户数：2用户名：admin角色名：管理员权限：用户管理权限：角色管理权限：系统管理角色名：普通用户权限：系统维护权限：单位管理--------------------------------------------------------用户名：testuser角色名：普通用户权限：系统维护权限：单位管理--------------------------------------------------------2019-07-31 15:11:27 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@38c5cc4c 2019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2c34f934] 2019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 741669172 to pool. Process finished with exit code 0 这样，我们就算是实现了一对多的两层嵌套结果映射的一个查询，这种方式在日常非常常见，也是MyBatis中非常强大的地方。最后我们看一下一对多的嵌套查询映射，和一对一的实现方法是类似的：前面我们写过一个resultMaprolePrivilegeListMap，但是还没有为他写接口方法，这里我们首先来实现这个： 123456789public interface SysPrivilegeMapper &#123; /** * 通过角色ID获得它的权限 * @return */ public List&lt;SysPrivilege&gt; selectPrivilegeByRoleId(Long id);&#125; 在SysRoleMapper.xml增加一个resultMap:rolePrivilegeListMap2 123456789101112131415&lt;resultMap id=\"rolePrivilegeListMap2\" extends=\"roleMap\" type=\"com.orecal.bean.SysRole\"&gt; &lt;collection property=\"privilegeList\" select=\"com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId\" column=\"&#123;roleId=id&#125;\"&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"selectRoleByUserId\" resultMap=\"rolePrivilegeListMap2\"&gt; SELECT sys_role.* FROM sys_role, sys_user_role WHERE sys_user_role.user_id = sys_role.id AND sys_user_role.user_id = 1; &lt;/select&gt; 在SysRoleMapper接口中增加一个方法selectRoleByUserId 123456/** * 根据用户id查他的权限 * @param userId * @return */public List&lt;SysRole&gt; selectRoleByUserId(Long userId); 最后在SysUserMapper.xml中增加一个resultMap:userRoleListMap2 12345678 &lt;resultMap id=\"userRoleListMap2\" extends=\"userMap\" type=\"com.orecal.bean.SysUser\"&gt; &lt;collection property=\"roleList\" select=\"com.orecal.mapper.SysRoleMapper.selectRoleByUserId\" column=\"&#123;userId=id&#125;\"/&gt;&lt;/resultMap&gt;&lt;select id=\"selectAllUserAndRole2\" resultMap=\"userRoleListMap2\"&gt; select sys_user.* from sys_user where sys_user.id=#&#123;id&#125;&lt;/select&gt; 在SysUserMapper接口中增加一个方法selectAllUserAndRole2: 1234567 /** * 根据用户的Id查询他拥有的角色和对应的权限 * @param id * @return */public SysUser selectAllUserAndRole2(Long id); 测试代码： 1234567891011121314151617181920212223@Test public void test10() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); SysUser user = sum.selectAllUserAndRole2(1002L); System.out.println(\"-------------------------------------------\"); System.out.println(\"用户名：\" + user.getUserName()); for (SysRole role : user.getRoleList()) &#123; System.out.println(\"角色名：\" + role.getRoleName()); for (SysPrivilege privilege : role.getPrivilegeList()) &#123; System.out.println(\"权限：\" + privilege.getPrivilegeName()); &#125; System.out.println(\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"); &#125; System.out.println(\"-------------------------------------------\"); log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 程寻运行打印的日志: 123456789101112131415161718192021222324252627282019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 785447854. 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] ==&gt; Preparing: select sys_user.* from sys_user where sys_user.id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] &lt;== Total: 1 -------------------------------------------用户名：admin2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] ==&gt; Preparing: select sys_role.* from sys_role,sys_user_role where sys_user_role.user_id=sys_role.id and sys_user_role.user_id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] &lt;== Total: 2 角色名：管理员2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] ==&gt; Preparing: select sys_privilege.* from sys_privilege,sys_role_privilege where sys_role_privilege.privilege_id=sys_privilege.id and sys_role_privilege.role_id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] &lt;== Total: 3 权限：用户管理权限：角色管理权限：系统管理$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$角色名：管理员权限：用户管理权限：角色管理权限：系统管理$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------------------------------------2019-07-31 15:40:08 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@63355449 2019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，程寻运行时，MyBatis给数据库发了多条sql语句，最终通过预定的映射集合，把这些查出来的数据放进去，之后打包组合成一个List&lt;SysRole&gt;对象返回。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"MyBatis缓存配置","date":"2019-07-28T05:26:29.000Z","path":"2019/07/28/MyBatis缓存配置/","text":"&nbsp;&nbsp;&nbsp;&nbsp;使用缓存可以是应用更快的获取数据，避免频繁的数据库交互，尤其是在查询越多、缓存命中率越高的情况下，使用缓存的作用就越明显。MyBatis作为持久层框架，提供了强大的查询缓存特性，可非常方便的配置和使用。&nbsp;&nbsp;&nbsp;&nbsp;MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存。&nbsp;&nbsp;&nbsp;&nbsp;1、默认情况下，一级缓存（SqlSession级别的缓存，也称为本地缓存）是开启的，但是不能控制。&nbsp;&nbsp;&nbsp;&nbsp;2、二级缓存需要手动开启和配置，他是和命名空间绑定的，即二级缓存需要配置在Mepper,xml文件中获配置在Mapper..java接口中&nbsp;&nbsp;&nbsp;&nbsp;3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存（或者使用第三方缓存） 一级缓存先通过一个简单的演示看看MyBati一级缓存是如何起作用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = \"mybatis-config.xml\";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;/*** 测试MyBatis一级缓存的特性*/@Testpublic void test01() &#123;SqlSession session = sqlSessionFactory.openSession(true);try &#123; StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;User&gt; user1 = sm.getUserByName(\"小明\"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; System.out.println(\"第二次查询\\\"小明\\\"............\"); List&lt;User&gt; user2 = sm.getUserByName(\"小明\"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; System.out.println(\"user1==user?==&gt;\" + (user1 == user2));&#125; catch (Exception e) &#123; log.error(e + \"---\" + new Date());&#125; finally &#123; session.close();&#125;&#125;&#125; 测试结果如下： &nbsp;&nbsp;&nbsp;&nbsp;可以看到，两次查询值MyBatis只给数据库发送了一次SQL语句，但是两次查询的结果都是一样的，而且再往下发现两个List&lt;User&gt;对象竟然是同一个对象，之所以这样就是MyBatis的一级缓存在起作用。&nbsp;&nbsp;&nbsp;&nbsp;在同一个SqlSession中查询是MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入PerpetualCache 的 HashMap本地缓存对象中。如果同一个SqlSession中执行的方法和参数完全一致，闹通过算法就会生成相同的键值，当Map缓存对象中已经存在该键值时，就会返回缓存中的对象，而不会再给数据库发sql语句了。&nbsp;&nbsp;&nbsp;&nbsp;但是要注意，下面几种情况发生会使一级缓存会失效： 1. 不同的SqlSession用不同的一级缓存，他们之间的数据不能共享 2. 就算是同一个SqlSession对象，但是如果执行的方法和参数不同也不行 3. 默认情况下，在SqlSession期间执行任何一次增删改操作，一级缓存会被清空 4. 手动清空一级缓存，一级缓存也会失效 下面分别举例说明： 由于MyBatis的一级缓存存在于SqlSession生命周期中，一次不同的SqlSession当然会有不同的一级缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = \"mybatis-config.xml\";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;/*** MyBatis的一级缓存存在于SqlSession生命周期中，在同一个SqlSession中查询是MyBatis会把* 执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map中。*/@Testpublic void test02() &#123;//第一个会话SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName(\"小明\");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//第二个会话System.out.println(\"开启新的会话......\");SqlSession session2 = sqlSessionFactory.openSession(true);StudentMapper sm2 = session2.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName(\"小明\");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();session2.close();&#125;&#125; 测试结果如下： MyBatis的&lt;insert&gt;、&lt;delete&gt;、&lt;update&gt;和&lt;select&gt;标签都中有一个属性：flushCache,在默认情况下，对于增删改操作这个标签默认值是true,也就是每次操作后要清空缓存，而对于&lt;select&gt;操作这个属性默认值是false，也即不刷新缓冲。也就是下面这段代码要说明的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = \"mybatis-config.xml\";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;@Testpublic void test03() &#123;SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName(\"小明\");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//执行任意一次增删改操作，当前SqlSession的一级缓存立即被清空System.out.println(\"删除一个用户......\");sm.deleteUserById(14);System.out.println(\"删除完成.......\");//由于缓存被清了，因此还得给数据库发sql语句查询StudentMapper sm2 = session.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName(\"小明\");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();&#125;&#125; 测试结果如下： 下面的这种情况就更直观了，但本质上和上面那种情况是一样的——都是一级缓存被清空了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = \"mybatis-config.xml\";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;@Testpublic void test03() &#123;SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName(\"小明\");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//清除缓存System.out.println(\"手动清除缓存......\");session.clearCache();StudentMapper sm2 = session.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName(\"小明\");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();&#125;&#125; 测试结果如下： 二级缓存 二级缓存默认也是采用 PerpetualCache，HashMap存储； 二级缓存的存储作用域为 Mapper(确切说是namespace)，即一个Mapper执行了insert、update或delete操作，不影响另外一个Mapper（不同namespace）； 二级缓存可自定义存储实现，如 Ehcache、redis； 二级缓存开启后，需要对应的java Bean实现，并且这个java Bean要实现Serializable接口进行序列化 配置二级缓存&nbsp;&nbsp;&nbsp;&nbsp;二级缓存有两种配置方法，一种是基于Mapper.xml文件来配置；另一种就是基于Mapper.java接口来配置。下面分别来看看如何配置使用MyBatis的二级缓存：&nbsp;&nbsp;&nbsp;&nbsp;首先，无论是通过Mapper.xml文件来配置，还是通过Mapper.java接口来配置，都需要在mybatis-config.xml文件中通过settings设置显式地开启二级缓存： 123456&lt;!--一些有关于mybatis运行行为的设置--&gt;&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;!--其他的设置--&gt;&lt;/settings&gt; 在Mapper.xml中配置二级缓存在xml文件中配置的方法很简单，在保证二级缓存的全局配置开启的情况下，在UserMapper.xml中只需要添加&lt;cache&gt;&lt;/cache&gt;即可。 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xust.iot.mapper.StudentMapper\"&gt;&lt;!--在UserMapper中开启二级缓存--&gt;&lt;cache&gt;&lt;/cache&gt;&lt;select id=\"getUserByName\" parameterType=\"string\" resultType=\"user\"&gt;select * from user&lt;where&gt; name=#&#123;username&#125;&lt;/where&gt;&lt;/select&gt;&lt;delete id=\"deleteUserById\" parameterType=\"integer\" &gt;delete from user&lt;where&gt; id=#&#123;userId&#125;&lt;/where&gt;&lt;/delete&gt;&lt;/mapper&gt; &lt;cacha&gt;标签的属性： eviction：缓存回收策略：flushInterval：缓存多长时间清空一次，默认不清空，单位毫秒 ms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LRU——最少使用的，移除最长时间不适用的对象；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIFO——先进先出&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WEAK——弱引用，更积极的移除基于垃圾回收器状态和弱引用规则的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOFT——软引用，更积极的移除基于垃圾回收器状态和弱引用规则的对象 flushInterval：缓存多久清空一次，默认不清空，时间毫秒 ms readOnly：缓存是否只读 size：缓存觉存放元素个数，默认1024 type：自定义缓存的全类名 在Mapper接口中配置二级缓存在接口中配置主要是借助@CacheNamespace这个注解，但是要注意：配置文件和接口注释是不能够配合使用的。只能通过全注解的方式或者全部通过xml配置文件的方式使用。也就是说你用了配置文件就不要用这种方式，用了接口配置的方式就别用xml配置文件的方式。如下： 1234567891011121314151617181920212223242526package com.xust.iot.mapper;import com.xust.iot.beans.User;import org.apache.ibatis.annotations.*;import java.util.List;@CacheNamespacepublic interface StudentMapper &#123; /** * 查询所有姓名为name的用户 * @param name * @return */ @Select(\"select * from user where name=#&#123;username&#125;\") @Options(useCache = true) public List&lt;User&gt; getUserByName(@Param(\"username\") String name); /** * 删除id=userId的用户 * @param id */ @Delete(\"delete from user where id=#&#123;userId&#125;\") public void deleteUserById(@Param(\"userId\") Integer id);&#125; 并在mybatis-config.xml中重新配置Mapper映射文件： 1234&lt;mappers&gt; &lt;!-- &lt;mapper resource=\"mapper/StudentMapper.xml\"&gt;&lt;/mapper&gt;--&gt; &lt;mapper class=\"com.xust.iot.mapper.StudentMapper\"/&gt; &lt;/mappers&gt; 使用二级缓存：&nbsp;&nbsp;&nbsp;&nbsp;配置Mybatis二级缓存的方法有两种，只要配置好,二级缓存就可以工作了。但是在使用前需要注意的是，由于MyBatis使用SerializedCache序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。因此，如果配置了只读缓存，MyBatis就会使用Map来存储缓存值。而这个缓存类要求所有被序列化的对象必须实现Serializable接口 。因此我们的java Bean需要实现Serializable接口。 12345678910package com.xust.iot.beans;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = -8963153814502574628L; //其他属性&#125; 做好所有准备后，编写一个测试类来看看二级缓存的效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123; private static SqlSessionFactory sqlSessionFactory; private static Logger log = Logger.getLogger(AppTest.class); @Before public void init() &#123; String resource = \"mybatis-config.xml\"; try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testL2Cache() &#123; //第一个会话 SqlSession session = sqlSessionFactory.openSession(true); StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;User&gt; user1 = sm.getUserByName(\"小明\"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; session.close(); //第二个会话 System.out.println(\"开启新的会话......\"); SqlSession session2 = sqlSessionFactory.openSession(true); StudentMapper sm2 = session2.getMapper(StudentMapper.class); List&lt;User&gt; user2 = sm2.getUserByName(\"小明\"); if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125; &#125; session2.close(); &#125;&#125; 测试结果： MyBatis缓存的执行逻辑&nbsp;&nbsp;&nbsp;&nbsp;1.当一个SqlSession第一次执行一次select后，查到数据后会首先把查询到的结果保存到一级缓存中&nbsp;&nbsp;&nbsp;&nbsp;2.当该SqlSession被关闭或者提交后，保存在一级缓存中的数据会转移到二级缓存中（前提是正确开启并配置了二级缓存）&nbsp;&nbsp;&nbsp;&nbsp;3.当另一个SqlSession第一次执行同样select时，首先会在二级缓存中找，如果没找到，就去自己的一级缓存中找，找到了就返回，如果没找到就去数据库查，MyBatis就是通过这样的机制从而减少了数据库压力提高了性能。MyBatis的执行流程总结起来就是：二级缓存–&gt;一级缓存–&gt;数据库 注意事项：&nbsp;&nbsp;&nbsp;&nbsp;1.如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读&nbsp;&nbsp;&nbsp;&nbsp;2.mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"Mybatis XML映射文件的配置","date":"2019-07-27T10:25:37.000Z","path":"2019/07/27/Mybatis XML映射文件的配置/","text":"MyBatis中的SQL 映射文件只有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。cache-ref – 其他命名空间缓存配置的引用。resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。sql – 可被其他语句引用的可重用语句块。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句 select元素select元素就是用来查询的，在select里嵌入SQL select查询语句,就象下边这样： 123&lt;select id=\"get\" resultType=\"Employee\" parameterType=\"int\"&gt; select * from employee where id=#&#123;id&#125;;&lt;/select&gt; 其中 select元素中的id属性是必须的，它的值是对应Mapper接口中的一个方法，当调用这个接口就是调用这个sql。关于select元素常用的属性具体如下： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。这个是必须的属性 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 resultType 返回的期望类型的类的完全限定名或别名。这个属性是可选的 resultMap 返回值类型是是个map集合，可用于多表联查后的结果MyBatis会封装成一个map返回，这个属性是可选的 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。这个属性是可选的 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。这个属性是可选的 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。这个属性是可选的 insert update delete&nbsp;&nbsp;&nbsp;&nbsp;insert update delete元素分别对应SQL语句中的insert、update、delete，分别实现对数据库记录的插入、更新和删除。他们可以有的属性值如下： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。这个是必须的属性 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键，默认值为false，这个属性是可选的。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，他和useGeneratedKeys配合起来才能工作 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true。这个属性是可选的 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对增删改元素为false。这个属性是可选的 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。这个属性是可选的 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 Result MapsresultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计就是简单语句不需要明确的结果映射,而很多复杂语句确实需要描述它们的关系。 简单映射例如下面这个例子：： 123&lt;select id=\"getById\" resultType=\"Employee\" paramaterType=\"int\"&gt; select * from employee where id=#&#123;id&#125;&lt;/select&gt; JavaBean是这样的： 1234567891011121314151617181920212223242526package com.xzy.bean;public class Employee &#123; /** * JavaBean基本类型最好使用他的包装类型！！！ */ private Long id; private String empId; private String empName; private Integer empAge; private String empSex; //省略getter、setter.... @Override public String toString() &#123; return \"Employee&#123;\" + \"id=\" + id + \", empId='\" + empId + '\\'' + \", empName='\" + empName + '\\'' + \", empAge=\" + empAge + \", empSex='\" + empSex + '\\'' + '&#125;'; &#125;&#125; Mybatis会将基于 JavaBean 的规范,这些 在 select 语句中会精确匹配到列名。这样一个语句简单作用于所有列被自动映射到 HashMap 的键上,这由 resultType 属性 指定。也就是说，对于resultType MyBatis会结果封装一个map返回。 高级映射有时候我们避免不了多表联查，这样带来的问题是返回的结果类型中的一个字段在resultType中的不存在，这就会造成问题。MyBatis中使用resultMap来解决这个问题。resultMap 元素有很多子元素和一个值得讨论的结构。 下面是 resultMap 标签中可以使用的属性如下： resultMap:constructor - 类在实例化时,用来注入结果到构造方法中idArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能arg - 注入到构造方法的一个普通结果id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能result – 注入到字段或 JavaBean 属性的普通结果association – 一个复杂的类型关联;许多结果将包成这种类型嵌入结果映射 – 结果映射自身的关联,或者参考一个collection – 复杂类型的集嵌入结果映射 – 结果映射自身的集,或者参考一个discriminator – 使用结果值来决定使用哪个结果映射case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 描述描述 id 当前命名空间中的一个唯一标识，用于标识一个result map. type 类的全限定名, 或者一个类型别名 autoMapping 如果设置这个属性，MyBatis将会为这个ResultMap开启或者关闭自动映射。这个属性会覆盖全局的属性autoMappingBehavior。默认值为：unset。 下面是一个例子： 12345678910111213141516171819202122&lt;!--StudentMapper.xml--&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xzy.mapper.StudentMapper\"&gt; &lt;!--第一种多表联查的映射方式--&gt; &lt;resultMap type=\"student\" id=\"queryCName\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"sid\" column=\"sid\"/&gt; &lt;result property=\"sname\" column=\"sname\"/&gt; &lt;result property=\"majorIn\" column=\"major_in\"/&gt; &lt;result property=\"sclass\" column=\"sclass\"/&gt; &lt;result property=\"course.cname\" column=\"cname\"/&gt; &lt;/resultMap&gt; &lt;!--查询某个同学所选的课程--&gt; &lt;select id=\"getAll\" parameterType=\"string\" resultMap=\"queryCName\"&gt; select student.*,course.cname from student,course where student.cid=course.cid and student.sname=#&#123;sname&#125; &lt;/select&gt;&lt;/mapper&gt; 学生实体：Student.java 123456789101112131415161718192021222324252627//JavaBean Studentpackage com.xzy.bean;public class Student &#123; private Long id; private String sid; private String sname; private String majorIn; private String sclass; private Course course; //getter、setter... @Override public String toString() &#123; return \"Student&#123;\" + \"id=\" + id + \", sid='\" + sid + '\\'' + \", sname='\" + sname + '\\'' + \", majorIn='\" + majorIn + '\\'' + \", sclass='\" + sclass + '\\'' + \", cname=\" + course.getCname() + '&#125;'; &#125;&#125; 课程实体:Course.java 1234567891011121314151617181920//JavaBean Coursepackage com.xzy.bean;public class Course &#123; private Long id; private String cid; private String cname; private Student student; //省略getter、setter..... @Override public String toString() &#123; return \"Course&#123;\" + \"id=\" + id + \", cid='\" + cid + '\\'' + \", cname='\" + cname + '\\'' + '&#125;'; &#125;&#125; 测试类AppTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.xzy;import com.xzy.bean.Course;import com.xzy.bean.Student;import com.xzy.mapper.CourseMapper;import com.xzy.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;import java.util.Scanner;/** * Unit test for simple App. */public class AppTest &#123; private static Logger log = Logger.getLogger(AppTest.class); private static SqlSessionFactory sqlSessionFactory; @Before public void initLoad() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void selectAll() &#123; SqlSession session = sqlSessionFactory.openSession(true); try&#123; StudentMapper sm=session.getMapper(StudentMapper.class); List&lt;Student&gt; lists= sm.getAll(\"OKOK2\"); if(null!=lists&amp;&amp;lists.size()&gt;0) &#123; System.out.println(\"OKOK2同学选的课：\"); for (Student list : lists) &#123; System.out.println(list.toString()); &#125; System.out.println(\"OK...\"); &#125;else&#123; System.out.println(\"没有这个人或该同学没有选课....\"); &#125; &#125;catch (Exception e)&#123; System.out.println(\"查询失败。。。。\"); &#125;finally&#123; session.close(); &#125; &#125;&#125; 运行结果： cache 和cache-ref 的用法参考另一篇笔记MyBatis缓存配置","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"Mybatis 动态SQL","date":"2019-07-26T10:25:09.000Z","path":"2019/07/26/Mybatis动态SQL/","text":"&nbsp;&nbsp;&nbsp;&nbsp;MyBatis 的强大特性之一便是它的动态 SQL。动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。主要的有以下几个： if choose (when, otherwise) trim (where, set) liforeach if使用if可以用条件的筛选SQL语句分支，只有条件满足的时候才会执行。实例： 12345678&lt;select id=\"get\" resultType=\"Employee\"&gt; select * from employee &lt;where&gt; &lt;if test=\"empSex!=null\"&gt;and emp_sex=#&#123;empSex&#125; &lt;/if&gt; &lt;if test=\"empAge!=null\"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test=\"empName!=null\"&gt;or emp_name=#&#123;empName&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这条sql语句就会动态的根据传入的参数值来查询，比如当只传了empAge=23，其他都为空，那么生成的sql语句就是：select * from employee where emp_age=23，where元素是很强大的，他会自动帮我们把sql中多余的and或or去掉 choose、when、otherwiseMyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。实例; 12345678910&lt;!--下面的条件分支中只会有一条被执行--&gt;&lt;select id=\"getBycondition\" resultType=\"Employee\"&gt;select * from employee where&lt;choose&gt; &lt;when test=\"empId!=null\"&gt;emp_id=#&#123;empId&#125;&lt;/when&gt; &lt;when test=\"empAge!=null\"&gt;emp_age=#&#123;empAge&#125;&lt;/when&gt; &lt;when test=\"empName!=null\"&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;otherwise&gt;emp_sex='女'&lt;/otherwise&gt;&lt;/choose&gt;&lt;/select&gt; java代码这么写： 123456789101112131415161718192021222324252627282930313233public class AppTest&#123;SqlSessionFactory sqlSessionFactory;private static final Logger log=Logger.getLogger(AppTest.class);@Beforepublic void createSqlSession() throws IOException &#123;String resource=\"mybatis-config.xml\";try (InputStream inputStream = Resources.getResourceAsStream(resource)) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125;&#125;@Testpublic void get2()&#123;SqlSession session=sqlSessionFactory.openSession(true);try&#123; Employee employee=new Employee(); employee.setEmpAge(34); employee.setEmpId(\"3343\"); EmployeeMapper mapper=session.getMapper(EmployeeMapper.class); List&lt;Employee&gt;lists=mapper.getBycondition(employee); for(Employee list:lists)&#123; System.out.println(list.toString()); &#125; log.info(mapper);&#125;catch (Exception e)&#123; System.out.println(\"查询数据异常...\"+e); session.rollback();&#125;finally &#123; session.close();&#125;&#125;&#125; 可以看到，即使在条件中给了两个不为空的，但是由于EmpId在最前面，因此首先匹配上后就不在往下找了，和switch很像。最终的运行结果： trim, where看看下面的这条这种情况： 123456&lt;select id=\"getEmp\" resultType=\"Employee\"&gt; select * from employee where &lt;if test=\"empAge!=null\"&gt;emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test=\"empAge!=null\"&gt; and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test=\"empAge!=null\"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt;&lt;/selsct&gt; 如果三个分之没有一条分支匹配上，那么最终的sql语句会变成： 1select * from employee where 这显然是会导致查询失败的。如果仅仅第二条或第三条匹配，那么sql语句会变成这样: 123select * from employee where and emp_age=#&#123;empAge&#125;/*或者是下面的样子*/select * from employee where and emp_age=#&#123;empAge&#125; 不论是那种情况，都会导致由于sql语句错误而查询失败。MyBatis 有一个简单的处理，这在90%的情况下都会有用。那就是使用where元素，where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。例如： 12345678&lt;select id=\"getEmp\" resultType=\"Employee\"&gt; select * from employee &lt;where&gt; &lt;if test=\"empAge!=null\"&gt;emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test=\"empAge!=null\"&gt; and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test=\"empAge!=null\"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;/where&gt;&lt;/selsct&gt; &nbsp;&nbsp;&nbsp;&nbsp;这样即使三条语句都不满足条件，那么最终的sql语句是：select * from employee，也不会影响正常的查询。 &nbsp;&nbsp;&nbsp;&nbsp;如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \"&gt; ... &lt;/trim&gt; &nbsp;&nbsp;&nbsp;&nbsp;prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的. set&nbsp;&nbsp;&nbsp;&nbsp;set用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的.示例： 123456789101112131415161718&lt;update id=\"updateByConditon\"&gt;update employee&lt;set&gt; &lt;if test=\"param1.empId!=null\"&gt; emp_id=#&#123;param1.empId&#125;, &lt;/if&gt; &lt;if test=\"param1.empName!=null\"&gt; emp_name=#&#123;param1.empName&#125;, &lt;/if&gt; &lt;if test=\"param1.empSex!=null\"&gt; emp_sex=#&#123;param1.empSex&#125;, &lt;/if&gt; &lt;if test=\"param1.empAge!=null\"&gt; emp_age=#&#123;param1.empAge&#125; &lt;/if&gt;&lt;/set&gt;where emp_age=#&#123;param2&#125;&lt;/update&gt; java代码： 123456789101112131415 @Testpublic void updateByConditon()&#123; SqlSession session=sqlSessionFactory.openSession(true); try&#123; EmployeeMapper em=session.getMapper(EmployeeMapper.class); List&lt;Employee&gt; lists=em.getAll(); for(Employee list:lists)&#123; list.setEmpName(\"蔡徐坤\"); em.updateByConditon(list,22); &#125; log.info(em); &#125;finally &#123; session.close(); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号 foreach&nbsp;&nbsp;&nbsp;&nbsp;动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 in 条件语句的时候: 1234567&lt;select id=\"selectPostIn\" resultType=\"Employee\"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach collection=\"lists\" item=\"list\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;list&#125; &lt;/foreach&gt;&lt;/select&gt; foreach标签中可以使用的属性如下：1. collection ：collection属性的值有三个分别是list、array、map三种，分别对应的java类型为：List、数组、map集合2. item ： 表示在迭代过程中每一个元素的别名3. index ：遍历过程的索引值4. open ：前缀5. close ：后缀6. separator ：分隔符，表示迭代时每个元素之间以什么分隔7. foreach标签主要用于构建in条件，他可以在sql中对集合进行迭代。","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"Mybatis 全局XML文件的配置","date":"2019-07-26T10:24:53.000Z","path":"2019/07/26/Mybatis全局XML文件的配置/","text":"properties properties提供了一个通过外部配置文件(例如数据库配置文件)来动态配置环境的方法。以动态配置数据库为例： 数据库配置文件jdbc.properties的详细配置如下： 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/xust?autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;set global time_zone=&apos;+8:00&apos; username=rootpassword=95162437 那么我们可以在mybatis-config.xml中这么写： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--配置外部数据库文件的位置，把它加载进来--&gt; &lt;properties resource=\"jdbc.properties\"&gt; &lt;/properties&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--通过在外部动态配置的方式来配置--&gt; &lt;!--需要注意的是value后面的值如果没有自定义，必须和外部配置文件中的名字一致--&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/StudentMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; settingssetting可以调整MyBatis的一些分长重要的配置，它们会改变 MyBatis 的运行时的行为，具体都有哪些配置可以设置可以参考官网，这里不再赘述，这里说几个常用的： 设置参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。 true | false false mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true | false false logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING Not set logPrefix 指定 MyBatis 增加到日志名称的前缀。 Any String Not set L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/wanko.model.json\"},\"display\":{\"position\":\"left\",\"width\":150,\"height\":300},\"mobile\":{\"show\":false},\"log\":false});!function(e){var r=Array.prototype.slice.call(document.querySelectorAll(\"img[data-original]\"));function t(){for(var c=0;c","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]},{"title":"认识MyBatis","date":"2019-07-25T10:27:20.000Z","path":"2019/07/25/认识Mybatis/","text":"什么是MyBatis?MyBatis 是一款优秀的java持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis的历史原是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation 迁移到了Google Code，随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis ，代码于2013年11月迁移到Github（下载地址见后）。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO） 为什么要使用MyBatis? MyBatis是一个半自动化的持久化层框架。 JDBC的不足： -SQL夹在Java代码块里，耦合度高导致硬编码内伤 -维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 Hibernate和JPA -长难复杂SQL，对于Hibernate而言处理也不容易 -内部自动生产的SQL，不容易做特殊优化。 -基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 对开发人员而言，核心sql还是需要自己优化 sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。 去哪里找MyBatis?MyBatis：https://github.com/mybatis/mybatis-3 简单的配置让MyBatis跑起来创建Maven项目在IDEA中打开【File】->【New】->【New Project】,然后选择【Maven】，创建一个【webapp】工程，如图所示 填写【GroupId】和【ArtifactId】,填好后点击【Next】 完成上面的操作后，等待片刻，一个基于Maven的基本结构就创建完成了，得到的Maven项目的目录结构如下图： 打开Mavne项目的pom.xml配置文件，向文件中添加MyBatis依赖、数据库JDBC驱动和Log4j等依赖 1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;!--mybatis的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;!--数据库驱动的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt;&lt;!--日志记录--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 完成以上操作后，MyBatis的基本开发环境就已经搭建好了，接下来我们开始实现衣蛾简单的查询功能。 准备数据库创建Student表 123456create table student( sid varchar(255) primary key not null, sname varchar(255) not null, major_in varchar(255), sclass varchar(255) ); 创建实体类和Mapper文件在【main】下新建一个文件夹【java】,并标记为【Source Root】，然后在src/main/java下新建一个基础包com.xzy,在这个包下在创建一个beans包，在这个包中创建一个实体类Student,代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.xzy.beans;import java.io.Serializable;public class Student implements Serializable &#123; private String sid; private String sname; private String majorIn; private String sclass; public Student()&#123; &#125; public String getSid() &#123; return sid; &#125; public void setSid(String sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getMajorIn() &#123; return majorIn; &#125; public void setMajorIn(String majorIn) &#123; this.majorIn = majorIn; &#125; public String getSclass() &#123; return sclass; &#125; public void setSclass(String sclass) &#123; this.sclass = sclass; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"sid='\" + sid + '\\'' + \", sname='\" + sname + '\\'' + \", major_in='\" + majorIn + '\\'' + \", sclass='\" + sclass + '\\'' + '&#125;'; &#125;&#125; 再在【com.xzy】包下新建一个包【dao.mapper】,在里面新建一个接口StudentMapper 1234567891011package com.xzy.dao.mapper;import com.xzy.beans.Student;import java.util.List;public interface StudentMapper &#123; public List&lt;Student&gt; getAll();&#125; 在【main】下新建一个文件夹【resoources】,并标记为【Resources Root】,然后在src/main/resources下创建目录【mapper】,在mapper目录中创建StudentMapper.xml文件，添加如下内容： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.xzy.dao.mapper.StudentMapper\"&gt; &lt;!--查询学生表中的所有学生--&gt; &lt;select id=\"getAll\" resultType=\"com.xzy.beans.Student\"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 配置MyBatisMyBatis有多种配置方式，这里使用最基础最常用的XML配置方式。首先在【src/main/resources】下创建【MyBatis-config.xml】文件，输入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"jdbc.properties\"&gt; &lt;/properties&gt; &lt;!--一些有关于mybatis运行是行为的设置--&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--设置数据库字段的下换线自动映射到java的驼峰模式--&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt; &lt;/settings&gt; &lt;!--配置数据库连接，可以配置多个数据库--&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!--通过在外部动态配置的方式来配置--&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/StudentMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 上面的配置文件中需要一个jdbbc.properties的配置文件，同样在【src/main/resources】下新建jdbc,properties文件 ，然后输入如下内容： 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/xust?autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;set global time_zone='+8:00' username=rootpassword=123456 配置Log4j一遍查看MyBatis操作数据库的过程在src/main/resources中添加log4j.properties配置文件，输入一下内容： 123456789101112131415161718192021222324### set log levels ### log4j.rootLogger = DEBUG , console , debug , error ### console ### log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n ### log file ### log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.File = redcmsv6.log log4j.appender.debug.Append = true log4j.appender.debug.Threshold = INFO log4j.appender.debug.layout = org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n ### exception ### log4j.appender.error = org.apache.log4j.DailyRollingFileAppender log4j.appender.error.File = redcms.log log4j.appender.error.Append = true log4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayout log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\\:mm\\:ss&#125; [%p]-[%c] %m%n 编写测试代码然MyBatis跑起来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package test;import java.io.IOException;import java.io.InputStream;import java.util.List;import com.xzy.beans.Student;import com.xzy.dao.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;/** * Unit test for simple App. */public class AppTest&#123; SqlSessionFactory sqlSessionFactory; @Before public void before() &#123; try &#123; String resource = \"MyBatis-CONFIG.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testselectAll()&#123; SqlSession session=sqlSessionFactory.openSession(); //接口 try &#123; StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;Student&gt; stus = sm.getAll(); for (Student stu : stus) System.out.println(stu.toString()); System.out.println(\"Ok\"); &#125;finally &#123; session.close(); &#125; &#125;&#125; 测试结果：","tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://easyblog.top/tags/MyBatis/"}]}]