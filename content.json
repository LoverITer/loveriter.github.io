[{"title":"SpringMVC视图解析","date":"2019-08-07T06:41:44.000Z","path":"2019/08/07/SpringMVC视图解析/","text":"SpringMVC视图解析 &nbsp; &nbsp; &nbsp;对于控制器的目标方法，无论其返回值是String、View、ModelMap或是ModelAndView，SpringMVC都会在内部将它们封装为一个ModelAndView对象进行返回。 &nbsp; &nbsp; &nbsp; Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是JSP也可是Excell、 JFreeChart等各种表现形式的视图。 视图（View） 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。 为了实现视图模型和具体实现技术的解耦，Spring在org.springframework.web.servlet包中定义了一个高度抽象的View接口。 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题。所谓视图是无状态的，是指对于每一个请求，都会创建一个View对象。 JSP是最常见的视图技术。 视图解析器（ViewResolver）和视图（View） springMVC用于处理视图最重要的两个接口是ViewResolver和View。 所以视图解析器的作用就是通过视图名（处理方法的返回值）生成View对象，所有的视图解析器都必须实现ViewResolver接口。 SpringMVC为逻辑视图名的解析提供了不同的策略，可以在Spring WEB上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。程序员可以选择一种视图解析器或混用多种视图解析器。可以通过order属性指定解析器的优先顺序，order越小优先级越高，SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则抛出ServletException异常。在项目中可以配置InternalResourceViewResolver作为视图解析器,在springmvc.xml中可以做如下配置： 12345&lt;!--配置视图解析器--&gt;&lt;bean id=\"viewHandler\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"WEB-INF/pages/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt; forward: 和redirect:一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理，会经过视图解析器拼串，但如果返回的字符串中带forward:或redirect:前缀时，SpringMVC会对它们进行特殊处理：将forward: 和redirect: 当成指示符，其后的字符串作为URL 来处理。示例如下：index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href=\"handler1\"&gt;handler1&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler2\"&gt;handler2&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler3\"&gt;handler3&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler4\"&gt;handler4&lt;/a&gt;&lt;br/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; hello.jsp，在当前项目的根路径下，和index.html同级 1234567891011&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;这是hello.jsp&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ViewTestController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xzy.Contorller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ViewTestController &#123; /** * handler1把请求转发到hello.jsp页面 * @return */ @RequestMapping(\"/handler1\") public String handler1()&#123; System.out.println(\"handler1\"); return \"forward:/hello.jsp\"; &#125; /** * handler把请求转发给handler1 * @return */ @RequestMapping(\"/handler2\") public String handler2()&#123; System.out.println(\"handler2\"); return \"forward:handler1\"; &#125; /** * 重定向到hello.jsp * @return */ @RequestMapping(\"/handler3\") public String handler3()&#123; System.out.println(\"handler3\"); return \"redirect:/hello.jsp\"; &#125; /** * 重定向到handler3 * @return */ @RequestMapping(\"/handler4\") public String handler4()&#123; System.out.println(\"handler4\"); return \"redirect:handler3\"; &#125;&#125; 测试结果: 按F12打开开发者工具，可以看到确实两次重定向 SpringMVC视图的解析流程(结合源码分析) 源码中把任何返回返回值封装为ModelAndView的实现：123456789101112131415161718192021222324 protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; this.checkRequest(request); ModelAndView mav; if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized(mutex) &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; if(!response.containsHeader(\"Cache-Control\")) &#123;if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; this.applyCacheSeconds(response,this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; this.prepareResponse(response); &#125; &#125; return mav; &#125; 这里以发出了一个GET请求为例：首先FrameworkServlet类会来处理这个GET请求doGet 123protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.processRequest(request, response); &#125; processRequest 123456789101112131415protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //省略..... try &#123; //它本类中的这个方法是个抽象方法，实现这个方法的类是DispatcherServlet this.doService(request, response); &#125; catch (IOException | ServletException var16) &#123; failureCause = var16; throw var16; &#125; catch (Throwable var17) &#123; //省略.....var17); &#125; finally &#123; //省略..... &#125; &#125; DispatcherServlet 类doService方法 12345678910111213protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略..... //给request域中设置了一些东西 try &#123; //调用doDispatch方法处理 this.doDispatch(request, response); &#125; finally &#123; ...... &#125; &#125; doDispatch方法 12345protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... this.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); //省略...... &#125; processDispatchResult方法,这个方法就是最终将数据交给页面的方法 12345678910111213141516171819202122232425 private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; //如果这里出现了异常就处理异常 if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123;this.logger.debug(\"ModelAndViewDefiningException encountered\", exception); mv = ((ModelAndViewDefiningException)exception).getModelAndView(); &#125; else &#123; Object handler = mappedHandler != null ? mappedHandler.getHandler() : null; //如果自己配置了自定义的HandlerExceptionResolver将会在这个方法里处理 mv = this.processHandlerException(request, response, handler, exception); errorView = mv != null; &#125; &#125; if (mv != null &amp;&amp; !mv.wasCleared()) &#123; //调用render方法进行视图渲染 this.render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else if (this.logger.isTraceEnabled()) &#123; this.logger.trace(\"No view rendering, null ModelAndView returned.\"); &#125; //省略...... &#125; DispatcherServlet 类 的render方法并没有继承View接口的render,和View接口的render不是一回事，这个render仅仅是为了命名统一而起的一个名字 123456789101112131415161718192021222324252627protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... //从ModelView中拿到视图名 String viewName = mv.getViewName(); View view; if (viewName != null) &#123; //这一步就是得到一个View对象，resolveViewName的实现看下边 view = this.resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(\"Could not resolve view with name '\" + mv.getViewName() + \"' in servlet with name '\" + this.getServletName() + \"'\"); &#125; &#125; else &#123; view = mv.getView(); if (view == null) &#123; throw new ServletException(\"ModelAndView [\" + mv + \"] neither contains a view name nor a View object in servlet with name '\" + this.getServletName() + \"'\"); &#125; &#125; //省略...... try &#123; //省略...... //调用了View接口的render方法，这里实际上调用的是视图在渲染时会把Model传入 view.render(mv.getModelInternal(), request, response); &#125; catch (Exception var8) &#123; //省略...... &#125;&#125; resolveViewName方法，循环遍历你配置的视图解析器，viewResolvers是进过order排序的，这一步就是ViewResolvers是如何通过视图名产生View对象的关键 1234567891011protected View resolveViewName(String viewName,Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; //遍历我们配置的视图解析器 for (ViewResolver viewResolver : this.viewResolvers) &#123; //ViewResolver根据方法的返回值，得到一个View对象，这块又有一个resolveViewName，具体的实现请往下看 View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; return null;&#125; InternalResourceViewResolver继承了AbstractCachingViewResolver，resolveViewName方法首先会判断有没有缓存，要是有缓存，它会先去缓存中通过viewName查找是否有View对象的存在，要是没有，它会通过viewName创建一个新的View对象，并将View对象存入缓存中，这样再次遇到同样的视图名的时候就可以直接在缓存中取出View对象了 12345678910111213141516171819202122232425262728293031@Overridepublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; //判断有缓存中有没有view对象，有就直接拿来用 if (!isCache()) &#123; return createView(viewName, locale); &#125; else &#123; Object cacheKey = getCacheKey(viewName, locale); View view = this.viewAccessCache.get(cacheKey); if (view == null) &#123; synchronized (this.viewCreationCache) &#123; view = this.viewCreationCache.get(cacheKey); if (view == null) &#123; //根据方法的返回值创建出View对象 view = createView(viewName, locale); if (view == null &amp;&amp; this.cacheUnresolved) &#123; view = UNRESOLVED_VIEW; &#125; if (view != null) &#123; this.viewAccessCache.put(cacheKey, view); this.viewCreationCache.put(cacheKey, view); if (logger.isTraceEnabled()) &#123; logger.trace(\"Cached view [\" + cacheKey + \"]\"); &#125; &#125; &#125; &#125; &#125; return (view != UNRESOLVED_VIEW ? view : null); &#125;&#125; createView的实现细节： 12345678910111213141516171819202122232425protected View createView(String viewName, Locale locale) throws Exception &#123; if (!this.canHandle(viewName, locale)) &#123; return null; &#125; else &#123; String forwardUrl; //如果方法得到返回值是以redirect：开始的 if (viewName.startsWith(\"redirect:\")) &#123; forwardUrl = viewName.substring(\"redirect:\".length()); RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible()); String[] hosts = this.getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return this.applyLifecycleMethods(\"redirect:\", view); //如果方法的返回值是以forward:开始的 &#125; else if (viewName.startsWith(\"forward:\")) &#123; forwardUrl = viewName.substring(\"forward:\".length()); InternalResourceView view = new InternalResourceView(forwardUrl); return this.applyLifecycleMethods(\"forward:\", view); &#125; else &#123; //其他情况的处理,这里又有一个createView，它调用了父类的createView创建了一个默认的View对象 return super.createView(viewName, locale); &#125; &#125;&#125; 以下都是解析视图名的实现细节，感兴趣的可以看一下。 父类AbstractCachingViewResolver类的createView实现细节： 123protected View createView(String viewName, Locale locale) throws Exception &#123; return loadView(viewName, locale);&#125; InternalResourceViewResolver继承了UrlBasedViewResolverUrlBasedViewResolver类中loadView方法的实现： 12345protected View loadView(String viewName, Locale locale) throws Exception &#123; AbstractUrlBasedView view = buildView(viewName); View result = applyLifecycleMethods(viewName, view); return (view.checkResource(locale) ? result : null); &#125; UrlBasedViewResolver的buildView方法会获取一个View对象，这个对象会将视图以什么格式呈现给用户，例如如果是jsp显示呈现给用户的话，那这个view对象就是JstlView，默认的是JstlView。在这个方法中我们看到了getPrefix() + viewName + getSuffix()这样一段代码，这就是对视图路径的一个拼接了，getPrefix()方法获取前缀，也就是我们在配置文件中配置的&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/PAGE/&quot;/&gt;的value中的值了,getSuffix()方法就是获取后缀值了，也就是我们在配置文件中配置的&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;的value中的值。这样就将将视图的物理路径找到了，并赋值到View的URL属性中去。 123456789101112131415161718192021222324252627protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; Class&lt;?&gt; viewClass = this.getViewClass(); Assert.state(viewClass != null, \"No view class\"); AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(viewClass); view.setUrl(this.getPrefix() + viewName + this.getSuffix()); String contentType = this.getContentType(); if (contentType != null) &#123; view.setContentType(contentType); &#125; view.setRequestContextAttribute(this.getRequestContextAttribute()); view.setAttributesMap(this.getAttributesMap()); Boolean exposePathVariables = this.getExposePathVariables(); if (exposePathVariables != null) &#123; view.setExposePathVariables(exposePathVariables); &#125; Boolean exposeContextBeansAsAttributes = this.getExposeContextBeansAsAttributes(); if (exposeContextBeansAsAttributes != null) &#123; view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes); &#125; String[] exposedContextBeanNames = this.getExposedContextBeanNames(); if (exposedContextBeanNames != null) &#123; view.setExposedContextBeanNames(exposedContextBeanNames); &#125; return view;&#125; 就这样我们得到了一个View对象，这个视图的name就是逻辑视图名，因为当将View对象放在缓存的时候，我们可以通过逻辑视图名在缓存中找出View对象。我们在获取到View对象的时候，我们还要将View进行渲染，并呈现给用户。 View是个接口,AbstractView实现了render方法: 1234567891011public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"View \" + this.formatViewName() + \", model \" + (model != null ? model : Collections.emptyMap()) + (this.staticAttributes.isEmpty() ? \"\" : \", static attributes \" + this.staticAttributes)); &#125; //主要是将一些属性填充到Map中 Map&lt;String, Object&gt; mergedModel = this.createMergedOutputModel(model, request, response); //对response头进行了一些属性设置 this.prepareResponse(request, response); //渲染给页面输出的所有model数据 this.renderMergedOutputModel(mergedModel, this.getRequestToExpose(request), response);&#125; 最后一行的renderMergedOutputModel方法由AbstractView的孙子类InternalResourceView实现InternalResourceView的renderMergedOutputModel方法帮我们获取到视图的物理路径，然后将这段路径传给RequestDispatcher对象，再调用RequestDispatcher的forward方法将页面呈现给用户，这样就走完了视图的解析了。 12345678910111213141516171819202122232425262728293031@Overrideprotected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(\"Could not get RequestDispatcher for [\" + getUrl() + \"]: Check that the corresponding file exists within your web application archive!\"); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(\"Including resource [\" + getUrl() + \"] in InternalResourceView '\" + getBeanName() + \"'\"); &#125; rd.include(request, response); &#125;else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(\"Forwarding to resource [\" + getUrl() + \"] in InternalResourceView '\" + getBeanName() + \"'\"); &#125; //对请求进行转发，至此结束了视图解析解析过程 rd.forward(request, response); &#125;&#125; 最后一句话总结：视图解析器只是为了得到视图对象；视图对象才是真正的转发（将模型数据发在request域中数据）或重定向到页面（视图对象才是真正的渲染视图）。","tags":[{"name":"SpringMVC基础","slug":"SpringMVC基础","permalink":"http://easyblog.top/tags/SpringMVC基础/"}]},{"title":"SpringMVC处理模型参数","date":"2019-08-07T06:14:42.000Z","path":"2019/08/07/SpringMVC-处理模型参数/","text":"SpringMVC 提供了以下几种途径输出模型数据: ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据 Map、Model以及ModelMap:入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 Java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中。 @SessionAttributes: 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性 @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中。 当然，除了上面这些SpringMVC提供的几种方法，SpringMVC支持直接使用Servlet几个原生API来给页面传值: HttpServletRequest request、HttpservletResponse response、HttpSession session、InputStream/Reader 对应request.getInputStream()、OutputStream/Writer 对应response.getOutputStram() servlet原生API给页面传值123456789101112131415/** * 使用servlet原生API给页面输出数据 * @param request * @param session * @return */ @RequestMapping(\"handler01\") public String handler01(HttpServletRequest request, HttpSession session) throws IOException &#123; request.setAttribute(\"msg\",\"你好，这是HelloController\"); session.setAttribute(\"msg\",\"json123\"); return \"success\"; &#125; 页面测试代码:success.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;table border=\"1px\" width=\"70%\" &gt; &lt;tr&gt; &lt;th&gt;域&lt;/th&gt; &lt;th&gt;值&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;requestScope&lt;/th&gt; &lt;td&gt;$&#123;requestScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;applicationScope&lt;/th&gt; &lt;td&gt;$&#123;applicationScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;pageScope&lt;/th&gt; &lt;td&gt;$&#123;pageScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： Model、Map、ModelMap首先通过通过源码看看他们三者的关系：ModelMap类 Model接口 ExtendModelMap类 BindingAwareModelMap类 通过打开源码，我们不难总结出如下继承关系 ： 接下来看看他们的用法：示例代码 123456789101112131415161718192021222324252627282930313233343536373839/** * 使用Model * @param model * @return */ @RequestMapping(\"/handler02\") public String handler02(Model model)&#123; System.out.println(\"Model\"+model.getClass()); model.addAttribute(\"msg\",\"大家好！这是handler02\"); model.addAttribute(\"id\",18); return \"success\"; &#125; /** * 使用Map * @param map * @return */ @RequestMapping(\"/handler03\") public String handler03(Map&lt;String,String&gt; map)&#123; System.out.println(\"Map:\"+map.getClass()); map.put(\"msg\",\"handler03\"); map.put(\"logged\",\"admin\"); return \"success\"; &#125; /** * 使用ModelMap * @param modelMap * @return */ @RequestMapping(\"/handler04\") public String handler04(ModelMap modelMap)&#123; System.out.println(\"ModelMap:\"+modelMap.getClass()); modelMap.addAttribute(\"msg\",\"handler04\"); return \"success\"; &#125; 页面代码和上面样 测试结果：页面的显示： 控制台打印的信息: 从测试结果可以总结出：Model(SpringMVC接口)其中一个实现类是ExtendedModelMapModelMap是Map(JDK的接口)Map的一个实现类,并且ModelMap被ExtendedModelMapExtendedModelMap被BindingAwareModelMap继承Model、Map、ModelMap不论用哪个，最终工作的都是BindingAwareModelMap,而且从测试结果可以看到通过这三个设置的值，SpringMVC都把他们放在了request域中。 ModelAndView 目标方法的返回值可以是ModelAndView类型，从名字上就可以看到，这是一个既包括模型(Model)又有视图(View)的一个类， 然而事实也确实如此，他的model就可以理解为送给页面的数据，他的View可以理解为目标页面地址。但我们在他的model中放入值后，SpringMVC会把ModelAndView的model中数据放在request域对象中。 示例代码 123456789101112 /** * 方法的返回值可以是 ModelAndView类型，这样我们可以把值设置在model中 * 然后springmvc会把ModelAndView的model中数据放在request域对象中 * @return */@RequestMapping(\"/handler05\")public ModelAndView handler05()&#123; ModelAndView mv=new ModelAndView(\"success\"); mv.addObject(\"msg\",\"handler05\"); return mv;&#125; 测试结果： 使用@SessionAttributes注解如果希望在多个请求之间共用某个模型属性数据，则可以在控制器类标注一个 @SessionAttributes，SpringMVC 会将模型中对应的属性暂存到 HTTPSession 中。@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中。 @SessionAttributes(types=User.class)会将隐含模型中所有类型为 User 的属性添加到会话中 @SessionAttributes(value={“user1”, “user2”})将名为 user1 和 user2 的模型属性添加到会话中 @SessionAttributes(types={“User.class”, “Dept.class”})将模型中所有类型为 User 及 Dept 的属性添加到会话中 @SessionAtributes(value={“user1”, “user2”}, types={Dept.class})将名为 user1 和 user2 的模型属性添加到会话中，同时将所有类型为 Dept 的模型属性添加到会话中总之：当使用@SessionAttributes注解时就是告诉SpringMVC,当@SessionAttributes中的value值和BindingAwareModelMap的key一样时，那么在session也你也给我保存一份相同的值示例代码：1234567891011121314//使用的时候一定要注意@SessionAttributes只能用在类上@SessionAttributes(value=&#123;\"id\",\"logged\"&#125;)@Controllerpublic class HelloController &#123; @RequestMapping(\"/handler0\") public String sessionAttributesTest(Model model)&#123; model.addAttribute(\"msg\",\"handler0\"); //这个会在request中显示 model.addAttribute(\"logged\",new Date()); //会在session中显示 model.addAttribute(\"id\",\"001\"); //会在session中显示 return \"success\"; &#125;&#125; 页面代码对success.jsp中的sessionScope稍作修改： 1234 &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125; | $&#123;sessionScope.id&#125; |$&#123;sessionScope.logged&#125;&lt;/td&gt;&lt;/tr&gt; 测试结果： 使用@ModelAttribute注解先来看看ModelAttribute的定义：查看 @ModelAttribute注解定义可以看到这个注解可以用在方法和参数中。 在 SpringMVC 的 Controller 中使用 @ModelAttribute 时，应用情况包括下面几种：1、应用在方法上。2、应用在方法的参数上。3、应用在方法上，并且方法也使用了@RequestMapping 示例代码：修改图书信息的页面： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;!-- &lt;a href=\"handler01\"&gt;原生API输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler02\"&gt;Model输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler03\"&gt;Map输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler04\"&gt;ModelMap输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href=\"handler05\"&gt;ModelAndView带回返回值&lt;/a&gt;&lt;br/&gt;--&gt; &lt;h3&gt;更新图书信息&lt;/h3&gt; &lt;form action=\"update\" method=\"post\"&gt; 书名：&lt;label&gt;西游记&lt;/label&gt;&lt;br/&gt; 作者：&lt;label&gt;吴承恩&lt;/label&gt;&lt;br/&gt; 价格：&lt;input type=\"text\" name=\"price\" placeholder=\"输入价格...\"/&gt;&lt;br/&gt; 库存：&lt;input type=\"text\" name=\"stock\" placeholder=\"输入库存...\"/&gt;&lt;br/&gt; 销量：&lt;input type=\"text\" name=\"sales\" placeholder=\"输入销量...\"/&gt;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交图书修改信息后的页面： 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/8/7 Time: 10:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;更新图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style=\"height: 200px;width: 100%\"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border=\"1px\" width=\"50%\"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 如果没有使用@ModelAttribute，那么要更新数据信息，必须要全字段更新，即使你不需要更新的的字段，你也要填写，这显然不和常理，因为如果你不填写这个值，值就会为null。最主要是因为SpringMVC在封装提交的信息的时候只会new一个Book对象，里面的属性的值初始就是null。你没有填写也只会以null存到数据库。不使用@ModelAttribute进行非全字段更新 12345678@Controllerpublic class BookController &#123; @RequestMapping(\"/update\") public String update(Book book)&#123; System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; &#125; 测试结果:页面的显示： 看看控制台的打印信息： 可以看到果然不出预料的出问题了，更新信息后书名和作者的信息没了。这就相当于你更改了一下你的QQ密码，然后你的QQ号没了！这是很可怕的事情。使用@ModelAttribute解决问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class BookController &#123; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中查询图书数据 Book book=new Book(); book.setName(\"西游记\"); book.setPrice(9.98); book.setAuthor(\"吴承恩\"); book.setSales(300); book.setStock(400); System.out.println(\"数据库中查询到Book的信息：\"+book); map.put(\"book\",book); System.out.println(\"ModelAttribute将查询到的图书信息保存起来.......：\"); &#125;&#125; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute(\"book\")，就是告诉SpringMVC，去拿一个key为 * book的值，你不要重新new一个Book对象了，这样做的好处是可以只更改有更新的数据，没有更新的就保持原始值 * @param book * @return */ @RequestMapping(\"/update\") public String update(@ModelAttribute(\"book\") Book book)&#123; System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; 测试结果：页面展示的结果： 控制台打印的信息： 而且从控制台打印的信息来看，被@ModelAttribute标识的方法确实是在处理器方法之前执行了 @Modelattribute的原理废话不多说，直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;/** * @Author: HuangXin * @Date: Created in 10:33 2019/8/7 * @Description: */@Controllerpublic class BookController &#123; private Object obj1; private Object b1; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute(\"book\")，就是告诉SpringMVC，你去拿一个key为book的值， * 你不要重新new一个Book对象了 * @param book * @return */ @RequestMapping(\"/update\") public String update(@ModelAttribute(\"book\") Book book, Map&lt;String,Object&gt; model)&#123; System.out.println(\"处理器方法的map:\"+model.getClass()); System.out.println(\"book==b1=&gt;\"+(book==b1)); System.out.println(\"obj1==model=&gt;\"+(obj1==model)); System.out.println(\"更新图书的信息......页面提交过来的图书信息：\"+book); return \"updateBook\"; &#125; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中拿数据 Book book=new Book(); book.setName(\"西游记\"); book.setPrice(9.98); book.setAuthor(\"吴承恩\"); book.setSales(300); book.setStock(400); System.out.println(\"数据库中查询到Book的信息：\"+book); obj1=map; b1=book; map.put(\"book\",book); System.out.println(\"@ModelAttribute中的map:\"+map.getClass()); System.out.println(\"ModelAttribute将查询到的图书信息保存起来.......：\"); &#125;&#125; 测试结果： 最后总结为一张图：","tags":[{"name":"SpringMVC基础知识","slug":"SpringMVC基础知识","permalink":"http://easyblog.top/tags/SpringMVC基础知识/"}]},{"title":"SpringMVC获取请求参数","date":"2019-08-06T11:24:59.000Z","path":"2019/08/06/Springmvc/","text":"第一种方式：方法的形参上给一个和请求参数同名的参数1.获得普通类型的参数值示例代码 123456789101112131415/** * 第1种获得请求参数的方式：在方法的形参上给一个和请求参数同名的参数， * 之后SpringMVC会帮我们自动注入参数值 * @param username * @param model * @return */@RequestMapping(value = \"/welcome\")public String welcome(String username, Model model)&#123; System.out.println(\"用户名：\"+username); model.addAttribute(\"username\",username); return \"success\";&#125; 2.获得POJO类型的值示例代码：新建Book.java以及Address.java两个POJOBook.java 12345678910111213package com.xzy.bean;public class Book &#123; private String name; private Double price; private Integer stock; //库存 private Integer sales; //销量 private String author; private Address address; //地址 //省略getter、setter方法，并且重写toString()方法&#125; Address.java 123456789package com.xzy.bean;public class Address &#123; private String province; private String county; private String city; //省略getter、setter方法，并且重写toString()方法 写一个简单的表单：index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;SpringMvc获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h3&gt;录入书籍信息&lt;/h3&gt; &lt;form action=\"book\" method=\"post\"&gt; 书名：&lt;input type=\"text\" name=\"name\" placeholder=\"输入书名...\"/&gt;&lt;br/&gt; 作者：&lt;input type=\"text\" name=\"author\" placeholder=\"输入作者...\"/&gt;&lt;br/&gt; 价格：&lt;input type=\"text\" name=\"price\" placeholder=\"输入价格...\"/&gt;&lt;br/&gt; 库存：&lt;input type=\"text\" name=\"stock\" placeholder=\"输入库存...\"/&gt;&lt;br/&gt; 销量：&lt;input type=\"text\" name=\"sales\" placeholder=\"输入销量...\"/&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"address.province\" /&gt;省&amp;nbsp; &lt;input type=\"text\" name=\"address.city\" /&gt;市&amp;nbsp; &lt;input type=\"text\" name=\"address.county\" /&gt;(区/县)&amp;nbsp;&lt;br/&gt; &lt;button type=\"submit\"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交后的页面：book.jsp 12345678910111213141516171819202122232425&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" import=\"com.xzy.bean.*\"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style=\"height: 200px;width: 100%\"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border=\"1px\" width=\"50%\"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;地区&lt;/th&gt;&lt;td&gt;$&#123;book.address&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提供一个控制器：BookContorller.java 1234567891011121314151617181920212223242526package com.xzy.controller;import com.xzy.bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;@Controllerpublic class BookContorller &#123; /** * SprningMVC帮我们自动注入参数到POJO类型中，而且还可以级联注入 * @param book * @param request * @return */ @RequestMapping(\"/book\") public String addbook(Book book, HttpServletRequest request)&#123; //打印得到的book信息 System.out.println(book); request.setAttribute(\"book\",book); return \"book\"; &#125;&#125; 测试结果： 第二种方式：使用Spring提供的注解1. 使用@RequestParam 获取参数分析@RequestParam的源码： 123456789101112131415public @interface RequestParam &#123; //默认值就是它，表示请求参数的key @AliasFor(\"name\") String value() default \"\"; //请求参数的值 @AliasFor(\"value\") String name() default \"\"; //设置这个参数是否必须，required=false表示这个参数不是必须的 boolean required() default true; //参数的默认值 String defaultValue() default \"\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n\"; &#125; 示例代码： 12345678910111213141516171819/** * RequestParam设置获取参数的key为user,required=false表示这个参数不是必须的， * defaultValue是这个参数的默认值 * @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username； * 等价于以前写的： * String user=null!=request.getParameter(\"user\")?request.getParameter(\"user\"):\"\"; * @param username * @param model * @return */@RequestMapping(\"/welcome3\")public String welocme3( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, Model model) &#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"username\", username); return \"success\";&#125; 2.使用@RequestHeader获得请求的头部信息@RequestHeader和@ReuqestParma的实现方式如出一辙，使用方法也基本相同。示例代码1：使用RequestHeader注解获得浏览器的信息 123456789101112131415161718192021/** * @RequestHeader(value = \"User-Agent\",required = false,defaultValue = \"\") String userAgent * 获取请求头中的值，相当于以前写的： * String header=null!=request.getHeader(\"User-Agent\")? request.getHeader(\"User-Agent\"):\"\"; * @param username * @param userAgent * @param model * @return */ @RequestMapping(\"/welcome4\") public String welocme4( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @RequestHeader(value = \"User-Agent\",defaultValue = \"\") String userAgent, Model model) &#123; System.out.println(\"用户名：\" + username); System.out.println(\"User-Agent\"+userAgent); model.addAttribute(\"userAgent\",userAgent); model.addAttribute(\"username\", username); return \"success\"; &#125; 示例代码2：使用RequestHeader注解获取请求头部的Cookie信息 123456789101112131415161718/** * 使用RequestHeader获得请求头中的Cookie的全部信息 * @param username * @param cookie * @param model * @return */ @RequestMapping(\"/welcome5\") public String welocome5( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @RequestHeader(value = \"Cookie\",required = false,defaultValue = \"\") String cookie, Model model)&#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"cookie\",cookie); model.addAttribute(\"username\", username); return \"success\"; &#125; 3.使用CookieValue获得请求头部的JSESSIONID示例代码： 123456789101112131415161718192021/** * 使用SpringMVC提供的@CookieValue注解，可以只获的JSESSIONID的值 * @param username * @param cookie * @param model * @return */ @RequestMapping(\"/welcome6\") public String welocome6( @RequestParam(value = \"user\", required = false, defaultValue = \"\") String username, @CookieValue(value = \"JSESSIONID\" ,required = false,defaultValue = \"\") String cookie, Model model)&#123; System.out.println(\"用户名：\" + username); model.addAttribute(\"cookie\",cookie); model.addAttribute(\"username\", username); System.out.println(\"cookie：\"+cookie); return \"success\"; &#125;","tags":[{"name":"SpringMVC基础知识","slug":"SpringMVC基础知识","permalink":"http://easyblog.top/tags/SpringMVC基础知识/"}]},{"title":"认识Spring框架","date":"2019-08-05T11:24:59.000Z","path":"2019/08/05/认识Spring框架/","text":"Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring：1). Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。2).Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring3).适用范围：任何 Java 应用4).Spring 的根本使命：简化 Java 开发 Spring 中常用术语：框架：是能完成一定功能的半成品。框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 非侵入式设计： 从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 轻量级和重量级： 轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 JavaBean： 即符合 JavaBean 规范的 Java 类 POJO：即 Plain Old Java Objects，简单老式 Java 对象它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 > 注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。 容器： 在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 Spring 的优势低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring能帮我们做什么①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。③.Spring 能非常简单的帮我们管理数据库事务。④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring的框架体系结构： Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 下面介绍这5个部分的jar以及依赖关系 Corecore部分包含4个模块:spring-core：依赖注入IoC与DI的最基本实现spring-beans：Bean工厂与bean的装配spring-context：spring的context上下文即IoC容器spring-expression：spring表达式语言它们的依赖关系 AOPaop部分包含4个模块:spring-aop：面向切面编程spring-aspects：集成AspectJspring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器spring-instrument-tomcat：针对tomcat的instrument实现它们的依赖关系 Data Accessdata access部分包含5个模块spring-jdbc：jdbc的支持spring-tx：事务控制spring-orm：对象关系映射，集成orm框架spring-oxm：对象xml映射spring-jms：java消息服务它们的依赖关系 Webweb部分包含4个模块spring-web：基础web功能，如文件上传spring-webmvc：mvc实现spring-webmvc-portlet：基于portlet的mvc实现spring-struts：与struts的集成，不推荐，spring4不再提供它们的依赖关系 Testtest部分只有一个模块，我将spring-context-support也放在这吧spring-test：spring测试，提供junit与mock测试功能spring-context-support：spring额外支持包，比如邮件服务、视图解析等它们的依赖关系","tags":[{"name":"Spring基础","slug":"Spring基础","permalink":"http://easyblog.top/tags/Spring基础/"}]}]