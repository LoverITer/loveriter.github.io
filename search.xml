<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[力扣：力扣：两两交换链表中的节点]]></title>
    <url>%2F2020%2F01%2F31%2F%E5%8A%9B%E6%89%A3%EF%BC%9A%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.给定 1-&gt;2-&gt;3-&gt;4-&gt;5 ，你应该返回 2-&gt;1-&gt;4-&gt;3-&gt;5. 题解只需要维护3个指针：prev、start和end，prev用于连接前一次交换后的start结点（第一次交换是preHead结点）和后一次交换后的end结点；而start结点和end结点分别表示每次交换前的前一个结点和后一个结点，交换前应该先把前一次交换后的start结点和本次的end结点先连上，不然链表就断了，之后再进行start结点和end结点的交换，他两的交换也是有要求的：先改变start结点的指向，之后再改变end结点的指向，最后交换完成后改变prev指向本次交换后的start结点（变成后一个结点了），以此循环，直到prev所指的结点后面凑不够两个节点了，返回头结点结束。 图 算法思路示意图 12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode preHead=new ListNode(0); preHead.next=head; //用于记录head结点的位置 ListNode prev=preHead; while(prev.next!=null&amp;&amp;prev.next.next!=null)&#123; //分别记录下两个节点的位置 ListNode start=prev.next; ListNode end=prev.next.next; //连接前一次交换的start结点（第一次交换是preHead结点）和后一次交换的end结点 prev.next=end; //交换两个节点:为了防止链断掉应该先交换start指针的指向，之后改变end结点的指向 start.next=end.next; end.next=start; //维护prev准备进行下一次交换:start交换后跑到后面去了 prev=start; &#125; return preHead.next; &#125;&#125; 复杂度分析 时间复杂度：O(N)，其中 N 指的是链表的节点数量。 空间复杂度：O(1)。]]></content>
      <categories>
        <category>LetCode</category>
      </categories>
      <tags>
        <tag>LetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣：合并k个有序链表]]></title>
    <url>%2F2020%2F01%2F30%2F%E5%8A%9B%E6%89%A3%EF%BC%9A%E5%90%88%E5%B9%B6%20k%20%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 题解解法1：两两链表逐一比较这是我首先想到的方法，由于前几天刚做过一个类似的题目：合并两个有序链表。力扣的地址是：https://leetcode-cn.com/problems/merge-two-sorted-lists/ 。所以，此个题启发，把k个链表的合并转换为k-1此两个链表的合并问题，第一次先合并lists[0]和lists[1]，此后用lists[i]和新生成的主链表两两合并，最终成功解决问题，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists==null||lists.length==0)&#123; return null; &#125; if(lists.length==1)&#123; return lists[0]; &#125; ListNode l1=lists[0]; //l1是主链 for(int i=1;i&lt;lists.length;i++)&#123; l1=meregTwoLists(l1,lists[i]); &#125; return l1; &#125; private ListNode meregTwoLists(ListNode l1,ListNode l2)&#123; if(l1==null) return l2; if(l2==null) return l1; ListNode preHead=new ListNode(0); ListNode preNode=preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; preNode.next=l1; l1=l1.next; &#125;else&#123; preNode.next=l2; l2=l2.next; &#125; preNode=preNode.next; &#125; preNode.next=l1==null?l2:l1; return preHead.next; &#125;&#125; 复杂度分析 时间复杂度：O(kN)，其中k 是链表的数目两个链表的合并的时间复杂度是O(m+n)，即O(N)，N=m+n，表示两个合并链表的总长度，k个链表合并的时间复杂度O(kN)。 空间复杂度：O(1)只需要常量级的空间就可以完成合并。 解法2：分治归并解法1的思路简单清晰虽然是可行的，但是它有一个致命的缺陷，有大量的结点被遍历（比较）了多次，实际上我们并不需要对他们遍历多次，我们可以参照归并排序的思想： 将 k 个链表配对并将同一对中的链表合并。 第一轮合并以后，k 个链表被合并成了 k/2个链表，平均长度为2N/k，然后是 k/4个链表，k/8个链表等等。 重复这一过程，直到我们得到了最终的有序链表。因此，我们在每一次配对合并的过程中都会遍历几乎全部 N个节点，并重复这一过程 log2(k) 次 图 分治合并思路图解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; /** *合并k个链表 **/ public ListNode mergeKLists(ListNode[] lists) &#123; int len=lists.length; if(len&lt;1)&#123; return null; &#125; while(len&gt;1)&#123; for(int i=0;i&lt;len/2;i++)&#123; lists[i]=meregTwoLists(lists[i],lists[len-i-1]); &#125; len=(len+1)/2; &#125; return lists[0]; &#125; /** *合并两个链表 **/ private ListNode meregTwoLists(ListNode l1,ListNode l2)&#123; if(l1==null) return l2; if(l2==null) return l1; ListNode preHead=new ListNode(0); ListNode preNode=preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; preNode.next=l1; l1=l1.next; &#125;else&#123; preNode.next=l2; l2=l2.next; &#125; preNode=preNode.next; &#125; preNode.next=l1==null?l2:l1; return preHead.next; &#125;&#125; 复杂度分析： 时间复杂度： O(Nlogk) ，其中k 是链表的数目。我们可以在 O(n)O(n) 的时间内合并两个有序链表，其中 nn 是两个链表中的总节点数。将所有的合并进程加起来，我们可以得到时间复杂度是O(Nlogk)。 空间复杂度：O(1)只需要常量级的空间就可以完成合并。]]></content>
      <categories>
        <category>LetCode</category>
      </categories>
      <tags>
        <tag>LetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置实例—负载均衡]]></title>
    <url>%2F2020%2F01%2F30%2FNginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%E2%80%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[1、Nginx负载均衡配置预期实现效果： 在浏览器地址栏中输入：http://www.123.com ，nginx收到请求后把请求平均分匹配到Linux服务器上监听8080和8081端口的两个tomcat服务器上。 1.1 准备工作（1）首先在host文件中配置域名映射：192.168.92.128 www.123.com（2）准备两个tomcat服务器，分别监听8080和8081端口，并在各自目录下新建一个edu目录，并创建index.html测试页面，配置完成后启动，让两个tomcat跑起来。 1.2 nginx负载均衡配置在nginx的http模块下配置upstream模块，upstream的语法是： 1234upstream 自定义域名&#123; [负载均衡策略;] server xxx.xxx.xxx.xxx:port [weight=xx] [down|backup|max_fails=xx|fail_timeout=xx]l];&#125; 注：[]中的内容是可选的。简单配置如下： 12345678910111213141516171819202122http &#123; #配置负载均衡：默认使用轮询策略 upstream myserver&#123; server 192.168.92.128:8080; server 192.168.92.128:8081; &#125; server &#123; listen 80; server_name 192.168.92.128; charset utf-8; location /&#123; root html; proxy_pass http://myserver; index index.html index.htm; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; error_page 404 /404.html; &#125;&#125; 测试结果在浏览器地址栏中输入www.123.com/edu ,结果和预期一样，nginx让两个tomcat轮询处理请求： 负载均衡配置运行结果 2、upstream模块详解upstream是Nginx中配置负载均衡的关键模块，基本语法： 123upstream 自定义域名&#123; ......&#125; upstream有关的参数如下： server：用于配置反向服务地址和端口，语法：server address [parameters]; weight：权重，语法：weight=number，默认是1 max_conns：语法：max_conns=number，用于限制到代理服务器的同时活动连接的最大数量，默认是0 max_fail：语法：max_fails=number，允许请求失败的次数。经常和fail_timeout参数配合使用。 fail_timeout：语法：fail_timeout=time， 经过max_fails失败后，服务暂停的时间(默认10s) backup： 预留的备份服务器(当其他的节点挂掉，备份服务器启动) down：当前的server暂时不参与负载均衡(不对外提供服务) slow_start：语法：slow_start=time，设置服务器不正常运行时，或者在一段时间后服务器变为不可用时，服务器将其权重从零恢复到指定值的时间。 默认值为零，即禁用慢速启动。 service：语法：service=name，启用DNS SRV记录的解析并设置服务名称。 为了使此参数起作用，必须为服务器指定resolve参数，并指定不带端口号的主机名。 resolve：监视与服务器域名相对应的IP地址的更改，并自动修改upstream配置，而无需重新启动nginx。 配置示例： 1234567upstream myserver&#123; server 192.168.92.128:8080 max_fail=3 fail_timeout=100; server 192.168.92.128:8081 max_fail=3 fail_timeout=100; server 192.168.92.128:8082 backup; #备用服务器 server 192.168.92.128:8083 down; #不参与请求的服务器 server 192.168.92.128:8084 backup max_conns=1000; #备用服务器，当启用后最大连接数是1000&#125; max_fail=3 fail_timeout=100的含义是：当一台服务器在100s内如果出现了3次请求失败，就会报机器的状态设置为down，并且会在100s后尝试重新启用这个服务器。 3、nginx负载均衡调度算法详解Nginx目前支持的调度策略有以下5种： （1）轮询（默认）每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 1234upstream myserver&#123; server 192.168.92.128:8080; server 192.168.92.128:8081;&#125; #####（2）加权轮询指定轮询权重，权重(weight)和访问比率成正比，用于后端服务器性能不均的情况。 123456upstream myserver&#123; #在server语句中加入weight参数指定一个权重就进入到加权轮询模式 #8080获得的请求是8081的2倍 server 192.168.92.128:8080 weight=10; server 192.168.92.128:8081 weight=5; &#125; #####（3）ip_hash每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session共享的问题。应用场景：保持session 一至性 123456upstream myserver&#123; #指定ip_hash，就进入到ip_hash模式 ip_hash; server 192.168.92.128:8080; server 192.168.92.128:8081; &#125; #####（4）url_hash（第三方）按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 应用场景：静态资源缓存,节约存储，加快速度 1234hash $request_uri;hash_method crc32; server 192.168.92.128:8080;server 192.168.92.128:8081; 其中，hash_method为使用的hash算法，需要注意的是：此时，server语句中不能加weight等参数。 #####（5）fair（第三方）按后端服务器的响应时间来分配请求，响应时间短的优先分配。 fair; #指定fair就会进入到fair模式 server 192.168.92.128:8080; server 192.168.92.128:8081;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣：合并两个有序链表]]></title>
    <url>%2F2020%2F01%2F30%2F%E5%8A%9B%E6%89%A3%EF%BC%9A%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 题解设定一个哨兵节点 prehead ，这可以在最后让我们比较容易地返回合并后的链表。并且维护一个 preNode指针，我们需要做的是调整它的 next 指针。然后，重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。 在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode preHead=new ListNode(0); ListNode preNode=preHead; while(l1!=null&amp;&amp;l2!=null)&#123; if(l1.val&lt;=l2.val)&#123; preNode.next=l1; l1=l1.next; &#125;else&#123; preNode.next=l2; l2=l2.next; &#125; preNode=preNode.next; &#125; preNode.next=l1==null?l2:l1; return preHead.next; &#125;&#125; 复杂度分析时间复杂度：O(n + m)。每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。 空间复杂度：O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。]]></content>
      <categories>
        <category>LetCode</category>
      </categories>
      <tags>
        <tag>LetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx快速入门—基本概念以及在Linux下安装]]></title>
    <url>%2F2020%2F01%2F27%2FNginx%E5%85%A5%E9%97%A8-%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[1、什么是Nginx？百度百科： Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 我的理解： Nginx(engine x)是一个高性能的HTTP反向代理服务器，特点是占用内存少，并发能力强，事实上nginx的并发能力确实是同类型网页服务器中中表现最好的。Nginx专门为性能优化而开发，性能是其最重要的考量，能经受住高并发的考验，有报告表明能支持高达50000个并发连接数。 2、Nginx中重要的概念 反向代理 负载均衡 动静分离 2.1 反向代理（1）正向代理 正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。 简单说正向代理就是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 图2.1.1 正向代理示意图 （2）反向代理反向代理正好相反，对于客户端而言反向代理服务器就像是原始服务器（实质并不是），并且客户端不需要进行任何特别的设置。客户端向反向代理服务器（例如：Nginx）的命名空间(name-space)中的内容发送普通请求，接着反向代理服务器将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 图 2.1.2 反向代理示意图 （3）正向代理和反向代理的区别从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理服务器对外都是透明的，访问者并不知道自己访问的是一个代理服务器。 2.2 负载均衡单个服务器解决不了问题时，我们通过增加服务器的数量，然后将任务分发到各个的服务器上，将原先请求集中到一个服务器上改变为分发到多个服务器，这一过程就是负载均衡。 图2.2.1 负载均衡示意图 2.3 动静分离为了加快网站的解析速度，可以把静态资源和动态资源分开部署到不同的服务器上进行解析，以加快解析速度，降低了原先单个服务器解析的压力。 图2.3.1 动静分离示意图 3、Linux上安装Nginx3.1 安装Nginx所需依赖Nginx安装需要的依赖：pcre、openssl、zlib、和gcc，因此我们需要在安装nginx之前先安装所需的依赖，下面是一条一键安装上面四个依赖的命令： 1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 3.2 安装Nginx依赖安装完毕后，我们可以到Nginx官网：http://nginx.org/download/ 找到合适的Nginx版本下载下来进行安装。 1234567#在本地新建nginx文件夹mkdir /usr/local/nginxcd /usr/local/nginx#下载nginxwget http://nginx.org/download/nginx-1.17.8.tar.gz#解压nginxtar -zvxf nginx-1.17.8.tar.gz 图3.2.1 解压成功 进入到解压出来的文件夹中执行以下命令; 1234#检查配置./configure#编译安装Nginxmake &amp;&amp; make install 安装成功后就会在/usr/local/nginx下生成Nginx的相关文件conf、html、logs、sbin，如图： 图3.2.1 Nginx目录结构 目录结构说明： conf ：Nginx的配置文件夹，它里面有一个nginx.conf，这是配置Nginx的重要文件 sbin：Nginx命令的目录，如Nginx的启动命令nginx logs：Nginx默认的日志路径，包括错误日志及访问日志 html：这是编译安装时Nginx的默认站点目录，类似 Apache的默认站点htdocs目录 3.3 启动Nginx进入到sbin目录，目录下只有一个执行脚本nginx,执行命令./nginx，然后找到Linux虚拟机的ip直接访问，如果看到下面的画面，证明Nginx就安装成功了： 图3.2.2 安装成功 注意：由于Nginx的配置文件中默认的端口是80，因此当没法访问的时候请先检查你的配置以及对应的端口是否在防火墙中是否是开放的。 检查防火墙端口是否开放：firewall-cmd --list-all 增加ka端口：sudo firewall-cmd --add-port=80 重启防火墙：firewall-cmd --reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker实战—手动部署SpringBoot项目到已存在的外部Tomcat]]></title>
    <url>%2F2020%2F01%2F17%2FDocker%E5%AE%9E%E6%88%98%E2%80%94%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2SpringBoot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[废话不多说，直接进入正题。在Linux云服务器上先安装docker ,（以centos为例）执行命令yum -y install docker即可。因为Docker 软件包和依赖包已经包含在默认的 CentOS-Extras 软件源里了。然后systemctl docker start即可开启docker服务。（具体的可以参照我的另一篇博客CentOS 7下安装Docker）。因为我的这个项目使用到了MySQL和Redis，因此需要先他们在docker中启动起来，具体操作看下面： 1、启动MySQL容器使用docker pull mysql 拉取最新的官方MySQL镜像，然后执行命令docker run -d --name mysql -e MYSQL_ROOT_PASSWORD=&quot;xxxx&quot; -e MYSQL_DATABASE=&quot;easyblog&quot; -p 3306:3306 docker.io/mysql。 图1 启动mysql容器成功 稍微解释一下命令的含义： > -d &nbsp; &nbsp; &nbsp;后台执行 > -&nbsp;-name&nbsp; &nbsp; &nbsp; 指定容器实例的名称 > -e MYSQL_ROOT_PASSWORD &nbsp; &nbsp; &nbsp; 初始化root用户的密码 > -e MYSQL_DATABASE &nbsp; &nbsp; &nbsp; 在启动的mysql容器中创建一个数据库 > -p &nbsp; &nbsp; &nbsp;映射主机端口和容器端口 2、启动Redis容器同样和启动mysql类似，先docker pull redis 拉取redis，然后执行命令：docker run --name redis -p 6379:6379 -d redis redis-server --appendonly yes --requirepass &quot;xxxx&quot; 图2 启动redis容器成功 命令中 ： > redis-server - -appendonly yes ：在容器执行redis-server启动命令，并打开redis持久化配置 > - -requirepass "xxx" ： 设置redis的密码，不是必须的 3、准备SpringBoot项目并将其打包为****.war由于我们的Tomcat服务器是另外早已经部署好了的，有专门的维护方式。此时我们需要剥离掉SpringBoot应用内置的Tomcat服务器，进而将应用发布并部署到外置的Tomcat容器之中： 3.1、修改打包的方式修改的方法有两种：一种是在使用【Spring Initializr】新建项目的时候选择Packing为war；或者在pom.xml文件中修改 3.1.1 使用【Spring Initializr】新建项目的时候选择Packing为war 图 3.1 选择打包方式 3.1.2 pom.xml文件中修改 1234&lt;artifactId&gt;springboot_servlet_contanier&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!--修改为war的打包方式--&gt;&lt;packaging&gt;war&lt;/packaging&gt; #####3. 2、 排除SpringBoot内置的tomcat 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!-- 移除嵌入式tomcat插件 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 3.3、 添加原生tomcat依赖123456789101112131415161718192021222324252627&lt;!--添加原生tomcat依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--使用jsp还要添加下面对依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 3.4、 修改启动类，并重写初始化方法12345678910111213141516171819202122232425package top.easyblog;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;import org.springframework.cache.annotation.EnableCaching;@EnableCaching@MapperScan(value = "top.easyblog.mapper")@SpringBootApplication// 修改启动类：继承 SpringBootServletInitializer 并重写 configure 方法public class Application extends SpringBootServletInitializer &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; // 注意这里一定要指向原先用main方法执行的Application启动类 return builder.sources(Application.class); &#125;&#125; 一些准备就绪后，执行以下Maven命令将我们的程序打成war包： 1mvn clean package -Dmaven.test.skip=true #清除以前target目录下的东西然后打包 -Dmaven.test.skip=true参数的含义是跳过mvn test 打包成功后可以在工程目录的target目录找到项目的war包，把这个war包上传到服务器。这里我使用rz命令把它上传到我服务器的/usr/local/docker/webapps目录下。 3.5、 启动tomcat容器流程还是一样的，先用docker pull tomcat命令拉取tomcat最新版本，然后运行tomcat。运行tomcat时有以下几点注意： 在运行的时候挂载主机的/usr/local/docker/weapps/ROOT.war到tomcat容器内部的webapps目录下。 由于mysql、redis都是在docker容器中运行着，容器之间是隔离的，没有办法通过127.0.0.1/localhost直接通信，但是docker提供了link机制（--link 运行中容器的名字:该容器你给起的别名），可以用于docker内部容器的通信。 最重要的一点 在配置文件中host地址一定要写你配置的–link的名字。切记！ 图 3.2 配置文件host地址的写法示例 一切检查无误后，执行下面的命令启动web服务器—tomcat： 1docker run --name tomcat-8080 -d -p 80:8080 -v /usr/local/docker/webapps/ROOT.war:/usr/local/tomcat/webapps/ROOT.war --link mysql:mysql --link redis:redis docker.io/tomcat 运行结果： 图 3.3 运行成功]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty入门—实现简单的HTTP服务器]]></title>
    <url>%2F2020%2F01%2F04%2FNetty%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Netty是一个基于事件驱动的异步非阻塞网络应用程序框架，可以用于快速开发可维护的高性能协议服务器和客户端，今天我们就用Netty来简单实现一个Http服务器。注意：如果要实现一个完整的Http服务器，那将是十分复杂的。所以，这里只是实现最基本的，请求-响应。 要求：1、Netty 服务器监听8080端口，当浏览器发出http://localhost:8080 请求后，服务器给浏览器返回一句话“服务器收到请求！Hello Client”;2、服务器要对某些特定的请求进行过滤/拦截 废话不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package top.easyblog.netty.http;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.http.*;import io.netty.util.CharsetUtil;import java.net.URI;/** * @author HuangXin * @since 2020/1/4 21:28 * 使用Netty写一个Http服务器并监听8080端口， * 当浏览器发出http://localhost:8080请求后可以返回给浏览器信息“服务器收到请求！” */public class HttpServer &#123; //监听的端口 private static final int DEFAULT_PORT = 8080; private int port = -1; //bossGroup 只负责处理accept事件 private EventLoopGroup bossGroup; //workerGroup 负责具体的数据业务处理 private EventLoopGroup workerGroup; public HttpServer() &#123; this.bossGroup=new NioEventLoopGroup(); this.workerGroup=new NioEventLoopGroup(); &#125; public HttpServer(int port) &#123; this(); this.port = port; &#125; private ServerBootstrap initServer() &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup) //设置两个线程组 .channel(NioServerSocketChannel.class) //设置服务器通道的类型 .option(ChannelOption.SO_BACKLOG, 128) //设置线程队连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置连接保持活动 .childOption(ChannelOption.TCP_NODELAY, true) //设置服务器非延迟发送 .childHandler(new HttpServerChannelInitializer()); ///给workerGroup的pipleline设置hanlder return serverBootstrap; &#125; public void start() &#123; try &#123; ServerBootstrap serverBootstrap = initServer(); ChannelFuture channelFuture; if (port &gt; 0) &#123; channelFuture = serverBootstrap.bind(port).sync(); //监听异步过程bind() channelFuture.addListener((ChannelFutureListener) channelFuture1 -&gt; &#123; if (channelFuture1.isSuccess()) &#123; System.out.println("服务器启动成功，正在监听"+port+"端口"); &#125; else &#123; System.out.println("服务器监听" + port + "端口失败,原因：" + channelFuture1.cause()); &#125; &#125;); &#125; else &#123; channelFuture = serverBootstrap.bind(DEFAULT_PORT).sync(); //监听异步过程bind() channelFuture.addListener((ChannelFutureListener) channelFuture1 -&gt; &#123; if (channelFuture1.isSuccess()) &#123; System.out.println("服务器启动成功，正在监听"+DEFAULT_PORT+"端口"); &#125; else &#123; System.out.println("服务器监听" + DEFAULT_PORT + "端口失败,原因：" + channelFuture1.cause()); &#125; &#125;); &#125; //监听服务器的关闭 channelFuture.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (bossGroup != null) &#123; bossGroup.shutdownGracefully(); &#125; if (workerGroup != null) &#123; workerGroup.shutdownGracefully(); &#125; &#125; &#125; /** *定义我们自己的初始化器HttpServerChannelInitializer */ static class HttpServerChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; ChannelPipeline pipeline = socketChannel.pipeline(); //HttpSererCodec是netty提供一个基于Http编/解码器 pipeline.addLast(new HttpServerCodec()); //添加自定义的handler pipeline.addLast(new HttpServerHandler()); &#125; &#125; /** * SimpleChannelInboundHandler是ChannelInboundHandler的子类 ，继承SimpleChannelInboundHandler也可以实现一个handler * HttpObject 是客户端和服务器通讯的数据封装 */ static class HttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123; //用于读取客户端的数据 @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject httpObject) throws Exception &#123; if (httpObject instanceof HttpRequest) &#123; System.out.println("客户端地址：" + ctx.channel().remoteAddress()); HttpRequest request= (HttpRequest) httpObject; URI uri=new URI(request.uri()); //过滤部分请求，不响应 if("/static".equals(uri.getPath())||"/image".equals(uri.getPath()))&#123; return; &#125; System.out.println("请求路径：" + ((HttpRequest) httpObject).uri()); ByteBuf content = Unpooled.copiedBuffer("服务器收到请求！Hello Client",CharsetUtil.UTF_8); //构造一个http请求 DefaultFullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content); response.headers().set(HttpHeaderNames.CONTENT_TYPE, "text/plain"); response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes()); ctx.channel().writeAndFlush(response).addListener(ChannelFutureListener.CLOSE); &#125; &#125; &#125;&#125; 上面代码看似很长，但是会一点Netty的同学不难看懂，上面的代码无非干了下面几件事： 初始化连个线程池boosGroup和workerGroup，他们的实现类型都是NioEventLoopGroup，其中boosGroup只负责处理accept事件连接请求，workerGroup负责具体的数据业务处理 使用ServerBootStrap进行初始化配置，其中初始化配置有：配置两个事件循环组(boosGroup和workerGroup)，配置服务器通道的类型为NioServerSocketChannel,配置初始化器以及一些其他的配置，具体的代码中有详细对注释。 自定义初始化器，并在初始化其中指定自定义的Handler 自定义Handler，对请求进行处理 并响应请求 启动服务器演示效果123456789101112131415package top.easyblog;import static org.junit.Assert.assertTrue;import org.junit.Test;import top.easyblog.netty.http.HttpServer;/** * Unit test for simple App. */public class AppTest &#123; public static void main(String[] args) &#123; new HttpServer().start(); &#125;&#125; 启动服务器并在postman中输入http://localhost:8080 ,运行结果截图如下：]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty入门—"HelloWorld"级别的服务器和客户端TCP通信]]></title>
    <url>%2F2020%2F01%2F03%2FNetty%E5%85%A5%E9%97%A8%E2%80%94HelloWorld%E7%BA%A7%E5%88%AB%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AFTCP%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[首先引入Netty的依赖包，这里以pom的方式导入Netty的依赖 123456&lt;!-- Netty依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.44.Final&lt;/version&gt;&lt;/dependency&gt; 编写服务端的程序NettyServer.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package top.easyblog.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.ServerSocketChannel;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.util.CharsetUtil;import io.netty.util.ReferenceCountUtil;/** * @author HuangXin * @since 2020/1/1 21:59 */public class NettyServer &#123; public static void main(String[] args) &#123; //创建两个线程组，BossGroup(只负责连接请求) 和 WorkerGroup（负责具体的业务处理） //这两个线程组都是无限循环执行的，线程组中的线程数量默认是当前CPU核的数量的2倍 /** * 默认的线程数量DEFAULT_EVENT_LOOP_THREADS=当前CPU核的数量的2倍 * private static final int DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt("io.netty.eventLoopThreads", NettyRuntime.availableProcessors() * 2)); * * protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) &#123; * super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args); * &#125; */ EventLoopGroup bossGroup = new NioEventLoopGroup(1); //指定bossGroup里的线程数量是1 EventLoopGroup workerGroup = new NioEventLoopGroup(); //没有指定的时候线程数量默认是系统CPU核心数的2倍 try &#123; //创建服务器启动对象 ServerBootstrap bootstrap = new ServerBootstrap(); //bossGroup在bootstrap对象的group成员中，workGroup在childGroup中 bootstrap.group(bossGroup, workerGroup) //设置两个线程组 .channel(NioServerSocketChannel.class) //设置服务器通道的类型 .option(ChannelOption.SO_BACKLOG, 128) //设置线程队列连接个数 .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动的连接状态 .childOption(ChannelOption.TCP_NODELAY,true) //关闭延迟发送 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; //给WorkerGroup的Pipeline设置Handler @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new MyServerHandler()); &#125; &#125;); //绑定一个端口并且启动服务器 ChannelFuture channelFuture = bootstrap.bind(9999).sync(); System.out.println("Server started,listening on"+channelFuture.channel().localAddress()); //对关闭通道这件事进行监听 channelFuture.channel().closeFuture().sync(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //完美的关闭两个线程组 bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125;/** * 自定义Handler 必须继承Netty规定的某个HandlerAdapter,这样我们写的这个类才能被称为Handler */class MyServerHandler extends ChannelInboundHandlerAdapter &#123; /** * 通道有读取事件时时触发这个方法 * * @param ctx 上下文对象，内部封装了许多有用的信息 * @param msg 客户端发送过来的信息 * @throws Exception */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; try &#123; ByteBuf buf = (ByteBuf) msg; Channel channel = ctx.channel(); //pipeline的底层数据结构是双向链表 ChannelPipeline pipeline = ctx.pipeline(); System.out.println("pipleline中的channle是否和ctx中的channel一样"+(pipeline.channel()==channel)); System.out.println(channel.remoteAddress() + "发送过来数据：" + buf.toString(CharsetUtil.UTF_8)); ctx.flush(); &#125;finally &#123; //抛弃接受到的数据 ReferenceCountUtil.release(msg); &#125; &#125; /** * 通道的数据读取完毕后就会触发此方法 * * @param ctx 上下文对象，内部封装了许多有用的信息 * @throws Exception */ @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; //将数据写入到缓存中并刷新 ctx.writeAndFlush(Unpooled.copiedBuffer("hello,Client~~", CharsetUtil.UTF_8)); &#125; /** * 发生通道断开时触发此事件 * @param ctx * @throws Exception */ @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("客户端"+ctx.channel().remoteAddress()+"断开连接..."); ctx.channel().close(); &#125; /** * 发生异常时触发此方法，当发生异常的时候会触发这个方法 * * @param ctx 上下文对象，内部封装了许多有用的信息 * @param cause 异常信息 * @throws Exception */ @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println(cause.getMessage()); ctx.close(); &#125;&#125; 编写客户端程序NettyClient.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package top.easyblog.netty.simple;import io.netty.bootstrap.Bootstrap;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.util.CharsetUtil;/** * @author HuangXin * @since 2020/1/1 21:59 */public class NettyClient &#123; public static void main(String[] args) &#123; EventLoopGroup works = new NioEventLoopGroup(); try&#123; Bootstrap bootstrap=new Bootstrap(); bootstrap.group(works) //设置线程组 .channel(NioSocketChannel.class) //设置客户端的的通道类型 .option(ChannelOption.SO_KEEPALIVE,true) .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; //设置处理器 @Override protected void initChannel(SocketChannel socketChannel) throws Exception &#123; socketChannel.pipeline().addLast(new MyClientHandler()); &#125; &#125;); System.out.println("client started,connecting to Server......"); ChannelFuture channelFuture = bootstrap.connect("127.0.0.1", 9999).sync(); System.out.println("connected to server successfully"); //监听客户端的关闭事件 channelFuture.channel().closeFuture().sync(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭客户端线程池 works.shutdownGracefully(); &#125; &#125;&#125;class MyClientHandler extends ChannelInboundHandlerAdapter&#123; /** * 当通道就绪的时候就会触发这个方法，可以用这个方法发送消息 * @param ctx 上下文对象，内部封装了许多有用的信息 * @throws Exception */ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("channel is active"); ChannelFuture channelFuture = ctx.writeAndFlush(Unpooled.copiedBuffer("hello,Sever!", CharsetUtil.UTF_8)); channelFuture.addListener((ChannelFutureListener)-&gt;&#123; System.out.println("message send successfully!"); &#125;); ctx.flush(); &#125; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; System.out.println("Channel is readable"); ByteBuf buf= (ByteBuf) msg; System.out.println("服务器回复的消息:"+buf.toString(CharsetUtil.UTF_8)); System.out.println("服务器的地址："+ctx.channel().remoteAddress()); ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println("caught Exception"); System.out.println(cause.getMessage()); ctx.channel().close(); &#125;&#125; 先后启动服务器端和客户端，运行结果在预料之中，服务器收到客户端的数据之后，给客户端响应了数据：]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置实例—动静分离]]></title>
    <url>%2F2020%2F01%2F03%2FNginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%E2%80%94%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[1、动静分离概念重温Nginx动静分离可以简单的理解为把动态跟静态分离开来，不能理解成只是单纯的把动态页面和静态页面物理上的分离。严格意义上来说应该是把动态请求和静态请求分离，即nginx处理静态请求，tomcat等应用服务器处理动态请求。动静分离从目前的实现角度来讲大致分为两类：一种是纯粹把静态文件放在一个独立的服务器上，有一个独立的域名，也是目前主流推崇的方案；另一种是动态文件和静态文件混在一起发布，通过nginx分离开来，通过location配置不同的后缀名实现不同的请求转发。 2、Nginx动静分离实战配置2.1 准备静态资源首先在Liunx系统根目录下新建一个文件夹/resources/static用于存放静态文件 123[root@localhost /]# cd static[root@localhost static]# mkdir images[root@localhost static]# wget -o images http://nginx.org/nginx.png 2.2 准备动态资源在tomcat的webapps/ROOT目录下新建test.jsp,内容如下： 12345678910111213&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt;&lt;HTML&gt; &lt;HEAD&gt; &lt;TITLE&gt;JSP Test Page&lt;/TITLE&gt; &lt;/HEAD&gt; &lt;BODY&gt; &lt;% Random rand = new Random(); out.println("&lt;h1&gt;Random number:&lt;/h1&gt;"); out.println(rand.nextInt(99)+100); %&gt; &lt;/BODY&gt;&lt;/HTML&gt; 2.3 在nginx中配置对静态请求和动态请求的处理逻辑完成资源文件的准备后，启动两个tomcat，分别监听8080和8081，之后在nginx的配置文件做如下简单配置： 123456789101112131415161718192021222324http &#123; #配置两个tomcat，让nginx均衡负载 upstream tomcatserver&#123; server 192.168.92.128:8080; server 192.168.92.128:8081; &#125; server &#123; listen 80; server_name 192.168.92.128; charset utf-8； #对静态资源的配置，使用Nginx进行处理响应 location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff)$ &#123; #root目录指向的就是静态资源所在的路径 root /static/images/; &#125; #对动态请求，由nginx转发到tomcat等应用服务器进行处理 location ~ .*\.jsp$ &#123; proxy_pass http://tomcatserver; &#125; &#125;&#125; 配置好后重启nginx，然后在浏览器地址栏中输入www.123.com/nginx.png ,能看到nginx的Logo图，说明对静态资源的配置没有问题；之后再输入www.123.com/test.jsp，能看到`Random number:xxx`，说明对动态请求的配置也能正常工作，运行截图如下： 图 1 nginx处理静态请求 图 2 nginx处理动态请求 整合动态资源和静态资源上面通过一个简单的小测试体验了一下nginx的动静分离的效果，测试结果达到了预期效果。接下来我们来把他们整合在一起，即在一个页面中即有动态的也有静态的资源，通过nginx中配置帮我们完成对资源的请求，而我们所需做的就是输入www.123.com 这个地址即可。（1）在/rsources目录下新建目录template，并在template中新建文件：index.html，文件内容如下： 1234567891011121314151617181920212223242526&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;测试ajax和跨域访问&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;script type="text/javascript"&gt;$(document).ready(function()&#123; $.ajax(&#123; type: "GET", url: "http://www.123.com/test.jsp", success: function(data) &#123; $("#get_data").html(data) &#125;, error: function() &#123; alert("fail!!,请刷新再试!"); &#125; &#125;);&#125;);&lt;/script&gt; &lt;body&gt; &lt;h1&gt;测试动静分离&lt;/h1&gt; &lt;img src="http://www.123.com/nginx.png"&gt; &lt;div id="get_data"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 保存文件之后修改nginx配置文件如下： 1234567891011121314151617181920212223242526272829http &#123; #配置两个tomcat，让nginx均衡负载 upstream tomcatserver&#123; server 192.168.92.128:8080; server 192.168.92.128:8081; &#125; server &#123; listen 80; server_name 192.168.92.128; charset utf-8; location / &#123; root /resources/template/; index index.html; &#125; #对静态资源的配置，使用Nginx进行处理响应 location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff)$ &#123; #root目录指向的就是静态资源所在的路径 root /resources/static/images/; &#125; #对动态请求，由nginx转发到tomcat等应用服务器进行处理 location ~ .*\.jsp$ &#123; proxy_pass http://tomcatserver; &#125; &#125;&#125; 配置好后重启nginx，然后在浏览器地址栏中输入www.123.com ，如果在网页上能看到如下图所示内容表示配置成功，运行截图如下： 图 3 动静资源正常加载]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次在云服务器上部署项目的实践经历]]></title>
    <url>%2F2020%2F01%2F02%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%AE%9E%E8%B7%B5%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[一、Linux上Java的安装与配置由于使用 yum 或者 apt-get 命令 安装 openjdk 可能存在类库不全，从而导致用户在安装后运行相关工具时可能报错的问题，所以此处我们推荐采用手动解压安装的方式来安装 JDK。具体步骤如下： 1.下载 JDK近入 Oracle 官方网站 下载载合适的 JDK 版本，准备安装。 注意：不要下错了，需要下载 Linux 版本。这里以jdk-8u151-linux-x64.tar.gz为例，你下载的文件可能不是这个版本，这没关系，只要后缀(.tar.gz)一致即可。 2. 创建目录在/usr/local目录下创建java目录， 12mkdir /usr/local/javacd /usr/local/java 把下载的文件 jdk-8u151-linux-x64.tar.gz 放在/usr/local/java/目录下。 向Linux上传文件可以使用rz命令，非常方便，它会把文件默认放在执行命令的（当前）目录下。传送门：Linux下安装、使用rz和sz 3. 解压 JDKtar -zxvf jdk-8u151-linux-x64.tar.gz 4. 设置环境变量vim /etc/profile在 profile 文件中添加如下内容并保存： 123456set java environmentJAVA_HOME=/usr/local/java/jdk1.8.0_151 JRE_HOME=/usr/local/java/jdk1.8.0_151/jre CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH 注意：其中 JAVA_HOME， JRE_HOME 请根据自己的实际安装路径及 JDK 版本配置。 让修改生效：source /etc/profile 5. 测试输入命令java -version显示 java 版本信息，则说明 JDK 安装成功： 123java version &quot;1.8.0_151&quot;Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) 二、Linux上MySQL的安装和配置1. 下载安装包输入命令:rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm 输入命令:yum install -y mysql-server 2. 检查是否设置成功输入命令：systemctl list-unit-files | grep mysqld 3. 查看默认密码输入命令:grep &#39;temporary password&#39; /var/log/mysqld.log 如果不行（没有反应），则按一下步骤： 1.删除原来安装过的mysql残留的数据（这一步非常重要，问题就出在这）rm -rf /var/lib/mysql2.重启mysqld服务systemctl restart mysqld3.再去找临时密码grep &#39;temporary password&#39; /var/log/mysqld.log 4. 登录mysql输入命令:mysql -uroot -p，此时输入上一步查看的默认密码，进入MySQL 5. 修改密码等级登录数据库后的第一件是就是修改密码，因为如果你不修改密码也用不了~~ 1234#选择数据库use mysql #修改数据库密码sqlALTER USER ‘root’@'%' IDENTIFIED WITH mysql_native_password BY 'newpassword(你的密码)'; 如果输入的密码过于简单，则需要进行安全策略的修改，否则会出现以下的错误: Your password does not satisfy the current policy requirements 此时将密码的优先级设置为LOW，在mysql里面输入命令:set global validate_password_policy=0; 如果不行， 1、查看 mysql 的密码策略，输入命令 “ SHOW VARIABLES LIKE &#39;validate_password%&#39;;” 进行查看.2、首先需要设置密码的验证强度等级，设置 validate_password_policy 的全局参数为 LOW 即可，输入设值命令 “ set global validate_password_policy=LOW;” 进行设值在MySQL8.x中请执行set global validate_password.policy=LOW;3、当前密码长度为 8 ，如果不介意的话就不用修改了，按照通用的来讲，设置为 6 位的密码，设置 validate_password_length 的全局参数为 6 即可，输入命令 “set global validate_password_length=6; ” 进行设值在MySQL8.x中请执行set global validate_password_length=6; 开启远程授权登陆输入命令:GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;XXXXX&#39; WITH GRANT OPTION其中XXXXX是修改的密码 连接本地可视化数据库客户端在本地使用可视化数据库客户端连接测试数据库是否配置好，这里我使用的是Navicat，创建连接后成功与服务器上的MySQL连接上了 如果没有连接上，请耐心检查上免的配置，以及防火墙是否没有开放3306端口 1234567firewall-cmd --state#查看已开放的列表firewall-cmd --list-ports#添加要开放的列表firewall-cmd --zone=public --add-port=3306/tcp --permanent#重启防火墙firwall-cmd --reload 三、Linux上Redis的安装和配置由于我的项目中使用到了Redis，因此需要在服务器中安装Redis，安装配置也很就简单详请参考我的这篇博客：Linux上安装配置Redis这里特别需要注意最好不要使用Redis的默认端口连接，而且最好给Redis设置个密码，毕竟项目是要在真实的服务器上运行的，会面临各种意想不到的事（我就遇到了，项目刚上线运行3天就被”肉鸡”了，上网一查原因就是有Redis导致的。）。 四、Linux下安装Tomcat1. 下载在命令行输入命令：wget https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.49/bin/apache-tomcat-8.5.49.tar.gz 2. 解压tar -zvxf apache-tomcat-8.5.49.tar.gz 解压后会在当前目录下得到解压后的得文件，把它移动到/usr/local/tomcat目录下mv apache-tomcat-8.5.49 /usr/local/tomcat/ 之后打开apache-tomcat-8.5.49下的conf文件夹中的server.xml文件 vim server.xml，配置第69行的Connector的port为80，表示监听80端口 简单配置后按Esc键后输入:wq保存配置 3. 部署项目我们的项目以war包的形式放在webapps目录下即可，然后到bin目录下执行./startup.sh启动tomcat，启动后就可以访问部署的项目了，访问的URL形式是：http://主机公网ip:端口/war包的名字/项目路径；如果想省去中间war包的名字可以直接把我的的war包命名为ROOT.war覆盖原来的ROOT目录，之后我访问项目的URL是：http://主机公网ip:端口/项目路径 工具安装Linux下安装、使用rz和szrzsz 官网入口：http://freecode.com/projects/lrzsz/lrzsz是一个unix通信套件提供的X，Y，和ZModem文件传输协议 windows 需要向centos服务器上传文件，可直接在centos上执行命令yum -y install lrzsz程序会自动安装好，然后如你要下载者sz [找到你要下载的文件] 如果你要上传，者rz 浏览找到你本机要上传的文件。需要注意的是这个命令无法在putty界面使用哦！ 安装与使用yum安装1[root@ecs-sn3-medium-2-linux-20191128162047 /]# yum -y install lrzsz 使用上传文件，执行命令rz，会跳出文件选择窗口，选择好文件，点击确认即可。 1[root@ecs-sn3-medium-2-linux-20191128162047 /]# rz 下载文件，执行命令sz 1[root@ecs-sn3-medium-2-linux-20191128162047 /]# sz Linux下Maven的安装和环境配置1. 下载maven输入命令下载安装包：wget http://mirrors.cnnic.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz输入解压命令：tar vxf apache-maven-3.3.9-bin.tar.gz在usr的local目录下创建maven3文件夹，切换到local目录，输入命令:cd /usr/local,在当前目录下创建maven3文件夹，输入命令:mkdir maven3将解压过后的文件夹移动到这个目录下，输入命令：mv apache-maven-3.3.9 /usr/local/maven3 2. 配置环境变量打开配置文件，输入命令:vim /etc/profile 123#Mavenexport MAVEN_HOME=/usr/local/maven3export PATH=$&#123;PATH&#125;:$&#123;MAVEN_HOME&#125;/apache-maven-3.6.3/bin 3. 生效环境变量输入命令:source /etc/profile 4. 查看安装配置是否成功输入命令:mvn -version如果提示一下信息，则表示安装成功： 提示：这一步要想成功，请务必确认你的Java环境是否配置正确，如果Java配置正确，这一步按流程来应该没有问题。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[力扣：最接近的三数之和]]></title>
    <url>%2F2020%2F01%2F02%2FLeetCode%20%E7%AC%AC16%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 解题思路：双指针法 ，具体看下面的图解1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 通过图解可以很清楚的看到本题的一个解决思路，先给给定的数组升序排序： 从头开始遍历数组，以遍历到的当前的下标为基准(i)，i+1定义为s(start)即双指针的开始，e初始在数组末尾； 当s和e没有重叠的时候，每次求nums[i]+nums[s]+nums[e]的和(sum)， 如果满足|target-ant|的差值大于|target-sum|的差值那就更新ant的值； 接下来判断当前sum和target的差距大小，如果sum&gt;target，那么就让尾指针-1（这样做又可以使得结果更好）否者让头指针s+1(同样的原因)。不断夹逼,最终当剩余的数&lt;3个的时候结束，并返回当前的ant的值。（无论第三步有没有执行这一步始终会执行） 源码实现：123456789101112131415161718192021222324class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int ant=nums[0]+nums[1]+nums[2]; //初始数据最前3个数的和 for(int i=0,len=nums.length;i&lt;len;i++)&#123; int s=i+1,e=len-1; while(s&lt;e)&#123; int sum=nums[i]+nums[s]+nums[e]; if(Math.abs(target-ant)&gt;Math.abs(target-sum))&#123; ant=sum; &#125; //根据结果计算下一步的操作是移动s指针还是移动e指针 if(sum&gt;target)&#123; e--; &#125;else if(sum&lt;target)&#123; s++; &#125;else&#123; return ant; &#125; &#125; &#125; return ant; &#125;&#125; 整个过程，对数组排序的时间复杂度是O(nlogn)，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2)，总的时间复杂度是O(n^2)]]></content>
      <categories>
        <category>LetCode</category>
      </categories>
      <tags>
        <tag>LetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis的Java客户端]]></title>
    <url>%2F2019%2F09%2F30%2FRedis%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[Jedis连接Redis1.添加Jedis依赖 12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 2.在虚拟机端配置：将bind注释掉，然后改protected-mode为no 改了之后保存并重启Redis。 3.使用Jedis提供的Jedis这个工具类来连接Jedis，首先在虚拟机使用ifconfig命令查看虚拟机的ip，然后向Redis发送一个ping命令，测试一下是否可以连接上远程的Redis: 1234567891011121314151617public class RedisTest &#123; private Jedis jedis = null; @Before public void getConnection() &#123; jedis = new Jedis("192.168.92.128", 6379); &#125; /** * 测试和虚拟机上的Redis的连通性 */ @Test public void pingTest() &#123; System.out.println(jedis.ping()); &#125;&#125; 可以连接上Redis的标志是程序运行后打印”PONG“ 如果程序运行出现了JedisConnectionException，这种情况要么是你代码中把ip或端口写错了，要不就是由于Linux的防火墙导致的，在你确定你没有写错ip或端口的前提下，你可以直接关闭防火墙或者为了安全你可以开放6379这个端口给远程，Centos 7上开放端口有关的命令操作如下： 12345678# 开放6379端口firewall-cmd --permanent --add-port=6379/tcp# 查询端口是否开放，yes就是开放的firewall-cmd --query-port=6379/tcp# 重新加载配置firewall-cmd --reload# 移除指定开放的端口firewall-cmd --permanent --remove-port=6379/tcp Jedis常用APIJedis操作Redis的常用API几乎和Redis的命令是一样的，比如操作String： 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /** * String类型的数据接的测试 */ @Test public void testString() &#123; //set 添加key和value 如果已经有了就覆盖 jedis.set("k1", "111"); jedis.set("k2", "222"); jedis.set("k3", "333"); //get 获取值 System.out.println(jedis.get("k1") + " " + jedis.get("k2") + " " + jedis.get("k3")); //set可以设置参数：EX（秒）/PX（毫秒）--&gt;过期时间 NX 不存在时操作 XX存才时操作 jedis.set("k4", "444", new SetParams().nx()); //key不存在的时候进行操作 jedis.set("k3", "123", new SetParams().xx()); //key存在的时候操作 jedis.set("k5", "345", new SetParams().ex(60)); //设置key的生命时间,单位s jedis.set("k6", "666", new SetParams().px(10000)); //设置key的生命时间,单位ms //append 追加内容 jedis.append("k1", "hello"); //追加 //STRLEN System.out.println(jedis.get("k1") + ",v1的长度：" + jedis.strlen("k1")); //INCR INCRBY DECR DECRBY jedis.incr("k6"); //加1 jedis.incrBy("k5", 100); //加任意增量 jedis.decr("k4"); //减1 jedis.decrBy("k3", 100); //减去任意减量 System.out.println(jedis.get("k3") + " " + jedis.get("k4") + " " + jedis.get("k5") + " " + jedis.get("k6") + " "); //GETRANGE 获得字符串的一部分 System.out.println(jedis.getrange("k1", 0, -1)); //SETRANGE 设置字符串的一部分 jedis.setrange("k1", 0, "redis"); System.out.println(jedis.get("k1")); jedis.mset("msg1", "hello", "msg2", "error", "msg3", "success"); System.out.println(jedis.mget("msg1", "msg2", "msg3"));&#125; 可以看到通过Jedis操作Redis所调用的API和Redis的命令是一样的，所以只要熟悉Redis的关于5大常用数据类型的命令，那么使用Jedis操作Redis就没有大的问题。如果你还不是熟悉Redis的关于5大常用数据类型的命令，可以参考我的这篇笔记：Redis五大常用数据类型 Jedis事务Redis中和事务有关的命令：mulit、exec，discard，watch和unwatch，然而Jedis中操作Redis事务的API也和这几个命令是一样的，比如我们实现一个简单的事务： 1234567891011121314@Test public void tx()&#123; Jedis jedis=new Jedis("192.168.92.128", 6379); Transaction transaction = jedis.multi();//开启事务 //命令入队 transaction.set("k1","v1"); transaction.set("k2","v2"); transaction.get("k1"); //执行事务 List&lt;Object&gt; exec =transaction.exec(); //transaction.discard(); //取消事物 //打印执行事务后的返回结果 exec.forEach(ele-&gt;System.out.println(ele)); &#125; 有两个关键字balance表示信用卡的余额（初始值为1000），debt表示信用卡的欠额（初始值为0），使用redis提供的乐观锁watch来实现对消费的记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.xust.iot;import redis.clients.jedis.Jedis;import redis.clients.jedis.Transaction;import java.util.List;public class TxTest &#123; private Integer balance; //账户余额 private Integer debt; //账户欠额 private static Jedis jedis = new Jedis("192.168.92.128", 6379); private static final int autoDECR = 10; //模拟每次消费的金额 public boolean coustmer() &#123; try &#123; String balance = jedis.watch("balance");//开启监控 //jedis.mset("balance","100","debt","400"); //模拟另一个线程在本线程开启了对balance监控以后改变了balance的值 this.balance = Integer.parseInt(jedis.get("balance")); List&lt;Object&gt; exec =null; if (this.balance &gt; autoDECR) &#123; Transaction transaction = jedis.multi(); //开启事务 transaction.decrBy("balance", autoDECR); transaction.incrBy("debt", autoDECR); exec = transaction.exec(); //提交事务,执行事务后会自动unwatch &#125; else &#123; jedis.unwatch(); &#125; if(null!=exec)&#123; System.out.println("操作成功："); System.out.println("余额："+jedis.get("balance") + " 欠额：" + jedis.get("debt")); return true; &#125;else&#123; System.out.println("操作失败，监控到balance发生改动"); return false; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; jedis.close(); //关闭连接 &#125; return false; &#125; public static void main(String[] args) &#123; TxTest txTest = new TxTest(); while (!txTest.coustmer()); //自旋，直到执行成功为止 &#125;&#125; 正常情况下（就是没有别的线程干扰）： 异常情况下： 解释一下这两种不同的结果：当开启监控后，如果期间别的线程把监控的关键字的值改变了，那么Redis就会在本次事务期间不执行任何操作，即使使用exec提交事务了，也不会执行（这时返回exec的返回值是null），这种基于CAS的监控，不仅保证了共享数据的安全，而且还提高了响应速速。这也正是程序所体现的，当jedis.mset(“balance”,”100”,”debt”,”400”); 这条语句被注释掉以后，程序可以正常执行，执行后返回true,程序结束；当jedis.mset(“balance”,”100”,”debt”,”400”);语句没有注释以后，在开启watch以后，相当于别的进程改变了监控关键字的值，那么这时Redis就不会在执行事务了，exec就会返回false，然后 while (!txTest.coustmer()); 就又再次调用方法，直到执行成功，然后结束程序。 JediaPool连接池类似于mysql的数据库连接池c3p0、Durid等，JedisPool是java连接Redis的连接池，基本的使用方式如下： 123456789101112131415161718public class RedisTest2 &#123; public static void main(String[] args) &#123; // 比较特殊的是，redis连接池的配置首先要创建一个连接池配置对象 JedisPoolConfig config = new JedisPoolConfig(); // 当然这里还有设置属性的代码 // 创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,"localhost",6379); // 获取连接 Jedis jedis = jedisPool.getResource(); // 使用 // 关闭，归还连接到连接池 jedis.close(); &#125;&#125; 一般我们可以各种配置的代码抽取出来写一个工具类，下面是一个基于单例模式的JedisPoolUtils：首先我们需要一个redis.properties的配置文件，用于配置JedisPool的一些属性： 1234redis.host=192.168.92.128redis.port=6379redis.maxTotal=50redis.maxIdle=10 JedisPoolUtils.java 1234567891011121314151617181920212223242526public class JedisPoolUtils &#123; private static volatile JedisPool jedisPool=null; public JedisPoolUtils()&#123;&#125; public static JedisPool getJedisPool()&#123; if(null==jedisPool)&#123; synchronized (JedisPoolUtils.class)&#123; if(null==jedisPool)&#123; try &#123; //设置各种属性 JedisPoolConfig poolConfig = new JedisPoolConfig(); ResourceBundle rs = ResourceBundle.getBundle("redis"); poolConfig.setMaxIdle(Integer.parseInt(rs.getString("redis.maxIdle"))); poolConfig.setMaxTotal(Integer.parseInt(rs.getString("redis.maxTotal"))); jedisPool = new JedisPool(poolConfig, rs.getString("redis.host"),Integer.parseInt(rs.getString("redis.port"))); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return jedisPool; &#125;&#125; 然后测试一下我们的JedisPoolUtils工具类： 12345678910public class JedisPoolTest &#123; public static void main(String[] args)&#123; JedisPool jedisPool = JedisPoolUtils.getJedisPool(); Jedis jedis = jedisPool.getResource(); jedis.set("msg","jedisPopl test success!"); System.out.println(jedis.get("msg")); jedis.close(); //把jedis放回池子 &#125;&#125; 测试结果： SpringBoot连接Redis导入redis的相关依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在application.properties/yml中配置redis的有关连接信息123456789101112spring: #Redis的有关配置 redis: host: 192.168.92.128 port: 6379 password: jedis: pool: max-wait: 200 max-idle: 10 max-active: 10 timeout: 2000 自定义RedisTemplate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringBoot自动帮我们在容器中生成了一个RedisTemplate和一个StringRedisTemplate。我们可以使用RedisTemplate来像Jedis一样操作Redis。但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。 RedisConfig.java 1234567891011121314151617181920212223242526272829@Configurationpublic class RedisConfig &#123; /*** * 自定义的redisTemplate * @param factory * @return */ @Bean public RedisTemplate&lt;Object, String&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;Object, String&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); //默认的序列化方式:jackson redisTemplate.setDefaultSerializer(jackson2JsonRedisSerializer); redisTemplate.setKeySerializer(RedisSerializer.string()); //设置了默认的序列化就不需要在设置下面的了，因为afterPropertiesSet()中会设置为默认的序列化方式 //redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); //redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer); //redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125;&#125; Redis工具类我们大家接触过Redis的都知道，Redis有5大常用数据类型，String、List、Hash、Set和ZSet。SpringBoot集成redis的RedisTemplate,也分别提供的对这些数据类型的操作。也有5大类： redisTemplate.opsForValue() //操作字符串 redisTemplate.opsForList() //操作List redisTemplate.opsForHash //操作hash redisTemplate.opsForSet //操作Set redisTemplate.opsForZet //操作Zset 但是对于Redis的具体类型的操作，SpringBoot提供的API并没有完全和Redis的命令统一，用起来有一点不爽，因此为了和Redis的命令保持统一（就像Jedis那样），我们可以对SpringBoot提供的Template中的API进行再次分装，写一个工具类，目的：一是保持和Redis命令的统一，二是练习一下以加深对RedisTemplate以及Redis命令的记忆和理解。 由于太多了所以我只展示部分代码，完整的代码大家可以到我的GitHub上查看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312@Componentpublic class RedisUtils &#123; @Autowired private RedisTemplate&lt;Object, String&gt; redisTemplate; /** * 设置某个key的过期时间 * * @param key * @param timeout * @return */ public boolean expire(String key, long timeout) &#123; if (timeout &gt; 0) &#123; try &#123; redisTemplate.expire(key, timeout, TimeUnit.SECONDS); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125; return false; &#125; /*** * 查看某个key的过期时间 * @param key * @return 过期时间 （秒/s） */ public long ttl(String key) &#123; if (null != key) &#123; Long expire = redisTemplate.getExpire(key, TimeUnit.SECONDS); if (Objects.nonNull(expire)) &#123; return expire; &#125; return -2L; &#125; return -2L; //key不存在，返回-2 &#125; /** * 判断是否存在某个key * * @param key * @return */ public boolean exists(String key) &#123; if (null != key) &#123; Boolean exists = redisTemplate.hasKey(key); return Objects.nonNull(exists); &#125; return false; &#125; /** * 获得某个key的类型 * * @param key * @return */ public DataType type(String key) &#123; if (null != key) &#123; return redisTemplate.type(key); &#125; return null; &#125; /** * 获得当前数据库中的所有key * * @param patten * @return */ public Set&lt;Object&gt; allKeys(Object patten) &#123; return redisTemplate.keys(patten); &#125; /** * 把当前库中的一个key移动到dbID这个数据库中 * @param key * @param dbID * @return */ public boolean move(String key, int dbID) &#123; if (null == key || dbID &lt; 0) &#123; return false; &#125; Boolean move = redisTemplate.move(key, dbID); return Objects.nonNull(move); &#125; /** * 删除一个或多个key * * @param key */ public void del(String... key) &#123; if (Objects.nonNull(key) &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key); &#125; else &#123; String s=append(key); if(Objects.nonNull(s)) &#123; redisTemplate.delete(s); &#125; &#125; &#125; &#125; /** * 设置字符串 * * @param key * @param value * @return */ public boolean set(String key, String value) &#123; if (Objects.nonNull(key) &amp;&amp; Objects.nonNull(value)) &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; return false; &#125; public boolean set(String key, String value, String command, long timout) &#123; if (Objects.nonNull(key) &amp;&amp; Objects.nonNull(value) &amp;&amp; Objects.nonNull(command) &amp;&amp; timout &gt; 0) &#123; if ("ex".equals(command.toLowerCase())) &#123; redisTemplate.opsForValue().set(key, value, timout, TimeUnit.SECONDS); &#125; else if ("px".equals(command.toLowerCase())) &#123; redisTemplate.opsForValue().set(key, value, timout, TimeUnit.MILLISECONDS); &#125; return true; &#125; return false; &#125; public boolean set(String key, String value, String absent) &#123; Boolean res=null; if (Objects.nonNull(key) &amp;&amp; Objects.nonNull(value) &amp;&amp; Objects.nonNull(absent)) &#123; if ("nx".equals(absent.toLowerCase())) &#123; res = redisTemplate.opsForValue().setIfAbsent(key, value); &#125; else if ("xx".equals(absent.toLowerCase())) &#123; res = redisTemplate.opsForValue().setIfPresent(key, value); &#125; &#125; return Objects.nonNull(res); &#125; public boolean set(String key, String value, String command, long timout, String absent) &#123; if (Objects.nonNull(command)) &#123; boolean res = this.set(key, value, absent); if (res) &#123; this.set(key, key, command, timout); return true; &#125; &#125; else if (Objects.nonNull(absent)) &#123; return this.set(key, value, absent); &#125; return false; &#125; /** * 为多个键分别设置它们的值 * * @param map */ public void mset(Map&lt;String, String&gt; map) &#123; if (Objects.nonNull(map) &amp;&amp; map.size() &gt; 0) &#123; redisTemplate.opsForValue().multiSet(map); &#125; &#125; /** * 为多个键分别设置它们的值，仅当键不存在时 * * @param map */ public void msetnx(Map&lt;String, String&gt; map) &#123; if (Objects.nonNull(map)) &#123; redisTemplate.opsForValue().multiSetIfAbsent(map); &#125; &#125; /** * 获得指定key的value * * @param key * @return */ public String get(String key) &#123; if (Objects.nonNull(key)) &#123; return redisTemplate.opsForValue().get(key); &#125; return null; &#125; /** * 获取所有给定键的值 * * @param keys * @return */ public List&lt;String&gt; mget(Collection&lt;String&gt; keys) &#123; if (Objects.nonNull(keys) &amp;&amp; keys.size() &gt; 0) &#123; return redisTemplate.opsForValue().multiGet(Collections.singleton(keys)); &#125; return null; &#125; /** * 截取指定key的value的部分 * * @param key * @param start 开始的下标 * @param stop 结束的下标 * @return */ public String getRange(String key, long start, long stop) &#123; if (Objects.nonNull(key)) &#123; return redisTemplate.opsForValue().get(key, start, stop); &#125; return null; &#125; /** * key--&gt;value对value的长度 * * @param key * @return */ public long strlen(String key) &#123; if (Objects.nonNull(key)) &#123; Long size = redisTemplate.opsForValue().size(key); return Objects.isNull(size) ? 0L : size; &#125; return 0L; &#125; /** * 字符串追加 * * @param key * @param s * @return 执行key追加后的 */ public long append(String key, String s) &#123; if (Objects.nonNull(key)) &#123; Integer length = redisTemplate.opsForValue().append(key, s); return Objects.isNull(length) ? strlen(key) : length; &#125; return 0L; &#125; public long incr(String key) &#123; return incrBy(key, 1); &#125; public long incrBy(String key, long increment) &#123; if (Objects.nonNull(key)) &#123; try &#123; Long value = redisTemplate.opsForValue().increment(key, increment); return Objects.isNull(value) ? 0L : value; &#125; catch (NumberFormatException ex) &#123; throw new NumberFormatException("非数字不可加"); &#125; &#125; return 0L; &#125; public long decr(String key) &#123; return this.decrBy(key, 1); &#125; public long decrBy(String key, long decrement) &#123; if (Objects.nonNull(key)) &#123; try &#123; Long value = redisTemplate.opsForValue().decrement(key, decrement); return Objects.isNull(value) ? 0L : value; &#125; catch (NumberFormatException ex) &#123; throw new NumberFormatException("非数字不可减"); &#125; &#125; return 0L; &#125; /** * 在指定偏移处开始的键处覆盖字符串的一部分 * * @param key * @param offset * @param value */ public void setRange(String key, long offset, String value) &#123; if (Objects.nonNull(key)) &#123; redisTemplate.opsForValue().set(key, value, offset); &#125; &#125; //省略....&#125;]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis之主从复制]]></title>
    <url>%2F2019%2F09%2F28%2FRedis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[主从复制概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(salve)。数据的复制是单向的，只能从主节点到从结点。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从结点（或没有从结点），但是一个从结点只能有一个主节点。 主从复制的作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 读写分离：可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量； 高可用的基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 主从复制启用前面提到过，默认情况下每台Redis服务器都是主节点（master）,而且如果没有配置的话，是没有从服务器的。（可以使用info replication命令查看一个Redis服务器的复制有关的信息） 有三种方式可以开启主从： 配置文件：在从服务器的配置文件中加入slaveof &lt;主节点ip&gt; &lt;主节点port&gt;。 启动命令：redis-server启动命令后面加入--slaveof &lt;主节点ip&gt; &lt;主节点port&gt;。 客户端命令：Redis服务器启动后，直接通过客户端执行命令slaveof &lt;主节点ip&gt; &lt;主节点port&gt;，返回OK后该Redis实例就成为了从节点。 Redis常用的主从拓扑1主N从所谓的1主N从指的是一个主Redis服务器（master）可以有一个或多个从Redis服务器（salve）,这种拓扑关系的特点是： 只有一个主节点，有一个或多个从结点； 主节点可读可写，从结点只能从主节点读数据，不能自己写数据； 当主服务节点宕机后（无论各种原因，反正主节点不能正常运行了），从服务节点不会自动变成主节点，而是保持自己从结点的身份继续运行（而且他从主节点复制的数据不会丢失，可以继续对外提供服务），直到主节点恢复后这些从结点又可一继续从主节点读数据； 当一以从服务器结点“挂掉”以后，再次重启后，他与先前的主节点没有任何关系了（在没有在配置文件中配置的前提下），除非在配置文件中配置过或者再次使用命令slaveof &lt;主节点ip&gt; &lt;主节点port&gt;连上主节点。 演示一：在客户端使用命令行在127.0.0.1:3679开启master，然后在127.0.0.1:3680/3681开启两个salve 然后关闭master节点，查看从服务节点，发现从服务节点没有自动升级为master，并且他之前从主节点复制来的数据还在，还可以向外提供服务： 之后重新启动master，查看从服务节点，发现从服务节点有重新连接上主服务节点了： 演示二：恢复到127.0.0.1:3679是master，127.0.0.1:3680/3681是127.0.0.1:3679的两个salve的状态，然后任意重启一个从服务器，观察发现这个服务器结点如果之前没有在配置文件中配置过，那么他将和master没有任何关系了： 薪火相传所谓”薪火相传“，指的是那种一个master连接了一个slave，然后这个slave结点又作为另一个slave的master节点…….依次向链表一样传递下去，这种拓扑的特点是： 只有这个传递链上的第一个master结点具有写的权限，其他的结点都是由读的权限； 这种模式下，减轻了master结点的压力，但是与之而来的问题是越往后的结点同步延时越大； 如果其中一个节点“挂了”，那么他后面的结点就无法同步到最新的数据了 演示：让127.0.0.1:3679作为127.0.0.1:3680的master,然后让127.0.0.1:3680作为127.0.0.1:3681的master: 反客为主“反客为主”说的就是当主服务器结点“挂了”以后，我们可以手动将一个从服务器节点指定为主服务器节点，然后让其他的从服务节点从这个新的master上复制： 演示：在客户端使用命令行在127.0.0.1:3679开启master，然后在127.0.0.1:3680/3681开启两个salve 然后主服务节点突然“挂了”，手动使用命令slaveof no one将原本的 slave 转成 master，停止与其他数据库的同步，然后将其他的slave和这个新的master交互： 这种模式下，在之后以前的主服务器再次启动后，它就与这个新建立的主从关系没有任何关系了。 Redis哨兵模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sentinel(哨兵)是用于监控redis集群中Master状态的工具，是Redis 的高可用性解决方案。Sentinel可以让redis实现主从复制，当一个集群中的master失效之后，sentinel可以选举出一个新的master用于自动接替master的工作，集群中的其他redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换。其结构如下: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。Sentinel由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。说的简单点，哨兵模式就是监控+自动版“反客为主”下图演示了哨兵的工作过程： 演示：首先我们在新建一个sentinel.conf配置文件，配置有关哨兵监控的信息，然后保存退出 让127.0.0.1:3679作为127.0.0.1:3680的master,然后让127.0.0.1:3680作为127.0.0.1:3681的master 一切设置好后，使用redis-sentinel sentinel.conf配置文件路径启动哨兵，让他监控master的状态： 之后关闭master，模拟服务器突然宕机等情况，发现哨兵自动通过投票选举出了新的master，并且把其他从服务器（slave）都拉到了这个新的master“旗下”： 那么如果之前的master重启回来，会不会有两个master冲突？ 不会，之前的master会在哨兵模式下变为slave从机： 主从复制的原理Redis主从复制的过程大体可以分成3个阶段：建立连接阶段 、数据同步阶段和命令传播阶段。 建立连接step1：保存主节点信息从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。(用info replication命令就可以查看) slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。 step2：建立socket连接&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点（slave）每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功： 从节点（slave）：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。 主节点（master）：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。 step3：发送ping命令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点（slave）成为主节点（master）客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。从节点发送ping命令后，可能出现3种情况： （1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。 （2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。 （3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。 step4：身份验证如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。 从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。 如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。 step5：发送从节点端口信息身份验证之后，从节点会向主节点发送其监听的端口号，主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。 数据同步阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。redis 同步有 2 个命令：sync 和psync，前者是 redis 2.8 之前的同步命令，后者是 redis 2.8 为了优化 sync 新设计的命令。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。 全量复制和增量复制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Redis 2.8以前，从结点向主节点发送的是sync命令同步数据的，这种同步方式是全量复制；但是在Redis 2.8 以后，从结点可以发送psync命令请求同步数据，此时根据主节点当前状态的不同，同步方式可能是全量复制和增量复制： 全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，这是一个非常耗费资源的操作。 流程如下： 发送 psync 命令（spync ？ -1） 主节点根据命令返回 FULLRESYNC 从节点记录主节点 ID 和 offset 主节点 bgsave 并保存 RDB 到本地 主节点发送 RBD 文件到从节点 从节点收到 RDB 文件并加载到内存中 主节点在从节点接受数据的期间，将新数据保存到“复制客户端缓冲区”，当从节点加载 RDB 完毕，再发送过去。（如果从节点花费时间过长，将导致缓冲区溢出，最后全量同步失败） 从节点清空数据后加载 RDB 文件，如果 RDB 文件很大，这一步操作仍然耗时，如果此时客户端访问，将导致数据不一致，可以使用配置slave-server-stale-data 关闭. 从节点成功加载完 RBD 后，如果开启了 AOF，会立刻做bgrewriteaof。以上红色字体的部分是整个全量同步耗时的地方。 增量复制：当从节点正在复制主节点时，如果出现网络闪断和其他异常，从节点会让主节点补发丢失的命令数据，主节点只需要将复制缓冲区的数据发送到从节点就能够保证数据的一致性，相比较全量复制，成本小很多。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行增量复制，仍使用全量复制。 当从节点出现网络中断，超过了 repl-timeout 时间，主节点就会中断复制连接。 主节点会将请求的数据写入到“复制积压缓冲区”，默认 1MB。 当从节点恢复，重新连接上主节点，从节点会将 offset 和主节点 id 发送到主节点。 主节点校验后，如果偏移量的数后的数据在缓冲区中，就发送 cuntinue 响应 —表示可以进行部分复制。 主节点将缓冲区的数据发送到从节点，保证主从复制进行正常状态。 psync命令的执行 首先从节点根据当前的状态，决定如何调用psync命令 如果从结点之前未执行过slavof或最近执行了slaveof no one 命令，则从结点发送命令pysnc ? -1，向主节点请求全量复制； 如果从结点之前执行了slaveof，则发送命令psync &lt;runid&gt; &lt;offset&gt;，其中runid为上次复制主节点的runid,offset为上次复制截止时从结点保存的复制偏量。 主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制： 如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制； 如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可； 如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC ，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。 命令传播阶段&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。 心跳机制主从节点在建立复制后，他们之间维护着长连接并彼此发送心跳命令。 心跳的关键机制如下： 主从都有心跳检测机制，各自模拟成对方的客户端进行通信，通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S。 主节点默认每隔 10 秒对从节点发送 ping 命令，可修改配置 repl-ping-slave-period 控制发送频率。 从节点在主线程每隔一秒发送replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量。 主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线。 总结一下：主-&gt;从：PING每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。 PING发送的频率由 repl-ping-slave-period 参数控制，单位是秒，默认值是10s。 从-&gt;主：REPLCONF ACK在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。 注意事项：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;延迟与不一致：命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis之事务]]></title>
    <url>%2F2019%2F09%2F26%2FRedis%E4%B9%8B%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Redis的事物 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发来的命令请求打断。 事务是一个原子操作：事务中的命令要么全部执行，要么全部不执行。 Redis事务相关的几个命令 multi：MULTI 命令用于开启一个事务，它总是返回 OK 。 MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC命令被调用时， 所有队列中的命令才会被执行。 exec ：执行所有的事物命令，EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。 discard： 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。 watch key [key ...]：监视一个或多个key(类似于乐观锁) unwatch：取消watch对所有key的监视 Redis事务的三个阶段 开始事务：使用multi命令开启一个事务，当一个事务被exec或discard后，改事务就宣告结束（无论有没有成功执行），下次在向开启事务就必须在使用这个命令开启事务。 命令入队：简单点说就是，开启事务后输入的命令不会立即执行，而是先入队，执行当exec后在一次性执行。 执行事务：使用exec命令执行事务 Redis事务使用示例：1、正常执行 2、取消事务 3、事务在执行 EXEC 之前，入队的命令可能会出错(语法上就是错误的)，执行exec时，整个事务都会失败。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。 4、事命令可能在 EXEC 调用之后失败（语法上没有错误，但是调用执行的时候出错了），在执行exec命令时，其他正确的命令可以正确执行，错误命令抛出错误 为什么Redis不支持回滚？通过上面的案例我们可以看到redis在事务中发生错误后是没有回滚的，而是继续执行余下的命令，那么redis为什么不支持事务回滚呢？从各方面考虑有以下两点原因： Redis命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，也就是说，从实用的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发过程中别发现，而不应出现在生产环境中。而且需要注意的是在通常情况下， 回滚并不能解决编程错误带来的问题。 因为redis不需要支持事务回滚，所以他可以在内部保持简单和快捷。 5、使用watch监控WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回nil-reply来表示事务已经失败。下面使用很典型的账户和消费问题来展示一下watch的作用。案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功 案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis持久化之RDB和AOF]]></title>
    <url>%2F2019%2F09%2F25%2FRedis%E6%8C%81%E4%B9%85%E5%8C%96RDB%E5%92%8CAOF%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，Redis是一种内存数据库，但是存在内存中的数据一断电后就消失了，Redis肯定没有这么弱。Redis也支持数据的持久化，Redis中有两种持久化方式RDB（Redis DataBase）和AOF（Append Only File）。 RDB（Redis DataBase）详解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDB持久化是将当前进程中的数据生成快照保存到硬盘，默认会在当前工作目录下生成dump.rdb文件，当Redis重启的时候会读取快照文件来恢复数据。RDB是Redis的默认持久化方式。有两种触发的方式：第一种是：手动在客户端使用save命令和bgsave命令触发；第二种是：在redis.conf配置文件中使用save &lt;seconds&gt; &lt;changes&gt;来配置后自动触发。 手动触发save命令和bgsave命令都可以生成RDB文件。 save命令会阻塞Redis服务器进程，直到RDB文件被创建出来为止，在Redis服务器阻塞期间，服务器无法处理任何请求。 bgsave命令会创建一个子进程（拷贝一份父进程），由子进程负责创建RDB文件，父进程（Redis主进程）可以继续处理请求。bgsave命令执行过程中，只有fork父进程时才会阻塞服务器进程，而对于save命令，整个执行过程都会阻塞服务器，因此在生产环境下要杜绝使用save的使用。而且在自动触发RDB持久化的时候，Redis也会选择bgsave而不是save。 自动触发设置自动触发 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动触发最常见的情况是在配置文件中通过`save `来配置，即只要在自定的seconds秒内只要发生了changes变化时，就会触发`bgsave`。redis默认的配置有三个： 123save 900 1 //当时间到900秒时，在此期间如果redis数据发生了至少1次变化，则执行bgsavesave 300 10 //当时间到300秒时，在此期间如果redis数据发生了至少10次变化，则执行bgsavesave 60 10000 //当时间到900秒时，在此期间如果redis数据发生了至少1次变化，则执行bgsave 自动触发的原理Redis的自动触发是通过serverCron函数、dirty计数器和lastave时间戳来实现的。 serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查save &lt;seconds&gt; &lt;changes&gt; 配置的条件是否满足，如果满足就执行bgsave。 dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。 lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。 也就是每隔100ms，执行serverCron函数；在serverCron函数中，遍历save &lt;seconds&gt; &lt;changes&gt; 配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save &lt;seconds&gt; &lt;changes&gt; 条件，只有下面两条同时满足时才算满足：&nbsp;&nbsp;&nbsp;&nbsp;（1）当前时间-lastsave &gt; seconds&nbsp;&nbsp;&nbsp;&nbsp;（2）dirty &gt;= changes 其他自动触发机制除了在配置文件中配置save &lt;seconds&gt; &lt;changes&gt; 来触发bgsave以外，还有别的情况会触发bgsave： 在主从复制场景下，如果从结点执行全量复制操作，则主结点回执性bgsave命令，并将dump.rdb文件发送给从结点。 在执行shutdown命令时，会自动执行rdb持久化，这一点通过redis的日志看到 RDB文件RDB的文件格式RDB文件是经过压缩的二进制文件，RDB的的文件格式如下图所示 其中各个字段的含义说明如下： REDIS：常量，保存着”REDIS”5个字符。 db_version：RDB文件的版本号，注意不是Redis的版本号。 SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。 EOF：常量，标志RDB文件正文内容结束。 check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。 RDB的存储路径RDB文件的存储路径既可以在redis.conf配置文件中配置，也可以在客户端通过命令动态设定： 在配置文件中可以设置dir参数来指定RDB文件的存放路径（AOF文件的默认的保存路径也是这个），redis默认是存放在当前工作目录下。也可以在配置文件中通过设置dbfilename指定RDB文件的名字，redis默认的文件名是dump。 动态设定：Redis启动后也可以在客户端使用config set dir /path来动态的改变RDB的存放路径，当然也可以通过config set dbfilename newfilenaem来设置RDB文件的名字。 RDB文件的压缩&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩会有一定的性能消耗，但是这样可以大大减小RDB文件的大小。但是需要特别注意的是：RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符进行的，且只有在字符串达到一定长度(20字节)时才会进行。 启动时加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDB文件的载入工作是在服务器启动的时候自动进行的，并没有专门的命令。但是当开启AOF后，Redis会优先加载AOF文件来恢复数据，只有当AOF关闭时，才会在Redis服务器启动的时候检测RDB文件，并自动加载。服务器载入RDB文件期间处于阻塞状态，直到加载完毕阻塞解除。Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。此时可以使用redis-check-rdb来修复RDB文件。 RDB优缺点总结最后以一幅图的方式总结RDB的优缺点： AOF（Append Only File）详解&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RDB持久化是将进程数据写入文件，而AOF用了和RDB完全不同的做法，AOF将Redis每次写操作记录到一个日志文件中，当Redis重启的时候会优先加载AOF（如果开启了AOF）文件，然后执行文件中的命令恢复数据，与RDB相比较AOF具有更好的实时性，也是当前主流的持久化方案。 开启AOFRedis服务器默认开启的是RDB，美哦与开启AOF，要开启AOF，需要在redis.conf中修改appendonly为yes，还可以在配置文件中修改AOF文件的名字等等，具体的可以参考我的这篇笔记：Redis配置文件redis.conf详解 AOF的执行流程由于需要记录Redis的每条写命令，因此AOF不需要触发，AOF的执行流程包括： 命令追加（append）:将Redis的写操作追加到缓冲区aof_buf 文件写入（write）和文件同步（sync）:根据不同的同步策略将aof_buf中的内容同步带硬盘 文件重写（rewrite）：定期重写AOF文件，达到压缩的目的。 命令追加(append)Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。 文件写入（write）和文件同步（sync）Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数： write函数：为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失 fsync函数：为了解决write函数数据丢失的问题，因此系统提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。 AOF缓存的同步文件策略有appendfsync控制，Redis提供了三种策略： always：命令写入aof_buf后立即调用系统的fsync函数同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。 no：命令写入aof_buf后调用系统的wirte函数，不对AOF文件做fsync同步，同步操作由系统负责，通常同步周期为30s。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。 everysec：命令写入aof_buf后调用系统的write函数，write完成后返回，fsync同步文件操作，有专门的线程每一秒调用一次。everysec是前面两种策略的折中，兼顾了性能和数据安全，也是Redis的默认配置。 文件重写（rewrite）AOF文件重写主要的作用就是对AOF文件进行压缩，文件重写就会定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写只是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取，写入操作。 为什么文件重写可以压缩AOF文件？ 过期的数据不需要再写入文件 无效的命令不再写入文件 多条命令可以合并为一条命令，比如sadd stu v1, sadd stu v2 ,sadd stu v2，这三条操作可以合并为一条sadd stu v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义 总之压缩的原理就是通过重写减小命令的数量从而减少了文件的大小。 文件重写的触发文件重写的触发有两种方式：第一种是在客户端使用bgrewriteaof命令触发；第二种是在配置文件中设置auto-aof-rewrite-min-size和auto-aof-rewrite-percentage，以及aof_current_size和aof_base_size状态确定触发时机。 手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似—都是fork子进程进行具体的工作，且都只有在fork时阻塞。使用bgrewriteaof后，可以看到服务器的日志如下： 自动触发：只是通过配置文件自动的触发重写，但是还是要使用bgrewirteaof这个命令，主要配置的参数如下： auto-aof-rewrite-min-size：执行AOF重写时，文件体积最小体积，默认为64MB。 uto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小和上一次重写AOF大小的比值，默认大小100。这些参数都可通过config get 参数来查看。 文件重写的流程 对照上图，文件重写的流程如下： 1、Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。 2、父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。 3.1、父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，此时可以响应其他命令。Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。 3.2、由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。 4、子进程根据内存快照，按照命令合并规则写入到新的AOF文件。 5.1、子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。 5.2、 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。 5.3、 使用新的AOF文件替换老文件，完成AOF重写。 AOF文件启动加载当开启AOF后，Redis重启会默认优先加载AOF文件来恢复数据；只有当AOF关闭时参会加载RDB文件。Redis加载AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中就会打印错误，并且Redis会启动失败。当AOF文件损坏后，我们可以使用redis-check-aof 这个工具来修复AOF文件。 AOF优缺点总结最后以一幅图片总结AOF的优缺点：]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis配置文件redis.conf详解]]></title>
    <url>%2F2019%2F09%2F24%2FRedis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; Redis脚本简介在我们介绍Redis的配置文件之前，我们先来说一下Redis安装完成后生成的几个可执行文件： redis-server 、redis-cli 、redis-benchmark 、redis-stat 、redis-check-dump、redis-check-aof : 1234567891011redis-server：Redis服务器的daemon启动程序。redis-cli：Redis命令行执行工具。当然，你也可以用telnet根据其纯文本协议来操作。redis-benchmark：Redis性能检测工具，测试Redis在你的系统及你的配置下的读写性能。redis-stat：Redis态检测工具，可以检测 Redis 当前状态参数及延迟状况（高版本的Redis将没有这个脚本）。redis-check-dump：Redis dump 数据文件的修复工具。redis-check-aof：Redis aof 日志文件修复工具。 &nbsp;&nbsp; Redis配置文件详解&nbsp;&nbsp;开头说明 开头说明中主要就是要注意在redis中内存大小写k和kb是不一样的，前者是1000的倍数，后者是1024的倍数。 &nbsp;&nbsp; INCLUDES &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INCLUDES的作用就是把其他关于redis的配置文件引入到redis.conf文件中使其生效，redis.conf就作为一个总闸一样，配置的方法是使用include来引入一个路径下配置文件（比如：include /path/aaa/other.conf）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，如果将此配置写在redis.conf 文件的开头，那么后面的配置会覆盖引入文件的配置，如果想以引入文件的配置为主，那么需要将 include 配置写在 redis.conf 文件的末尾。 &nbsp;&nbsp;MODULES 这个部分是用来引入自定义的模块的。通过这里的 loadmodule 配置将引入自定义模块来新增一些功能。 &nbsp;&nbsp;NETWORK bind： 绑定redis服务器网卡IP，默认为127.0.0.1，即本地回环地址。这样的话访问redis服务只能通过本机的客户端连接，而无法通过远程连接。如果bind被注掉了或者为空时会接收所有来自于可用网络的连接。 port： 指定redis运行的端口，默认的是6379。由于redis是单线程模型，因此单机开多个redis运行的时候会修改端口，除此而外一般保持默认的即可。 protected-mode：是否开启保护模式，默认是yes表示开启保护模式 timeout：设置客户端连接时的超时时间，单位：秒。当客户端在这段时间没有任何操作（空闲的），那么就会关闭连接。默认为0，表示永不关闭。 tcp-backlog: 设置tcp的backlog, backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列+已完成三次握手队列。在高并发环境下需要该backlog值来避免客户端连接问题。注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog两个值来达到想要的效果。 tcp-keepalive：表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方默认是300s，如果设置为0，表示不周期性检测。 &nbsp;&nbsp;GENERAL daemonize：设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认为no pidfile：配置pid文件路径，当Redis作为守护进程运行的时候，会把pid默认写到/var/redis/run/redis_6379.pid 文件里面 loglevel：定义日志级别。默认为notice。Redis中有4个日志级别： debug ：记录详细的日志，使用与开发、测试阶段 varbose：较多的日志 notice：适量的日志信息，适用于生产环境 warning：仅有部分重要、关键的才会被记录 logfile：配置日志文件默认存放的位置，默认会直接打印在终端的屏幕上 databases：设置数据库的数目。默认的数据库是DB0，有16个，可以使用select &lt;dbid&gt;命令选择不同的数据库。 always-show-logo：是否在启动的时候显示Redis的logo，默认为yes，即显示logo。 &nbsp;&nbsp;SNAPSHOTTING Snapshotting：快照。主要是用来配置持久化策略的。这一块的配置牵扯到Redis默认的持久化方案RDB，关于RDB的细节可以参考我的这篇笔记：Redis 持久化之RDB和AOF。 save：用来配置触发Redis的做持久化的条件，也就是什么时候将内存中的数据保存到硬盘中。默认配置如下： save 900 1：表示900s内如果有1个key变化，到时间（900s）后就把这段时间内的变化保存到磁盘 save 300 10： 表示300s内如果有10个key变化，到时间（300s）后就把这段时间内的变化保存到磁盘 save 60 10000 ：表示60s内如果有10000个key变化，到时间（60s）后就把这段时间内的变化保存到磁盘当然如果只是使用Redis的缓存功能，不需要持久化，那么可以把这些save注释掉，然后使用一个空字符串实现停用：save &quot;&quot; stop-writes-on-bgsave-error：当启用了RDB且最火一次后台保存数据失败，Redsi是否停止接收数据。默认值为yes，这会让用户意识到数据没有正确持久化到硬盘上，从而可以排错，否者没有人会注意到灾难发生了。 rdbcompression：对于存储到磁盘中的快照，可以设置时候惊进行压缩存储。默认值是yes，redis会使用LZF算法进行压缩。但是压缩会带来一定的CPU消耗，如果关闭后存储在磁盘上的快照将会非常大。 rdbchecksum：在存储快照后，我们还可以让Redis使用CRC64算法来进行数据校验。默认是yes，这样会带来10%的性能消耗。 dbfilename：设置快照的文件名，默认名字是dump.rdb。 dir：设置快照文件的存放路径，这个配置项必须自定的是一个目录，而不能是一个文件名。保存的是上面dbfilename，默认保存到当前目录下。 &nbsp;&nbsp;REPLICATION slave-serve-stale-data：当一个slave和一个master失去联系，或者复正在进行的时候，slave可能会有两种表现： 如果是yes，slave任然会应答客户端请求，但是返回的数据是过时的。 如果是no，在执行除了info he salvaof之外的其他命令时，slave都将返回一个“SYNC with master in progress”错误 slave-read-only：配置Redis的Slave示例是否接受写操作，即Slave是否为只读Redis。默认值是yes，Slave为只读。 repl-diskless-sync：主从复制是否使用无硬盘复制功能。默认值为no。 repl-disless-sync-delay：当启用无硬盘备份，服务器等待一段时间后才会通过套接字向从站传送RDB文件，这个等待时间是可配置的。 这一点很重要，因为一旦传送开始，就不可能再为一个新到达的从站服务。从站则要排队等待下一次RDB传送。因此服务器等待一段 时间以期更多的从站到达。延迟时间以秒为单位，默认为5秒。要关掉这一功能，只需将它设置为0秒，传送会立即启动。默认值为5。 repl-disalbe-tcp-nodelay：同步之后是否禁用从站上TCP_NODELAY。如果yes，表示redis会使用较少的TCP包和带宽向从站发送数据。但是这回导致从站增加数据延时；如果选择no，从站的数据延时不会那么多，但备份需要的带宽相对较多。Redis默认设置是no。 &nbsp;&nbsp;SECURITY rename-command：从命名命令。例如对于一些危险的命令： flushdb ：清空当前数据库 flushall：清空所有数据库 config：客户端连接后可配置服务器 keys：查看数据库中所有的键 requirepass：设置Redis连接密码，如果配置了连接密码，客户端在连接Redis的时候需要通过auth &lt;password&gt;命令来验证。默认是关闭的。 作为服务端redis-server，常常需要禁用以上命令来使得服务器更加安全，禁用的具体做法是：(比如禁用FLUSHALL命令)： rename-command FLUSHALL &quot;&quot; 也可以保留这个命令但是把它重命名，这样不知道重命名后的命令的人将无法使用这些危险的命令，从而可以保证系统数据的安全： rename-command FLUSHALL sfr443g432 这样，重启服务器后则需要使用新命令来执行操作，否则服务器会报错unknown command。 &nbsp;&nbsp;CLIENTS maxclients：设置客户端最大的连接数，默认是10000个连接。当客户端连接数到达限制是，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息。如果设置为0，表示不作限制。 &nbsp;&nbsp;MEMORY MANAGEMENT maxmemory：指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区 maxmemory-policy：当内存使用达到最大值时，redis应该采用的内存清理策略。有以下几种可以选择：volatile-lru：利用LRU算法移除设置过过期时间并且最近很少使用过的key allkeys-lru：利用LRU算法移除任何最近很少使用过的key volatile-random：随机移除设置过过期时间的key allkeys-random：随机移除任何key volatile-ttl：移除即将过期的key noeviction：不移除任何key，返回写错误。 maxmemory-samples：设置样本数量，LRU算法和最小TTL算法都不是精确的算法，而是估算值，所以可以设置样本的大小。默认值是5，即，使用5个样本。 &nbsp;&nbsp; APPEND ONLY MODE 具体的原理可以参考我的另一篇笔记：Redis 持久化之RDB和AOF appendonly：默认redis使用的是RDB方式持久化，这种方式在许多应用中已经足够用了。但是对于数据一致性要求很高的应用，如果还是只使用RDB,一旦redis宕机，会导致可能有几分钟的数据丢失，这种场景下就需要使用AOF（另一种持久化方式），可以提供更好的持久化特性以及更高的数据一致性。将appendonly置为yes开启AOF，Redis将会把每次写入的数据在接收后都写入appendonly.aof文件（默认的文件名），每次启动的时候会优先加载appendonly.aof这个文件到内存中。默认值是no。 appendfilename：aof文件的默认文件名，默认值是appendonly.aof appendfsync：aof持久化化策略配置。有三个值可以选： no：不执行fsync，由操作系统保证数据同步到磁盘，速度最快 always：每次写入都执行fsync，以保证数据同步到磁盘，速度最慢 everysec：每秒执行一次fsync，这样aof就可能会对时1s的数据 （默认值，通常来说能在速度和数据安全性之间取得比较好的平衡。） no-appendfsync-on-rewirite：设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入.官方文档建议如果你有特殊的情况可以配置为’yes’。但是配置为’no’是最为安全的选择。 auto-aof-rewrite-percentage: aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。默认值是100 auto-aof-rewrite-min-size：AOF文件到达重写的阈值，避免了达到约定百分比但尺寸仍然很小的情况还要重写，默认64m，这点内存啥都干不了，一般设置都是以GB为单位。 aof-load-truncated：如果设置为yes，如果一个因异常被截断的AOF文件被redis启动时加载进内存，redis将会发送日志通知用户；如果设置为no，redis将会拒绝启动。此时需要用”redis-check-aof”工具修复文件。 aof-use-rdb-preamble：默认为yes，就是使用RDB文件格式来保存AOF文件，设置为no就会使用AOF默认的键值的方式保存客户端的所有写操作。 &nbsp;&nbsp; LUA SCRIPTING lua-time-limit：一个lua脚本执行的最大时间，单位：ms。默认值5000。 &nbsp;&nbsp; REDIS CLUSTER cluster-enable：是否开启集群，默认是不开启的。 cluster-config-file：集群配置文件名称，每个节点都有一个集群相关的配置文件，持久化保存集群的信息。这个文件不需要手动配置，它由redis生成并更新。默认配置为nodes-6379.conf cluster-node-timeout：可以设置值为15000。节点互连超时的阈值，集群节点超时毫秒数。 cluster-slave-validity-factor：在进行故障转移的时候，全部slave都会请求申请为master，但是有些slave可能与master断开连接一段时间了， 导致数据过于陈旧，这样的slave不应该被提升为master。该参数就是用来判断slave节点与master断线的时间是否过长。判断方法是：比较slave断开连接的时间和(node-timeout * slave-validity-factor) + repl-ping-slave-period 如果节点超时时间为三十秒, 并且slave-validity-factor为10,假设默认的repl-ping-slave-period是10秒，即如果超过310秒slave将不会尝试进行故障转移。 cluster-migration-barrier：master的slave数量大于该值，slave才能迁移到其他孤立master上，如这个参数若被设为2，那么只有当一个主节点拥有2 个可工作的从节点时，它的一个从节点会尝试迁移。 cluster-require-full-coverage：默认情况下，集群全部的slot有节点负责，集群状态才为ok，才能提供服务。 设置为no，可以在slot没有全部分配的时候提供服务。不建议打开该配置，这样会造成分区的时候，小分区的master一直在接受写请求，而造成很长时间数据不一致。]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis五大常用数据类型]]></title>
    <url>%2F2019%2F09%2F23%2FRedis%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[redis命令参考：http://redisdoc.com/ Redis 键(key)的有关命令keys *&nbsp;查看当前数据库中的所有键 exists key&nbsp;判断是否存在某个key，如果存在返回1,不存在返回0 move key dbId&nbsp;把某个key移动到指定的数据库中 expire key seconds&nbsp;为某个key设置过期时间，时间单位：秒 ttl key&nbsp; 查看某个key离过期还有多久，单位：秒 type key&nbsp;查看某个key的数据类型 Redis String有关命令SET key value将字符串value关联到键key。如果 key 已经持有其他值， SET 就覆写旧值， 无视类型。可选参数： EX seconds ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。 PX milliseconds ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。 NX ： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。 XX ： 只在键已经存在时， 才对键进行设置操作。 当 SET 命令对一个带有生存时间（TTL）的键进行设置之后， 该键原有的 TTL 将被清除。 GET key返回与键 key 相关联的字符串值，如果没有这个key，返回nil。 1234567891011121314151617181920212223242526127.0.0.1:6379&gt; set user1 wangwu ex 60 #设置键user1的值为wangwu,存活时间是60sOK127.0.0.1:6379&gt; ttl user1(integer) 55127.0.0.1:6379&gt; get user1"wangwu"127.0.0.1:6379&gt; ttl user1(integer) 38127.0.0.1:6379&gt; ttl user1(integer) -2127.0.0.1:6379&gt; get user1 #60s后user1销毁(nil)127.0.0.1:6379&gt; set user1 lisi px 5000 #设置user1的存活时间是5000ms（5s）OK127.0.0.1:6379&gt; ttl user1(integer) -2127.0.0.1:6379&gt; get user1 #5s后user1销毁(nil) 127.0.0.1:6379&gt; set user1 lisi NX #当user1这个主键不存在的时候才设置值OK127.0.0.1:6379&gt; get user1"lisi"127.0.0.1:6379&gt; set user1 xiaoming XX #当user1这个主键存在的时候才设置值OK127.0.0.1:6379&gt; get user1"xiaoming" APPEND key value如果键 key 已经存在并且它的值是一个字符串， APPEND 命令将把 value 追加到键 key 现有值的末尾。如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。执行成功后会返回当前value的长度。 STRLEN key 返回与key关联的value的字符串的长度，当key不存在的时候返回0，当key不是字符串的时候使用这个命令会报错。 INCR key为键 key 储存的数字值加上一。如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。 INCRBY key increment为键 key 储存的数字值加上增量 increment 。如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 INCRBY 命令。如果键 key 储存的值不能被解释为数字， 那么 INCRBY 命令将返回一个错误 DECR key为键 key 储存的数字值减去一。如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECR 操作。如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。 DECRBY key decrement将键 key 储存的整数值减去减量 decrement 。如果键 key 不存在， 那么键 key 的值会先被初始化为 0 ， 然后再执行 DECRBY 命令。如果键 key 储存的值不能被解释为数字， 那么 DECRBY 命令将返回一个错误。 注意：上面这4个命令只能用于value是数字值的，而且这些操作执行后都会返回加/减操作后的值，且仅仅支持 64 位(bit)有符号数字表示之内。 GETRANGE key start end返回键key 储存的字符串值的指定部分， 字符串的截取范围介于start 和 end 两个偏移量。 SETRANGE key offset value从偏移量 offset 开始， 用 value 参数覆写(overwrite)键 key 储存的字符串值。不存在的键 key 当作空白字符串处理。Redis允许的字符串最大的512M，即：能够使用的最大偏移量为 2^29-1(536870911)，但是请别这样做，除非你想上午还在写码，下午就被开除！！！ MSET key value [key value …]同时为多个键设置值。如果某个给定键已经存在， 那么 MSET 将使用新值去覆盖旧值。MSET 是一个原子性(atomic)操作， 所有给定键都会在同一时间内被设置， 不会出现某些键被设置了但是另一些键没有被设置的情况。 MGET key [key …]返回给定的一个或多个字符串键的值。如果给定的字符串键里面， 有某个键不存在， 那么这个键的值将以特殊值 nil 表示 MSETNX key value [key value …]当且仅当所有给定键都不存在时， 为所有给定键设置值。即使只有一个给定键已经存在， MSETNX 命令也会拒绝执行对所有键的设置操作。MSETNX 是一个原子性(atomic)操作， 所有给定键要么就全部都被设置， 要么就全部都不设置， 不可能出现第三种状态。 Redis List常用命令LPUSH key value [value …]将一个或多个值 value 插入到列表key的表头。如果有多个 value 值，那么各个value值按从左到右的顺序依次插入到表头，List中允许有重复的值。 RPUSH key value value …]将一个或多个值value 插入到列表key 的表尾(最右边)。如果有多个 value值，那么各个 value值按从左到右的顺序依次插入到表尾 LRANGE key start end返回列表key 中指定区间内的元素，区间以偏移量 start 和end指定。下标(index)参数 start和end都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 LPUSHX key value当且仅当 key存在并且是一个列表时才将值 value 插入到列表 key 的表头。 RPUSH key value当且仅当 key存在并且是一个列表时才将值 value 插入到列表key 的表尾。 123456789101112131415161718192021222324252627282930127.0.0.1:6379&gt; lpush mylist1 a b c d e f g #a,b,c,d,e,f依次圧桟的效果(integer) 7 127.0.0.1:6379&gt; rpush mylist2 1 2 3 4 5 6 7 #1,2,3,4,5,6,7依次入队的效果(integer) 7127.0.0.1:6379&gt; lrange mylist1 0 -11) "g"2) "f"3) "e"4) "d"5) "c"6) "b"7) "a"127.0.0.1:6379&gt; lrange mylist2 0 31) "1"2) "2"3) "3"4) "4"127.0.0.1:6379&gt; lpushx language java python php #对一个不存在的list使用lpush不会成功的(integer) 0127.0.0.1:6379&gt; lrange language 0 -1(empty list or set)127.0.0.1:6379&gt; lpush language java(integer) 1127.0.0.1:6379&gt; lpushx language python php js(integer) 4127.0.0.1:6379&gt; lrange language 0 -11) "js"2) "php"3) "python"4) "java" LPOP key移除并返回列表 key 的头元素。当元素不存在时返回nil。 RPOP key移除并返回列表 key 的尾元素。当元素不存在时返回nil。 RPOPLPUSH source destination将 source弹出的元素插入到列表 destination ，作为destination 列表的的头元素。如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849127.0.0.1:6379&gt; lrange mylist1 0 -1 #查看mylist1列表中的所有元素1) "g"2) "f"3) "e"4) "d"5) "c"6) "b"7) "a"127.0.0.1:6379&gt; lpop mylist1 #相当于mylist1栈顶元素出栈"g"127.0.0.1:6379&gt; lpop mylist1 "f"127.0.0.1:6379&gt; rpop mylist1 #相当于mylist1队首元素出队"a"127.0.0.1:6379&gt; rpop mylist1"b"#rpoplpush测试27.0.0.1:6379&gt; lrange mylist2 0 -11) "1"2) "2"3) "3"4) "4"5) "5"6) "6"7) "7"127.0.0.1:6379&gt; rpoplpush mylist1 mylist2 #mylist1栈顶元素出栈的元素入栈到mylist2"c"127.0.0.1:6379&gt; lrange mylist2 0 -11) "c"2) "1"3) "2"4) "3"5) "4"6) "5"7) "6"8) "7"127.0.0.1:6379&gt; rpoplpush mylist2 mylist2 #mylist2栈顶元素出栈的元素入栈到mylist2,形成列表的旋转"7"127.0.0.1:6379&gt; lrange mylist2 0 -11) "7"2) "c"3) "1"4) "2"5) "3"6) "4"7) "5"8) "6"127.0.0.1:6379&gt; LLEN key返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 。如果 key 不是列表类型，返回一个错误。 LREM key count value 当count&gt;0表示从表头开始搜索并删除count个和value相等的元素 当count&lt;0表示从表尾开始搜索并删除count个和vlaue相等的元素 当count=0表示删除表中所有的和vlaue相等的元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657127.0.0.1:6379&gt; lpush list 1 2 3 4 4 3 2 1 5 6 7 8 3 3 (integer) 14127.0.0.1:6379&gt; lrange list 0 -1 #查看所有的元素 1) "3" 2) "3" 3) "8" 4) "7" 5) "6" 6) "5" 7) "1" 8) "2" 9) "3"10) "4"11) "4"12) "3"13) "2"14) "1"127.0.0.1:6379&gt; lrem list 2 3 #删除列表中从开头的2个3(integer) 2127.0.0.1:6379&gt; lrange list 0 -1 1) "8" 2) "7" 3) "6" 4) "5" 5) "1" 6) "2" 7) "3" 8) "4" 9) "4"10) "3"11) "2"12) "1"127.0.0.1:6379&gt; lrem list -2 1 #删除列表中从结尾开始的2个1(integer) 2127.0.0.1:6379&gt; lrange list 0 -1 1) "8" 2) "7" 3) "6" 4) "5" 5) "2" 6) "3" 7) "4" 8) "4" 9) "3"10) "2"127.0.0.1:6379&gt; lrem list 0 4 #删除列表中全部的4(integer) 2127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "7"3) "6"4) "5"5) "2"6) "3"7) "3"8) "2"127.0.0.1:6379&gt; trim start end对一个列表进行截取，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。 12345678910111213141516127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "7"3) "6"4) "5"5) "2"6) "3"7) "3"8) "2"127.0.0.1:6379&gt; ltrim list 0 3 #截取0-3,即列表中前4个元素，其余元素全部删除OK127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "7"3) "6"4) "5" LINDEX key index返回列表 key 中，下标为 index 的元素。下标(index)参数以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。 123456789101112127.0.0.1:6379&gt; lrange list 0 -1 #列表中的所有元素1) "8"2) "7"3) "6"4) "5"127.0.0.1:6379&gt; lindex list 0 #查看列表中的第一个元素"8"127.0.0.1:6379&gt; lindex list 1 #查看列表中的第二个元素"7"127.0.0.1:6379&gt; lindex list -1 #查看列表中的倒数第一个元素"5"127.0.0.1:6379&gt; LINSERT key BEFORE|AFTER pivot value将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。当 pivot 不存在于列表 key 时，不执行任何操作。当 key 不存在时， key 被视为空列表，不执行任何操作 1234567891011121314151617181920212223127.0.0.1:6379&gt; lrange list 0 -1 #查看list中的所有元素1) "8"2) "7"3) "6"4) "5"127.0.0.1:6379&gt; linsert list before 7 java #在7前面插入java(integer) 5127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "java"3) "7"4) "6"5) "5"127.0.0.1:6379&gt; linsert list after 7 js #在7后面插入js(integer) 6127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "java"3) "7"4) "js"5) "6"6) "5"127.0.0.1:6379&gt; LSET key index vlaue将列表 key 下标为 index 的元素的值设值为 value 。当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。 1234567891011121314151617127.0.0.1:6379&gt; lrange list 0 -11) "8"2) "java"3) "7"4) "js"5) "6"6) "5"127.0.0.1:6379&gt; lset list 0 phone #设置列表的第一个元素为phoneOK #设置成功了127.0.0.1:6379&gt; lrange list 0 -1 1) "phone"2) "java"3) "7"4) "js"5) "6"6) "5"127.0.0.1:6379&gt; Redis Set常用命令SADD key member [member …]将一个或多个member 元素加入到集合 key 当中，已经存在于集合的 member元素将被忽略。假如 key 不存在，则创建一个只包含 member元素作成员的集合。会返回被添加到集合中元素的个数，不包括重复的元素。 SMEMBERS key返回集合key中的所有成员，不存在的 key 被视为空集合。 SISMEMBERS key member判断 member元素是否集合 key 的成员。如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。 12345678910111213141516171819202122127.0.0.1:6379&gt; sadd myset a b c d e #向集合中添加成员a,b,c,d,e(integer) 5127.0.0.1:6379&gt; smembers myset #查看集合中的所有成员1) "d"2) "b"3) "c"4) "a"5) "e"127.0.0.1:6379&gt; sadd myset d e f g #集合中是没有重复值的，如果sadd的值在集合中已经有了，那就会被忽略(integer) 2127.0.0.1:6379&gt; smembers myset1) "e"2) "f"3) "b"4) "d"5) "g"6) "a"7) "c"127.0.0.1:6379&gt; sismember myset g #判断元素g是否是myset中的成员(integer) 1127.0.0.1:6379&gt; sismember myset sdsds(integer) 0 SCARD key返回集合 key 的基数(集合中元素的数量)。 SREM key [key ...]移除集合key 中的一个或多个member元素，不存在的 member元素会被忽略。 12345678910111213141516127.0.0.1:6379&gt; smembers myset1) "e"2) "f"3) "b"4) "d"5) "g"6) "a"7) "c"127.0.0.1:6379&gt; srem myset e f #删除集合中的e,f(integer) 2127.0.0.1:6379&gt; smembers myset1) "b"2) "d"3) "g"4) "a"5) "c" SRANDMEMBER key count如果命令执行时，只提供了 key 参数，那么返回集合中的一个随机元素。从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的count 参数： 如果count 为正数，且小于集合基数，那么命令返回一个包含count 个元素的数组，数组中的元素各不相同。如果 count大于等于集合基数，那么返回整个集合。 如果 count为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count的绝对值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344127.0.0.1:6379&gt; sadd set01 1 2 3 4 5 6 7 8 9 10 (integer) 10127.0.0.1:6379&gt; smembers set01 1) "1" 2) "2" 3) "3" 4) "4" 5) "5" 6) "6" 7) "7" 8) "8" 9) "9"10) "10"127.0.0.1:6379&gt; srandmember set01 5 #从set01这个集合中随机抽取5个数组成数组，这些数没有重复的1) "2"2) "1"3) "5"4) "8"5) "3"127.0.0.1:6379&gt; srandmember set01 51) "1"2) "8"3) "6"4) "10"5) "9"127.0.0.1:6379&gt; srandmember set01 51) "7"2) "4"3) "8"4) "10"5) "9"127.0.0.1:6379&gt; srandmember set01 -5 #从set01这个集合中随机抽取5个数组成数组，这些数有可能会重复1) "5"2) "1"3) "5"4) "7"5) "7"127.0.0.1:6379&gt; srandmember set01 -51) "6"2) "5"3) "5"4) "2"5) "9"127.0.0.1:6379&gt; SPOP key count移除并返回集合中的一个或多个随机元素。 12345678910111213141516171819202122232425127.0.0.1:6379&gt; smembers set01 1) "1" 2) "2" 3) "3" 4) "4" 5) "5" 6) "6" 7) "7" 8) "8" 9) "9"10) "10"127.0.0.1:6379&gt; spop set01 1 #随机移除一个元素并返回这个元素1) "3"127.0.0.1:6379&gt; spop set01 5 #随机移除5个元素并返回元素1) "2"2) "5"3) "8"4) "6"5) "1"127.0.0.1:6379&gt; smembers set011) "4"2) "7"3) "9"4) "10"127.0.0.1:6379&gt; SMOVE source destination member将 member 元素从 source 集合移动到 destination 集合。SMOVE 是原子性操作。 如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。 当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。 12345678910111213141516127.0.0.1:6379&gt; keys *1) "set01"127.0.0.1:6379&gt; sadd set02 a b c d e f(integer) 6127.0.0.1:6379&gt; keys *1) "set01"2) "set02"127.0.0.1:6379&gt; smove set02 set01 a(integer) 1127.0.0.1:6379&gt; smembers set011) "9"2) "7"3) "10"4) "4"5) "a"127.0.0.1:6379&gt; Set集合的数学操作命令SDIFF key [key …]返回一个集合的全部成员，该集合是所有给定集合之间的差集。不存在的 key 被视为空集。 123456789101112127.0.0.1:6379&gt; sadd A 1 2 3 4 5(integer) 5127.0.0.1:6379&gt; sadd B 1 2 3 a c d(integer) 6127.0.0.1:6379&gt; sdiff A B #求A-B,即A有B没有的成员1) "4"2) "5"127.0.0.1:6379&gt; SDIFF B A #求B-A，即B有A没有的成员1) "d"2) "c"3) "a"127.0.0.1:6379&gt; SINTER key [key ...]返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。 123456789127.0.0.1:6379&gt; sinter A B #求A∩B，即A,B公有的成员1) "1"2) "2"3) "3"127.0.0.1:6379&gt; sinter B A #求B∩A1) "1"2) "2"3) "3"127.0.0.1:6379&gt; SUNION key [key ...]返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。 12345678910111213141516171819127.0.0.1:6379&gt; SUNION A B #求A∪B，即A，B中的所有元素1) "2" 2) "1"3) "4"4) "3"5) "5"6) "d"7) "c"8) "a"127.0.0.1:6379&gt; SUNION B A1) "1"2) "2"3) "4"4) "3"5) "5"6) "d"7) "c"8) "a"127.0.0.1:6379&gt; Redis Hash常用命令HSET key filed vlaue [filed value ...]将哈希表 key中域 field 的值设置为 value 。如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。 HGET key filed返回哈希表中给定域的值。如果给定的域或者hash表不存在，返回nil。 HGETALL key返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。 HMSET key filed value [filed value ...]同时将多个 field-value (域-值)对设置到哈希表 key 中。此命令会覆盖哈希表中已存在的域。如果 key 不存在，一个空哈希表会被创建并执行 HMSET 操作。这个的使用和HSET 的用法一样。 HMGET key filed回哈希表 key 中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个 nil 值。这个命令的作用和HEGT的作用一样。 123456789101112131415127.0.0.1:6379&gt; hset student name zhansan age 20 gender M #hash以key-value的形式存值(integer) 3127.0.0.1:6379&gt; hget student name #获得student的name属性的值"zhansan"127.0.0.1:6379&gt; hget student age #获得student的age属性的值"20"127.0.0.1:6379&gt; hget student gender #获得student的gender属性的值"M"127.0.0.1:6379&gt; hgetall student 1) "name" 2) "zhansan" 3) "age" 4) "20" 5) "gender" 6) "M" HSETNX key filed value当且仅当域field 尚未存在于哈希表key中的情况下， 将它的值设置为 value 。如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。如果哈希表 hash 不存在， 那么一个新的哈希表将被创建并执行 HSETNX 命令 HEXISTS key filed检查给定域 field 是否存在于哈希表 hash 当中。存在返回1，不存在返回0。 123456789101112131415161718192021222324127.0.0.1:6379&gt; hgetall student #得到hash表中所有student的属性（奇数）和值（偶数） 1) "name" 2) "zhansan" 3) "age" 4) "20" 5) "gender" 6) "M"127.0.0.1:6379&gt; hsetnx student name lisi #给一个存在的属性设值，是不会成功的(integer) 0127.0.0.1:6379&gt; hset student class IOT(integer) 1127.0.0.1:6379&gt; hsetnx student address aabbcc #给一个不存在的属性设值会成功(integer) 1127.0.0.1:6379&gt; HEXISTS student address #原先没有的属性address现在已经有了(integer) 1127.0.0.1:6379&gt; hgetall student 1) "name" 2) "zhansan" 3) "age" 4) "20" 5) "gender" 6) "M" 7) "address" 8) "aabbcc" HLEN key返回哈希表 key 中域的数量。 12345678910111213127.0.0.1:6379&gt; hgetall student 1) "name" 2) "zhansan" 3) "age" 4) "20" 5) "gender" 6) "M" 7) "class" 8) "IOT" 9) "address"10) "aabbcc"127.0.0.1:6379&gt; hlen student #返回hash表student中属性的个数(integer) 5 HSTRLEN key filed返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度（string length）。如果给定的键或者域不存在， 那么命令返回 0 。 12345678910111213141516127.0.0.1:6379&gt; hgetall student 1) "name" 2) "zhansan" 3) "age" 4) "20" 5) "gender" 6) "M" 7) "class" 8) "IOT" 9) "address"10) "aabbcc"127.0.0.1:6379&gt; hstrlen student name #返回student表中name属性的vlaue的长度(integer) 7127.0.0.1:6379&gt; hstrlen student address #返回student表中address属性的vlaue的长度(integer) 6127.0.0.1:6379&gt; HINCRBY key filed increment为哈希表key中的域field的值加上增量increment。增量也可以为负数，相当于对给定域进行减法操作。如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。 HINCRBYFLOAT key filed increment和HINCRBY key filed increment的作用一样，都是哈希表key中的域field的值加上增量increment，但是这里的增量是浮点数。 1234567891011127.0.0.1:6379&gt; hincrby student age 2 #给studnet表中的age属性增加2(integer) 22127.0.0.1:6379&gt; hincrby student age 2(integer) 24127.0.0.1:6379&gt; hincrby student age 2(integer) 26 127.0.0.1:6379&gt; hget student age"26"127.0.0.1:6379&gt; hincrbyfloat student age 0.5 #给studnet表中的age属性增加0.5"26.5"127.0.0.1:6379&gt; HKEYS key返回哈希表key中的所有域。 HVALS key返回哈希表key中的所有域的值。 12345678910111213127.0.0.1:6379&gt; hkeys student #得到hash表中的所有属性（域）1) "name"2) "age"3) "gender"4) "class"5) "address"127.0.0.1:6379&gt; hvals student #得到hash表中的所有属性对应的值1) "zhansan"2) "26.5"3) "M"4) "IOT"5) "aabbcc"127.0.0.1:6379&gt; Redis ZSet常用命令ZADD key score member [score member ...]将一个或多个 member 元素及其 score值加入到有序集key 当中。如果某个 member 已经是有序集的成员，那么更新这个member的 score值，并通过重新插入这个 member元素，来保证该member在正确的位置上。score 值可以是整数值或双精度浮点数。如果 key 不存在，则创建一个空的有序集并执行ZADD 操作。 ZRANGE key start end [withscore]返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。如果需要成员按 score 值递减(从大到小)来排列，可以使用 ZREVRANGE key start end withscore ZREVRANGE key start end [withscores]返回有序集key中，指定区间内的成员。其中成员的位置按 score值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。 123456789101112131415161718192021222324252627127.0.0.1:6379&gt; zadd stu 70 v1 80 v2 90 v3 100 v4 #和set大致类似，只是这里每一个score和member是一个整体，按照score的大小排序(integer) 4127.0.0.1:6379&gt; ZRANGE stu 0 -1 #默认升序排列1) "v1"2) "v2"3) "v3"4) "v4"127.0.0.1:6379&gt; zrange stu 0 -1 withscores #使用withscores可以打印出score1) "v1"2) "70"3) "v2"4) "80"5) "v3"6) "90"7) "v4"8) "100"#逆序打印有序集的成员127.0.0.1:6379&gt; zrevrange stu 0 -1 withscores1) "v4"2) "100"3) "v3"4) "90"5) "v2"6) "80"7) "v1"8) "70" ZRANGEBYSCORE key min max [withscores] [limit offset count]返回有序集 key中，所有 score 值介于min和max之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。具有相同 score 值的成员按字典序(lexicographical order)来排列(该属性是有序集提供的，不需要额外的计算)。 可选的 LIMIT 参数指定返回结果的数量及区间(就像SQL中的SELECT LIMIT offset, count )，注意当 offset 很大时，定位offset的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。 可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 1234567891011121314151617181920212223242526272829303132333435#打印出score介于[60 90]的值127.0.0.1:6379&gt; zrangebyscore stu 60 90 1) "v1"2) "v2"3) "v3" #打印出score介于[60 90]的值并且打印出对应的score127.0.0.1:6379&gt; zrangebyscore stu 60 90 withscores 1) "v1"2) "70"3) "v2"4) "80"5) "v3"6) "90"#打印出score介于[60 90)的值，并且打印出score127.0.0.1:6379&gt; zrangebyscore stu 60 (90 withscores 1) "v1"2) "70"3) "v2"4) "80"#打印出score介于(60 90)的值，并且打印出score127.0.0.1:6379&gt; ZRANGEBYSCORE stu (60 (90 withscores1) "v1"2) "70"3) "v2"4) "80"#打印出score介于[60 90]并且是从0（第一个元素）开始的2个元素127.0.0.1:6379&gt; zrangebyscore stu 60 90 limit 0 21) "v1"2) "v2"#打印出score介于[60 90]并且是从0（第一个元素）开始的2个元素，并且打印出score127.0.0.1:6379&gt; ZRANGEBYSCORE stu 60 90 withscores limit 0 21) "v1"2) "70"3) "v2"4) "80" ZREM key member [menber ...]移除有序集key中的一个或多个成员，不存在的成员将被忽略。 12345678910111213141516171819127.0.0.1:6379&gt; zrange stu 0 -1 withscores1) "v1"2) "70"3) "v2"4) "80"5) "v3"6) "90"7) "v4"8) "100"#删除有序集stu中的v1127.0.0.1:6379&gt; zrem stu v1 (integer) 1127.0.0.1:6379&gt; zrange stu 0 -1 withscores1) "v2"2) "80"3) "v3"4) "90"5) "v4"6) "100" ZCARD stu当 key 存在且是有序集类型时，返回有序集的基数。 当 key不存在时，返回 0 。 ZCOUNT stu start end返回有序集 key中， score值在 min和max 之间(默认包括score 值等于min 或 max )的成员的数量。 12345678910111213127.0.0.1:6379&gt; zrange stu 0 -1 withscores1) "v2"2) "80"3) "v3"4) "90"5) "v4"6) "100"#统计有序集中成员的总个数127.0.0.1:6379&gt; ZCARD stu(integer) 3#统计大于80，小于等于100的成员127.0.0.1:6379&gt; ZCOUNT stu (80 100(integer) 2 ZRANK key member返回有序集key中成员member的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说，score 值最小的成员排名为 0 。 ZREVRANK key member返回有序集key中成员member 的排名。其中有序集成员按 score值递减(从大到小&lt;和默认的逆序&gt;))排序。排名以 0 为底，也就是说， score 值最大的成员排名为 0 。 12345678910111213141516171819202122127.0.0.1:6379&gt; zrange stu 0 -1 withscores 1) "v0" 2) "50" 3) "v1" 4) "60" 5) "v2" 6) "80" 7) "v3" 8) "90" 9) "v4"10) "100"#成员v3的排名127.0.0.1:6379&gt; zrank stu v3(integer) 3#成员v4的排名127.0.0.1:6379&gt; zrank stu v4(integer) 4#成员逆序排序127.0.0.1:6379&gt; zrevrank stu v3(integer) 1127.0.0.1:6379&gt; zrevrank stu v4(integer) 0 ZRANGEBYSOCRE key min max [withscores] [limit offset count]返回有序集 key中，所有score 值介于min和 max 之间(包括等于 min或 max )的成员。有序集成员按 score值递增(从小到大)次序排列。具有相同 score值的成员按字典序(lexicographical order)来排列： 可选的LIMIT参数指定返回结果的数量及区间(就像SQL中的 SELECT LIMIT offset, count )，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。 可选的WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。 ZREVRANGESCORE key min max [withsocres] [limit offset count]使用方法和ZRANGEBYSOCRE的用法一样，还是这个是前者的逆序 123456789101112131415161718192021#返回stu有序集中[90 100]的score和值127.0.0.1:6379&gt; zrangebyscore stu 90 100 withscores1) "v3"2) "90"3) "v4"4) "100"#返回stu有序集中（90 100]的score和值127.0.0.1:6379&gt; zrangebyscore stu (90 100 withscores1) "v4"2) "100"#返回stu有序集中[90 100]的score和值，只是是以逆序打印127.0.0.1:6379&gt; zrevrangebyscore stu 100 90 withscores1) "v4"2) "100"3) "v3"4) "90"#返回stu有序集中（90 100]的score和值，只是是以逆序打印127.0.0.1:6379&gt; zrevrangebyscore stu 100 (90 withscores1) "v4"2) "100"127.0.0.1:6379&gt;]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis快速入门]]></title>
    <url>%2F2019%2F09%2F22%2FRedis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是Redis？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redis是Remote Dictionary Severy(远程字典服务器)的缩写，它是一个基于C语言编写的完全开源免费，并且遵循BSD协议的一个高性能的key-value型分布式内存数据库。Redis使用key-value的形式保存值，常用的数据类型有String、list、hash、set、zset等数据结构，因此也被人们称为数据结构服务器。当然他也是NoSQL的一种典型产品。 Redis的特性 1、Redis支持数据的持久化，可以将内存中的数据保存到磁盘上，重启后可已再次加载数据 2、Redis不仅仅支持简单的key-value类型的数据，同时还支持list、set、zset、hash等存储数据结构 3、Redis支持数据的备份，即master-slave模式的数据备份。 4、Redis的性能极高-官方宣称Redis的读速度可以达到110000次/s，写的速度是81000次/s. 5、原子操作—Redis的所有操作都是原子的，即要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务。 在Linux（CentOS 7）上安装Redis首先去Redis的官方网站下载需要redisredis官网的镜像网址：http://download.redis.io/releases/，在这里有redis的各个版本： 在Liunx上使用wget命令下载（我这个下载它当前的最新的镜像redis-5.0.5-tar.gz版本）：wget http://download.redis.io/releases/redis-5.0.5.tar.gz 下载好后解压tar -zxvf redis-5.0.5.tar.gz 安装使用make命令编译解压完成后，cd 到解压后文件中，执行make命令，这一步可能会报错（在较低版本的Linux发行系统中可能会报错提示没有GCC环境，那就去安装一下GCC,然后执行make destclean命令清除失败的安装产生的文件，之后再次执行nake命令） make install PREFIX=/usr/local/redismake执行成功后文件夹找就会多一个src文件夹，进入src文件夹，执行 make install PREFIX=/usr/local/redis命令，把redis安装到/usr/local/redis/ 有关的配置把redis配置文件copy到安装目录下 配置redis为后台启动将刚在复制到安装目录的那个redis.conf打开，并把其中的daemonize no改成daemonize yes 设置redis开机自动启动打开/etc/rc.local 在里面添加：/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf(rc.local这个脚本会在开机的时候执行） 启动redis服务使用redis-server /usr/local/redis/redis.conf启动redis服务。注意：如果按照上面的正常的流程安装下来，但是在执行redis-server启动redis的时候提示redis-server不是命令，不要慌张，这是由于这个redis-server不是全局的命令不能在每一个目录下使用，当在别的目录下使用的时候系统在/usr/bin/找不到这个命令，因此我们需要把安装目录下的redis-server移动到到/usr/bin目录下就可以了。比如我的安装目录是/home/myredis/redis/redis-5.0.5/src/redis-server，那就可以执行下面的命令：ln -s /home/myredis/redis/redis-5.0.5/src/redis-server /usr/bin/redis-server 解决问题后再来执行上面那个命令启动redis服务,启动后我们可以使用ps -ef | grep redis来查看服务有没有启动： redis启动成功了，之后执行redis-cli -p 6379 进入redis的客户端 redis-benchmarkredis自带了一个性能测试工具redis-benchmark，他有丰富的模拟组件和指令可以使用。Redis-benchmark的官方中文链接： 。redis-benchmark 程序模拟 N 个客户端同时发出 M 个请求来测试在本机上redis可以达到的吞吐量从而间接的计算出你的机器性能高低。 表现为Response time和完成request的数量等等。 redis-benchmark可以使用到的参数： 12345-t 选择你想测试的命令，比如redis-benchmark -t set -p 指定port redis-benchmark -p 6379 -l 一直循环 -c 指定客户端数量 -n 指定request数量 redis常识性知识点redis的默认端口是6379redis的常用五大数据类型Redis的五大常用数据类型是：String（字符串）、List（列表）、Hash（散列表）、Set（集合）、ZSet（sorted Set，有序集合）。这五大数据类型在我的另一篇笔记Redis五大常用数据类型中有详细的介绍。 redis是单进程的来处理客户端的请求。对读写等事件的响应式通过对epoll函数的包装来实现到的。Redis的实际处理速度完全依靠主进程的执行效率。epoll是Linux内核为处理大批量文件描述符伟做了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，他能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。 默认有16个数据库。默认的数据库从DB0开始（一进入redis客户端默认使用的也是0号库），切换可以使用select &lt;dbid&gt;,这些在redis.conf这个文件中有详细的说明： SELECT 命令切换数据库使用select &lt;dbid&gt;，比如select 1就可以切换到1号库： DBSIZE 命令查看数据库key的数量 KEYS 命令查看数据库中的key123456789101112131415127.0.0.1:6379&gt; DBSIZE(integer) 7 #7个key127.0.0.1:6379&gt; keys * #查看本库中的所有key1) "mylist"2) "k3"3) "myset:__rand_int__"4) "key:__rand_int__"5) "k2"6) "counter:__rand_int__"7) "k1"127.0.0.1:6379&gt; keys k? #查看以`k`打头的key1) "k3"2) "k2"3) "k1"127.0.0.1:6379&gt; 但我们不想要数据库中的key的时候可以使用FLUSHDB清空当前数据库的所有key，FLUSHALL清空所有数据库中所有key]]></content>
      <categories>
        <category>NoSQL</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker进阶之Dockerfile和容器数据卷（Volume）]]></title>
    <url>%2F2019%2F09%2F20%2Fdocker%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%8D%B7%2F</url>
    <content type="text"><![CDATA[什么是数据卷？什么是容器数据卷？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷就是一个文件或者文件夹。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Docker的理念之一是将应用与其运行的环境打包，docker容器的生命周期是与其运行的程序一致的，而对数据的要求是持久化，docker容器之间也需要有共享数据的渠道。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷是特殊的目录，可以绕过联合文件系统，为一个或多个容器提供访问。数据卷设计的目的是数据的持久化，是完全独立于容器的生命周期，不会在容器删除时删除其挂载的数据卷，也不会存在类似垃圾收集机制，对容器引用的数据卷进行处理。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据卷存在于宿主机中，独立于容器，和容器的生命周期是分离的，数据卷存在于宿主机的文件系统中，数据卷可以是目录也可以是文件，容器可以利用数据卷与宿主机进行数据共享，实现了容器间的数据共享和交换。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通俗地来说，docker容器数据卷可以看成使我们生活中常用的u盘，它存在于一个或多个的容器中，由docker挂载到容器，但不属于联合文件系统，Docker不会在容器删除时删除其挂载的数据卷。 Docker添加数据的两种方式使用命令的方式添加数据卷在使用docker run的时候我们可以通过 -v 来创建一个数据卷并挂载到容器上，在一次run中多次使用可以挂载多个容器。命令语法：docker run -it -v /宿主机绝对路径:/容器绝对路径 镜像名 打开命令行终端，使用docker命令以交互式的方式来运行centos 1234567[root@localhost /]# docker run --name centos -it -v /home/huangxin/hostdata/:/dataVolmeContainer --privileged=true 67fa590cfc1c /bin/bash [root@aa29e3790769 /]# lsanaconda-post.log bin dataVolmeContainer dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@aa29e3790769 /]# cd dataVolmeCOntainer[root@localhost /]# docker run -it -v /home/huangxin/hostdata:/dataVolmeContainer centos [root@0504f3b67b95 /]# ls #进入到容器内部，容器内部的目录创建好了anaconda-post.log bin dataVolmeContainer dev etc home lib lib64 如果发现挂载在容器中的目录没有访问权限，可以加上--privileged=true这个参数。启动成功后我们可以用前面我们学过一个命令docker inspect 容器名/容器ID来查看关于一个容器的有关细节，打开我们发现主机和容器之间的共享已经建立起来了，而且默认都是可读可写的： 接下来测试一下容器和主机之间互相共享数据：打开另一个终端中，来到/home/huangxin/hostdata目录下，新建text1.txt,然后在里面写点东西： 12345[huangxin@localhost ~]$ cd /home/huangxin/hostdata[root@localhost hostdata]# touch text1.txt[root@localhost hostdata]# lstext1.txt[root@localhost hostdata]# vim text1.txt 随便写点东西： 然后来到容器里，就可以看到主机在主机端的共享文件夹中写的数据在容器中可以看到了： 接着我们反向操作看看在容器中写的数据能不能在主机可以共享到。 1234[root@aa29e3790769 dataVolmeContainer]# touch Demo1.txt[root@aa29e3790769 dataVolmeContainer]# vi Demo1.txt[root@aa29e3790769 dataVolmeContainer]# lsDemo1.txt text1.txt 还是随便写了点东西在新建的Demo1.text中，然后在主机端去看看有没有。 1234[root@localhost hostdata]# lsDemo1.txt text1.txt[root@localhost hostdata]# cat Demo1.txtHere is container!!!Hello Host. 可以看到主机和容器之间可以相互共享文件了；而且对这些文件都具有读写的权限。而且即使容器停止后，这些共享的数据还是同步的。然而有时我们不需要让容器写数据，那么我们就可以用带权限的命令：docker run -it -v /宿主机绝对路径:/容器绝对路径:ro 镜像名 ，ro表示read only。 使用DockerFile添加数据卷（这里先大概了解一下，下面会有Dockerfile详细的介绍）编写自定义的Dockerfile，可以使用VOLUME []命令可以挂载任意多个共享目录，以json的格式，多个目录逗号隔开。 1234FROM centosVOLUME ["/data1","/data2"]CMD echo "finished-----SUCCESS"CMD /bin/bash 使用docker build命令通过Dockerfile构建一个镜像docker build的基本语法：docker build [OPTIONS] PATH | URL | - -f,--file 指定Dockerfile的路径名 -t,--tag 指定镜像的REPOSITORY 和标签 常用的写法：docker build -f /Dcokerfile文件的路径 -t 仓库:标签 123456789101112131415161718192021[root@localhost docker]# docker build -f /home/huangxin/docker/Dockerfile -t xust-hx/centos .Sending build context to Docker daemon 2.048 kBStep 1/4 : FROM centos ---&gt; 67fa590cfc1cStep 2/4 : VOLUME /data1 /data2 ---&gt; Running in 296561fadbc5 ---&gt; da4cfb9f98d5Removing intermediate container 296561fadbc5Step 3/4 : CMD echo "finished-----SUCCESS" ---&gt; Running in 668697ef3ba4 ---&gt; ec2bf3c54a54Removing intermediate container 668697ef3ba4Step 4/4 : CMD /bin/bash ---&gt; Running in 5b3d43b5114a ---&gt; e61c27683817Removing intermediate container 5b3d43b5114aSuccessfully built e61c27683817[root@localhost docker]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZExust-hx/centos latest e61c27683817 13 seconds ago 202 MBxust/tomcat 1.0.0 71a1320815f5 19 hours ago 506 MB 可以看到我们的镜像构建成功了，下来我们来启动基于我们构建镜像的一个容器。 1[root@localhost docker]# docker run -it e61c27683817 /bin/bash 使用ls查看，发现容器中自动就挂载了两个文件夹data1,data2 但是这两个文件夹对应在主机上的什么地方呢？使用docker inspect来看看这个运行中的容器的详细信息 可以看到，docker对于使用VOLUME挂载的共享目录，在主机中会有一个默认的文件夹——&quot;/var/lib/docker/volumes/。在这个文件夹下你有挂载几个，docker就默认给你生成几个对应的共享目录。 1234[root@localhost huangxin]# cd /var/lib/docker/volumes/402caff5bb629320e524e8239b4ca121be7d11ce4df4b55b657bdcfdc549b543/_data[root@localhost _data]# pwd/var/lib/docker/volumes/402caff5bb629320e524e8239b4ca121be7d11ce4df4b55b657bdcfdc549b543/_data[root@localhost _data]# vim Demo1.txt 还是一样随便写点东西，然后去容器中的data1目录看看有没有Demo1.txt以及内容。 12345[root@6f062b92cccb /]# cd data1[root@6f062b92cccb data1]# lsDemo1.txt[root@6f062b92cccb data1]# cat Demo1.txtHello,this is host of data1! 容器之间共享数据让容器之间共享数据首先启动一个父容器(启动我们刚才制作的那个镜像) 12345[root@localhost docker]# docker run -it --name centos01 e61c27683817 [root@a5c471c5b738 /]# lsanaconda-post.log bin data1 data2 dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var//在data1目录下新建centos01.txt[root@a5c471c5b738 /]# vi centos01.txt 在centos01.txt中随便写点东西，然后在启动同样容器时候使用命令参数：--volumes-from来和父容器共享数据: 1234567891011121314[root@localhost docker]# docker run -it --name centos02 --volumes-from centos01 e61c27683817 [root@fec297cd7c00 /]# ls anaconda-post.log bin data1 data2 dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var[root@fec297cd7c00 /]# cd data1[root@fec297cd7c00 data1]# vim centos02.txt//在centos02.txt中随便写点东西//再启动另一个容器挂载到centos01上[root@fec297cd7c00 data1]# [root@localhost docker]# docker run -it --name centos03 --volumes-from centos01 e61c27683817 [root@1a8862870583 /]# cd data1[root@1a8862870583 data1]# lscentos01.txt centos02.txt[root@1a8862870583 data1]# vi centos03.txt//同样在centos03.txt中随便写点东西 最终达到的效果：父子容器都可以互相共享各自的数据： 那么如果我们删除了父容器，父容器以前共享的数据还在吗？子容器之间的共享还会有吗？来，一张图回答这个问题： Volume的作用/特点最后通过这几个示例可以终结出docker提供的数据卷的特点如下： 通过数据卷可以在容器之间实现数据的共享和重用 对数据卷的修改会立马生效(非常适合作为开发环境) 对数据卷的更新,不会影响镜像 数据卷会一直存在,直到没有容器使用才会被清除 Dockerfile基础Dockerfile是什么？Dockerfile是一个包含用于创建镜像的命令的文本文档。Docker通过读取Dockerfile中的指令自动生成镜像。Docker build命令用于从Dockerfile构建镜像。可以在docker build命令中使用-f参数指向文件系统中任何位置的Dockerfile。 Dockerfile的解析过程？1.Dockerfile中第一条指令必须是FROM 指令，它的作用是指定将要生成的镜像的基础镜像，类似于java中的继承。因此Dockerfile执行的第一步就是加载基础镜像；2.加载完基础镜像后，后面的指令按照定义的顺序从上到下依次执行，每执行一条指令都会对容器做一些修改；3.执行类似docker commit的操作提交一个新的镜像层；4.docker再基于刚提交的镜像运行一个新容器；5.执行Dockerfile中的下一条指令直到所有指令都执行完成； Dockerfile、Docker镜像、Docker容器三者的关系 从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段： Dockerfile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态。 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。 Dockerfile保留字指令FROM &nbsp;&nbsp;指定基础镜像,要建立的新镜像是基于那个镜像的,必须是Dockerfile中的第一个命令 12345格式： FROM &lt;image&gt;[:&lt;tag&gt;] FROM &lt;image&gt;[@&lt;digest&gt;]示例： FROM tomcat:8.5.3 MAINTAINER &nbsp;&nbsp;镜像维护者的信息 12345格式： MAINTAINTER &lt;info&gt;示例： MAINTAINTER zhangsan@163.com MAINTAINTER 张三 RUN &nbsp;&nbsp;容器构建是需要运行的命令 12345格式： RUN &lt;command&gt; #shell执行 RUN ["executable", "param1", "param2"] #exec执行示例： RUN yum install -y vim EXPOSE &nbsp;&nbsp;容器运行后对外暴露的端口 1234格式： EXPOSE &lt;port&gt; [&lt;port&gt;...]示例： EXPOSE 8080 3306 WORKDIR &nbsp;&nbsp; 指定容器创建后，终端默认登录进来的工作目录,类似于cd命令 123456格式： WORKDIR /path示例： WORKDIR / #此时工作目录为容器的根目录 WORKDIR /tmp #此时工作目录为容器的/tmp目录 WORKDIR /aaa #此时工作目录为容器的/tmp/aaa ENV &nbsp;&nbsp;用来在构建镜像的过程中设置环境变量 123456格式： ENV &lt;key&gt; &lt;value&gt; #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量 ENV &lt;key&gt;=&lt;value&gt; ... #可以设置多个变量，每个变量为一个"&lt;key&gt;=&lt;value&gt;"的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过""来进行标示；另外，反斜线也可以用于续行示例： ENV JAVA_HOME /usr/local/jdk1.8.0_171 ENV CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar ADD &nbsp;&nbsp;该命令将复制指定本地目录(src)中的文件到容器中的指定目录(det)中，src可以是是一个绝对路径，也可以是一个URL或一个tar文件，tar文件会自动解压为目录。 123456格式： ADD &lt;src&gt; &lt;dest&gt; ADD ["&lt;src&gt;","&lt;dest&gt;"] #用于支持包含空格的路径示例： ADD jdk-8u171-linux-x64.tar.gz /usr/local #ADD ["jdk-8u171-linux-x64.tar.gz","/usr/local"] 和上面的作用一样 COPY &nbsp;&nbsp;功能类似ADD，但是是不会自动解压文件，也不能访问网络资源VOLUME &nbsp;&nbsp;容器数据卷，用于数据保存和持久化，不多说上面有详细的介绍 1234格式： VOLUME ["/path/to/dir"] #可以写多个挂载目录，中间用逗号隔开示例： VOLUME ["dataVolume1","dataVolume2"] CMD &nbsp;&nbsp;指定一个容器启动时要执行的命令 ，Dockerfile中可以有多个CMD指令，但是只有最后一个CMD命令会生效，并且Dockerfile中的CMD命令会被docker run命令之后的参数替换 12345678格式： CMD ["executable","param1","param2"] (执行可执行文件，优先) CMD ["param1","param2"] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数) CMD command param1 param2 (执行shell内部命令)示例： CMD ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"] CMD ["/bin/bash"] CMD cd /bin/bash ENTRYPOINT &nbsp;&nbsp;指定一个容器启动时要执行的命令，和CMD一样，都是在指定容器动程序以及参数，但是他和CMD的区别是他会追加docker run后面的命令而不是覆盖。 123456格式： ENTRYPOINT ["executable", "param1", "param2"] (可执行文件, 优先) ENTRYPOINT command param1 param2 (shell内部命令)示例： ENTRYPOINT ["/usr/local/apache-tomcat-9.0.8/bin/catalina.sh","run"] ENTRYPOINT /bin/bash ONBUILD &nbsp;&nbsp;用于设置镜像触发器 1234格式： ONBUILD [INSTRUCTION]示例： ONBUILD ADD . /app/src/ 小试牛刀：使用Dockerfile的保留字构建一个可以构建tomcat的镜像的Dockerfile 12345678910111213141516171819202122232425262728293031#加载基础镜像FROM centos#维护者的信息MAINTAINER Huangxin#赋值jdk和tomcat到目标路径ADD jdk-8u212-linux-x64.tar.gz /usr/local/ADD apache-tomcat-8.5.37.tar.gz /usr/local/#在容器中安装vimRUN yum -y install vim#设置工作路径，就是登陆目录ENV workspace /usr/localWORKDIR $workspace#设置tomcat的环境ENV JAVA_HOME /usr/local/java/jdk1.8.0_212ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarENV CATALINTA_HOME /usr/local/tomcat_home/apache-tomcat-8.5.37ENV CATALINTA_BASE /usr/local/tomcat_home/apache-tomcat-8.5.37ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin#端口号默认为8080EXPOSE 8080#构建成功后打印成功信息CMD echo "&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;Successful!&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"#最后启动tomcatENTRYPOINT ["/usr/local/apache-tomcat-8.5.37/bin/catalina.sh"] 编写好后使用dcoker命令：docker build -t xust/tomcat:8.5.37 .来构建镜像(docker build默认使用当前目录下的Dockerfile来构建镜像，命令中最后那个点表示当前目录)： 中间经过很多个步骤，一层一层的叠加，最后构建成功了： 使用docker images查看我们构建的镜像：]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker核心技术（基础篇）]]></title>
    <url>%2F2019%2F09%2F18%2FCentOS7%E9%85%8D%E7%BD%AEDocker%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; 什么是Docker?&nbsp;&nbsp;&nbsp;&nbsp;Docker是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。&nbsp;&nbsp;&nbsp;&nbsp;Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&nbsp;&nbsp;&nbsp;&nbsp;Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。&nbsp;&nbsp;&nbsp;&nbsp;简单的说，Docker就是一个开源的应用容器引擎；是一个轻量级的容器技术。使用Docker我们可以把软件打包成一个镜像，在镜像中做好软件的相关配置，然后把镜像发布出去，其他使用者就可以直接使用我们的这个镜像而不需要其他的配置就可是我们的应用跑起来。 &nbsp;&nbsp; Docker三大组成Docker的三大基本组成（要素）：镜像（images）,容器（container）和仓库（repository）。 镜像（Images）Docker镜像就是一个只读的模板。镜像可以用来创建Docker容器，一个镜像可以重复创建多个容器。用java中的有关概念来解释就是：镜像类似于java中的类，而容器就是这个类的具体的实例。 容器（Container）Docker利用容器独立运行一个或一组应用。容器是用镜像创建的运行实例。它可以被启动、开始、停止、甚至删除，每个容器都是相互隔离的。我们可以把容器看作是一个简易版的Linux环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序。 仓库（Repository）仓库是集中存放镜像文件的场所。仓库和仓库组成服务器是有区别的。仓库组成服务器上往往存放着多个仓库，每个仓库中有包含了多个镜像，每个镜像又有不同的标签（tag）.仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是Docker Hub,这里面存放了数量庞大的的镜像。 镜像/容器/仓库三者的关系总结起来就是：Docker本身是一个容器运行载体（管理引擎）。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器。images文件可以看做是容器的模板。Docker根据image文件生成容器的实例。至于仓库，就是存放了一堆镜像的地方，我们可以把镜像发布到仓库存储起来，需要的时候从仓库拉取下拉就可以使用了。 &nbsp;&nbsp; CentOS 7安装配置Docker1、在安装前一定要先检查一下你对CentOS的版本：Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。查看的命令如下： 12345[root@localhost huangxin]# uname -r3.10.0-862.el7.x86_64[root@localhost huangxin]# cat /etc/redhat-releaseCentOS Linux release 7.5.1804 (Core) 2、使用yum命令安装docker 1[root@localhost huangxin]# yum install docker 期间会有一个确认提示，直接输入y确认。3、启动Docker,并设置以后开机自动启动 12[root@localhost huangxin]# systemctl start docker #启动[root@localhost huangxin]# systemctl enable docker #设置开始自动启动 4、这时我们可以查看一下docker的有关配置 12[root@localhost huangxin]# docker -v #查看docker的版本[root@localhost huangxin]# docker info #查看docker的详细信息 5、配置阿里云的镜像源这个配置不是必须的，只是配置一下以后使用的时候下载的速度会快很多，而且有时候如果直接使用国外的镜像会导致下载失败的情况也可以这么来配置。具体的方法是：&nbsp;&nbsp;&nbsp;&nbsp;1）、到阿里云的官网直接搜索容器镜像服务&nbsp;&nbsp;&nbsp;&nbsp;2）、点开后一顿注册设置后点击最下面的镜像加速器，然后复制加速器地址&nbsp;&nbsp;&nbsp;&nbsp;3）、复制后来到虚拟机使用命令vim /etc/docker/daemon.json添加刚才阿里云上的加速地址，格式如下： 123&#123; "registry-mirrors": ["https://xxxxxx.mirror.aliyuncs.com"]&#125; 注意：这里格式一定要正确，标准的json格式,不然服务不能启动 配置后保存并退出vim界面，输入以下命令重新加载配置并重启Docker 12[root@localhost huangxin]# systemctl daemon-reload[root@localhost huangxin]# systemctl restart docker 6、停止docker如果我们想停止docker，可以使用命令systemctl stop docker 1[root@localhost huangxin]# systemctl stop docker &nbsp;&nbsp; Docker常用命令和操作Docker常用的帮助命令docker version &nbsp;&nbsp;&nbsp;&nbsp;查看Docker的版本信息12345678910111213141516171819[root@localhost huangxin]# docker versionClient: Version: 1.13.1 API version: 1.26 Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64Server: Version: 1.13.1 API version: 1.26 (minimum version 1.12) Package version: docker-1.13.1-102.git7f2769b.el7.centos.x86_64 Go version: go1.10.3 Git commit: 7f2769b/1.13.1 Built: Mon Aug 5 15:09:42 2019 OS/Arch: linux/amd64 Experimental: false docker info &nbsp;&nbsp;&nbsp;&nbsp;显示系统范围的信息123456789101112131415161718192021222324252627282930[root@localhost huangxin]# docker infoContainers: 5 Running: 5 Paused: 0 Stopped: 0Images: 8Server Version: 1.13.1Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: trueLogging Driver: journaldCgroup Driver: systemdPlugins: Volume: local Network: bridge host macvlan null overlaySwarm: inactiveRuntimes: docker-runc runcDefault Runtime: docker-runcInit Binary: /usr/libexec/docker/docker-init-currentcontainerd version: (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)runc version: 9c3c5f853ebf0ffac0d087e94daef462133b69c7 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)Security Options: seccomp WARNING: You're not using the default seccomp profile Profile: /etc/docker/seccomp.json selinuxKernel Version: 3.10.0-862.el7.x86_64....... docker -&nbsp;-help &nbsp;&nbsp;&nbsp;&nbsp;docker的命令帮助123456789101112131415161718192021222324252627282930313233343536373839404142[root@localhost huangxin]# docker --helpUsage: docker COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/root/.docker") -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to (default []) -l, --log-level string Set the logging level ("debug", "info", "warn", "error", "fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/root/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/root/.docker/cert.pem") --tlskey string Path to TLS key file (default "/root/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumesCommands: attach Attach to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes on a container's filesystem events Get real time events from the server exec Run a command in a running ........ ...... 包括我们还可以在具体的命令后面使用--help参数,来获得关于这个命令的详细帮助例如我们可使用docker info -&nbsp;-help来查看关于docker info的命令帮助： 123456789[root@localhost huangxin]# docker info --helpUsage: docker info [OPTIONS]Display system-wide informationOptions: -f, --format string Format the output using the given Go template --help Print usage 可以看到docker info 还可以带-f/-format 和–help参数 镜像操作检索关键字（镜像）使用docker search命令后docker会去Docker Hub去查找镜像，并罗列出在Docker Hub上所有有关的镜像。 12345678910111213141516171819202122232425262728[root@localhost huangxin]# docker search mysqlINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/mysql MySQL is a widely used, open-source relati... 8596 [OK] docker.io docker.io/mariadb MariaDB is a community-developed fork of M... 2985 [OK] docker.io docker.io/mysql/mysql-server Optimized MySQL Server Docker images. Crea... 632 [OK]docker.io docker.io/centos/mysql-57-centos7 MySQL 5.7 SQL database server 62 docker.io docker.io/centurylink/mysql Image containing mysql. Optimized to be li... 61 [OK]docker.io docker.io/mysql/mysql-cluster Experimental MySQL Cluster Docker images. ... 51 docker.io docker.io/deitch/mysql-backup REPLACED! Please use http://hub.docker.com... 41 [OK]docker.io docker.io/tutum/mysql Base docker image to run a MySQL database ... 34 docker.io docker.io/bitnami/mysql Bitnami MySQL Docker Image 33 [OK]docker.io docker.io/schickling/mysql-backup-s3 Backup MySQL to S3 (supports periodic back... 28 [OK]docker.io docker.io/prom/mysqld-exporter 22 [OK]docker.io docker.io/linuxserver/mysql A Mysql container, brought to you by Linux... 21 docker.io docker.io/centos/mysql-56-centos7 MySQL 5.6 SQL database server 16 docker.io docker.io/circleci/mysql MySQL is a widely used, open-source relati... 14 docker.io docker.io/mysql/mysql-router MySQL Router provides transparent routing ... 12 docker.io docker.io/arey/mysql-client Run a MySQL client from a docker container 11 [OK]docker.io docker.io/imega/mysql-client Size: 36 MB, alpine:3.5, Mysql client: 10.... 7 [OK]docker.io docker.io/openshift/mysql-55-centos7 DEPRECATED: A Centos7 based MySQL v5.5 ima... 6 docker.io docker.io/yloeffler/mysql-backup This image runs mysqldump to backup data u... 6 [OK]docker.io docker.io/fradelg/mysql-cron-backup MySQL/MariaDB database backup using cron t... 4 [OK]docker.io docker.io/genschsa/mysql-employees MySQL Employee Sample Database 2 [OK]docker.io docker.io/ansibleplaybookbundle/mysql-apb An APB which deploys RHSCL MySQL 1 [OK]docker.io docker.io/jelastic/mysql An image of the MySQL database server main... 1 docker.io docker.io/monasca/mysql-init A minimal decoupled init container for mysql 0 docker.io docker.io/widdpim/mysql-client Dockerized MySQL Client (5.7) including Cu... 0 [OK][root@localhost huangxin]# docker search命令可以使用-s参数筛选出STARS数不小于指定数的镜像 123456[root@localhost huangxin]# docker search -s 100 mysqlFlag --stars has been deprecated, use --filter=stars=3 insteadINDEX NAME DESCRIPTION STARS OFFICIAL AUTOMATEDdocker.io docker.io/mysql MySQL is a widely used, open-source relati... 8596 [OK] docker.io docker.io/mariadb MariaDB is a community-developed fork of M... 2985 [OK] docker.io docker.io/mysql/mysql-server Optimized MySQL Server Docker images. Crea... 632 [OK] 可以看到，下面那些小于100START的镜像就不会显示出来 拉取镜像命令的基本语法是：docker pull [参数] 镜像名[:标签|@DIGEST] 1[root@localhost huangxin]# docker pull redis 这个命令中的tag缺省，在缺省情况下默认下载最新版本的镜像。 查看本地所有的镜像基本的语法：docker images [参数] [REPOSITORY[:TAG]] 1234[root@localhost huangxin]# docker imagesREPOSITORY（仓库） TAG(标签名) IMAGE ID（镜像ID） CREATED（创建日期） SIZE（镜像的大小）docker.io/tomcat latest 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 4 weeks ago 98.2 MB docker images命令后面还可以跟一些参数: -a 查看本地的所有的镜像（包含中间层镜像） -q 只显示镜像ID --digest 显示镜像的摘要信息 12345678910111213[root@localhost huangxin]# docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/tomcat latest 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 4 weeks ago 98.2 MB[root@localhost huangxin]# docker images -qeb0a013292232fb79bc1163c[root@localhost huangxin]# docker images --digestsREPOSITORY TAG DIGEST IMAGE ID CREATED SIZEdocker.io/tomcat latest sha256:80db17f3efd9cdcd9af7c799097fe0d223bbee8f25aa36234ab56292e3d8bd7b 96c4e536d0eb 3 weeks ago 506 MBdocker.io/redis latest sha256:9755880356c4ced4ff7745bafe620f0b63dd17747caedba72504ef7bac882089 f7302e4ab3a8 4 weeks ago 98.2 MB 删除指定的本地镜像基本的命令语法：docker rmi [参数] 镜像名1/镜像ID1 [镜像名2/镜像ID2...] 1[root@localhost huangxin]# docker rmi tomcat 一次删除多个镜像：docker rmi -f 多个镜像名/镜像ID ,其中-f表示强制删除，多个镜像之间空格隔开。 123456789101112[root@localhost huangxin]# docker rmi -f a00bc560660a 2fb79bc1163cUntagged: docker.io/rabbitmq:latestUntagged: docker.io/rabbitmq@sha256:dc853667e768ad1f35625f0337eede5de81ddcca452cf85436c9be2da8657723Deleted: sha256:a00bc560660a5519eee2356f87b76091f39c27ae2d3e595169b4ef97bec4c9fbUntagged: docker.io/rabbitmq:managementUntagged: docker.io/rabbitmq@sha256:f20a3a019241e53aaf98d4133f7781b6d9811d256ff1d755b5aab00855007d5bDeleted: sha256:2fb79bc1163c8003dc25438c32d472ac3034900b86bd5a17b421abdd32fb4496Deleted: sha256:9222d87e80ed54151a186ba2a1e2702008c1e0fce425b7e671e6de0751b005bcDeleted: sha256:2093e80d5f422868e454b8551a268d5892702b74e1e82326f015f6e68c0e2400Deleted: sha256:462c555fe32ac61371c4d1dba2ea30d51e3e803b7c4b0e9d84bf0afa4d938969Deleted: sha256:e0f0f24c7303048f18ce79f408f83ba1ecb49f0c94dc38c0c47e6aa7a38b6b2cDeleted: sha256:742c3e7ab1e9c7242d735106cd62e9efba28105c82b50b06b5a4a8f3a60a5b4f 删除本地的所有镜像：docker rmi -f ${docker images -q} 容器操作新建并启动容器命令的基本语法：docker run [操作参数] 镜像名/镜像ID [指令] [参数...]docker run 命令常用的参数有： --name 容器的新名字 给容器起一个名字，没有指定时会默认生成一个随机的字符串 -d 后台运行运行容器，并返回容器的ID -i 以交互式的方式运行容器 -t 为容器重新分配一个伪输入终端，通常会与-i配合使用 -P 随机端口映射 -p 指定端口映射，有以下四种格式：&nbsp;&nbsp;&nbsp;1.ip:hostPort:containerPort&nbsp;&nbsp;&nbsp;2.ip::containerPort&nbsp;&nbsp;&nbsp;3.hostPort:containerPort (常用的格式)&nbsp;&nbsp;&nbsp;4.containerPort 例如：在后台启动tomcat,并把虚拟机的25050端口映射到容器的8080端口 12[root@localhost huangxin]# docker run --name Tomcat -d -p 25050:8080 tomcat:latest239057353cedab1dfc26b921b237580f72009d7710008772d5a2a3befd539324 查看容器命令的基本语法：docker ps [操作参数]docker ps 常用的命令参数有： -a docker ps命令默认显示当前运行中的容器，加上-a参数会显示会有所有的容器（包括停止的、退出的） -l 显示最近一次启动的容器 -n 值 显示最近指定值次数启动的容器，比如 docker ps -n 2 ,表示显示最近两次启动的容器 -q 仅仅显示所有运行中的容器容器ID -s 显示所有运行中的容器的文件大小 示例： 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost huangxin]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ESeea2f65ecd70 90cce17c1af8 "docker-entrypoint..." 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ESeea2f65ecd70 90cce17c1af8 "docker-entrypoint..." 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql[root@localhost huangxin]# docker ps -lCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01[root@localhost huangxin]# docker ps -n 2CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES[root@localhost huangxin]# docker ps -qff15f2f20b325e68d3980e15eea2f65ecd7016fe5da80056e3a6146e9ee4[root@localhost huangxin]# docker ps -sCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES SIZEff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01 37.2 kB (virtual 225 MB)5e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 5 days 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 32.8 kB (virtual 486 MB)eea2f65ecd70 90cce17c1af8 "docker-entrypoint..." 6 days ago Up 6 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq 123 B (virtual 179 MB)16fe5da80056 redis:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:6379-&gt;6379/tcp redis-server 0 B (virtual 98.2 MB)e3a6146e9ee4 mysql:latest "docker-entrypoint..." 8 days ago Up 8 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 62 B (virtual 445 MB) 停止/退出运行中的容器 退出容器：exit（停止容器并退出）或使用快捷键Ctrl+P+Q（容器不停止并退出，相当于让容器后台运行） 停止容器：docker stop [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...] 强制停止容器: docker kill [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]例如：停止ES可以这么写：123456[root@localhost huangxin]# docker stop ESES[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Exited (143) 15 seconds ago ES 启动容器基本的命令语法：docker start [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]这里的启动这个docker run的功能不太一样，docker start是指启动一个已经停止的容器，而docker run是指创建出一个容器（这个容器还不存在）并启动它。示例：启动刚才停止的ES 123456[root@localhost huangxin]# docker start ESES[root@localhost huangxin]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 3 days 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 17 seconds 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 重启容器基本的命令语法：docker restart [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]示例：重启zookeeper 123456[root@localhost huangxin]# docker restart zookeeper01zookeeper01[root@localhost huangxin]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 9 seconds 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper015e68d3980e15 5acf0e8da90b "/docker-entrypoin..." 5 days ago Up 6 minutes 0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp ES 删除容器基本语法是：docker rm [操作参数] 容器名1/容器ID1 [容器名2/容器ID2...]注意：docker rm 删除的容器必须是不在运行状态的容器，如果想直接删除一个运行中的容器可以使用-f参数执行强制删除。 1234[root@localhost huangxin]# docker rm ESError response from daemon: You cannot remove a running container 5e68d3980e15f41d97662241c3bd022b3fcb9c4912761f50212c2ce2d6213e9f. Stop the container before attempting removal or use -f[root@localhost huangxin]# docker rm -f ESES docker rm支持一次删除多个容器，例如批量删除本地所有的容器： 1[root@localhost huangxin]# docker rm $&#123;docker ps -aq&#125; 解释一下这个组合命令:docker ps -aq可以返回本地所有的容器ID，然后把它传给docker rm执行批量删除。 查看容器的日志基本语法是：docker logs [操作参数] 容器名/容器IDdocker logs命令常用的参数：-t 加入时间戳-f 跟随最新的日志打印--tail 值 显示最后多少条日志 1[root@localhost huangxin]# docker logs 239057353ced 打印的日志： 查看容器内运行的进程命令：docker top 容器名/容器ID [ps OPTIONS] 1234[root@localhost huangxin]# docker top mysqlUID PID PPID C STIME TTY TIME CMDpolkitd 6565 6548 0 Sep17 ? 00:16:43 mysqldroot 6895 6879 0 Sep17 pts/1 00:00:00 bash 获取容器/镜像的元数据命令：docker inspect [操作参数] 容器名1|容器ID1 [容器名2|容器ID2...]使用这个命令可以查看容器内部的各种信息，docker会以json串的形式返回结果,例如查看mysql这个容器的内部细节： 123456789101112[root@localhost huangxin]# docker inspect mysql[ &#123; "Id": "e3a6146e9ee47230bb6f6df49f23db31cbd570c40e8125654443de42e02c4b79", "Created": "2019-09-10T10:48:43.201901131Z", "Path": "docker-entrypoint.sh", "Args": [ "mysqld" ], "State": &#123; "Status": "running",..... 进入容器并且在容器中以命令行的方式交互 命令1：docker exec [操作参数] 容器名/容器ID COMMAND [ARG...] 命令2：docker attach [操作参数] 容器名/容器ID 这两个命令的区别是：docker exec是在容器中打开新的终端并且启动新的线程，docker attach 是直接进入容器并启动终端，不会启动新的线程。示例：使用docker exec命令进入到mysql容器的命令行界面： 1234567891011121314151617181920212223242526[root@localhost huangxin]# docker exec -it mysql mysql -uroot -pEnter password: #输入数据库密码Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 14Server version: 8.0.17 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.13 sec)mysql&gt; 容器与主机之间的数据拷贝命令：把容器的数据拷贝到主机上：docker cp [操作参数] 容器名/容器ID:源路径 目的路径|-把主机上的数据拷贝到容器：docker cp [操作参数] 源路径|- 容器名/容器ID:目的路径示例：把mysql的一个库中的数据拷贝到主机的/Desktop 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost huangxin]# docker exec -it mysql /bin/bash #相当于windows上打开mysql的安装目录root@e3a6146e9ee4:/# mysql -uroot -p 密码 #进入数据库Enter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 15Server version: 8.0.17 MySQL Community Server - GPLCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; create database xust; #创建一个数据库xustQuery OK, 1 row affected (0.12 sec)#之后借助数据库工具创建了一张Students表mysql&gt; select * from students;+-------------+----------+----------+---------+| s_id | s_name | major_in | s_class |+-------------+----------+----------+---------+| 20190808001 | zhangsan | aas | casss 1 || 20190808002 | lisi | dad | casss 1 || 20190808003 | wangwu | ad | casss 3 || 20190808004 | lixiaoer | ad | casss 4 || 20190808005 | tom | ad | casss 5 |+-------------+----------+----------+---------+5 rows in set (0.00 sec)#使用Ctrl+P+Q快捷键退出数据库root@e3a6146e9ee4:/# mysqldump -u root -p 'xust'&gt;xust.sql #导出数据库数据Enter password: #之后使用ls命令就可以看到导出的脚本文件,使用pwd xust.sql查看一下他的路径,我的xust.sql文件的路径是/# 退出容器后将容器内文件拷贝到宿主机[root@localhost huangxin]# docker cp mysql:/xust.sql /Desktop/ #将容器中的xust.sql脚本文件复制到主机的/Desktop/目录下 导出的数据表： 由容器实例生成镜像（container-&gt;image）命令语法：docker commit [操作参数] 容器名/容器ID [仓库名[:标签名]]docker commit命令常用的参数： -a 指定作者名 -m 提交描述 示例：在tomcat容器中部署自己的网页,然后把它打包成一个镜像1.首先把一个项目www拷贝到CentOS的/home/huangxin/Desktop/目录下,然后进入运行中的tomcat的容器内部 1234[root@localhost Desktop]# docker exec -it 6f1bb2d2118d /bin/bashroot@6f1bb2d2118d:/usr/local/tomcat# ls #使用ls会看到我熟悉的目录，比如webappsBUILDING.txt LICENSE README.md RUNNING.txt conf lib native-jni-lib webappsCONTRIBUTING.md NOTICE RELEASE-NOTES bin include logs temp work 2.进入webapps，使用pwd得到webapps的路径记下来 12root@6f1bb2d2118d:/usr/local/tomcat# pwd/usr/local/tomcat/webapps 3.退出容器使用docker的复制命令把/home/huangxin/Desktop/www复制到容器中 1[root@localhost Desktop]# docker cp www 6f1bb2d2118d:/usr/local/tomcat/webapps 可以在虚拟机的localhost:25050/www来访问我们定制的网页： 接下来我们把这个定制的Tomcat容器打包成一个镜像4.把我们定制的这个tomcat打包成一个镜像 1234567891011[root@localhost Desktop]# docker commit -m="A tomcat with my site" -a="Huangxin" 6f1bb2d2118d xust/tomcat:1.0.0sha256:71a1320815f58ac6f71d8fbf8823dfff091f1561ce9cec7e9cac2bc32f2fe619[root@localhost Desktop]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZExust/tomcat 1.0.0 71a1320815f5 11 seconds ago 506 MB #这个是我们的tomcatdocker.io/zookeeper latest eb0a01329223 5 days ago 225 MBdocker.io/rabbitmq 3.8-rc-management 90cce17c1af8 9 days ago 179 MBdocker.io/tomcat latest 96c4e536d0eb 4 weeks ago 506 MBdocker.io/redis latest f7302e4ab3a8 5 weeks ago 98.2 MBdocker.io/mysql latest 62a9f311b99c 5 weeks ago 445 MBdocker.io/elasticsearch latest 5acf0e8da90b 12 months ago 486 MB 5.在虚拟机80端口启动我们定制的tomcat，然后访问localhost:/www 1234567891011[root@localhost Desktop]# docker run --name mytomcat -d -p 80:8080 71a1320815f5292830f2988b094ebd720aa438311f26e9a756bd6bdfca50abd01d7b81a2c228[root@localhost Desktop]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS #我们定制的tomcat启动了并映射在虚拟机的80端口 NAMES292830f2988b 71a1320815f5 "catalina.sh run" 12 seconds ago Up 11 seconds 0.0.0.0:80-&gt;8080/tcp mytomcat6f1bb2d2118d tomcat:latest "catalina.sh run" 2 hours ago Up 2 hours 0.0.0.0:25050-&gt;8080/tcp cranky_aryabhataff15f2f20b32 eb0a01329223 "/docker-entrypoin..." 3 days ago Up 6 hours 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 8080/tcp zookeeper01eea2f65ecd70 90cce17c1af8 "docker-entrypoint..." 7 days ago Up 7 days 4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp rabbitmq16fe5da80056 redis:latest "docker-entrypoint..." 9 days ago Up 9 days 0.0.0.0:6379-&gt;6379/tcp redis-servere3a6146e9ee4 mysql:latest "docker-entrypoint..." 9 days ago Up 9 days 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql 后记&nbsp;&nbsp;&nbsp;&nbsp;至此，docker的基本常用命令就介绍到这里了，使用后我个人的直观的感受是这个东西确实非常方便。然而这里仅仅是介绍了一些常用的命令，Docker中还有许多的命令这里没有介绍到，具体的可以参考Docker技术文档，而且我们也可以参考docker.hub上每个镜像官方给出的配置方法，方法很多这里就不一&nbsp;一介绍了。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot + Eureka 实现微服务负载均衡]]></title>
    <url>%2F2019%2F09%2F17%2FSpring%20Boot%20%2B%20Eureka%20%E5%AE%9E%E7%8E%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; 什么是Eureka？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka这个单词原本的意思就是“我发现了，我找到了”，然而他在Spring中的功能也和他的本意是一样的。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka是netflix的一个子模块，也是核心模块之一，Eureka是一个基于REST的服务，用于定位服务，以实现云端中间层服务发现和故障转移。服务注册与发现对于微服务架构来说是非常重要的，有了服务发现和注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务，而不需要修改服务调用的配置文件了，功能类似于dubbo的注册中心，比如zookeeper。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SpringCloud封装了Netflix公司开发的Eureka模块来实现服务注册时和发现。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka采用了C-S的设计架构。Eureka Server作为服务注册功能的服务器，它是服务注册时中心。而系统中的其他微服务，使用eureka的客户端连接到eureka server并维持心跳连接。这样系统的维护人员就可以通过eureka server来监控系统中各个微服务是否正常运行。SpringCloud的一些其他模块就可以通过eureka server来发现系统中的其他微服务，并执行相关的逻辑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka包含两个组件：Eureka Server和Eureka Client。Eureka Server提供服务注册服务。各个节点启动后，会在Eureka Server中进行注册，这样Eureka server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Eureka client是一个java客户端，用于简化eureka server的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表把这个服务节点移除。Eureka的三大角色： Eureka server提供服务注册和发现 Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到。 Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务。 总结起来就是说： Eureka是Netflix开源的一个RESTful服务，主要用于服务的注册发现。 Eureka由两个组件组成：Eureka服务器和Eureka客户端。Eureka服务器用作服务注册服务器。 Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。 Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的加权负载均衡。 &nbsp;&nbsp; 搭建一个基于Spring Boot + Eureka的微服务工程工程的搭建我使用IDEA，首先新建一个空工程【Empty project】,选择空工程点击【next】，之后我们需要在这个工程中建立三个子模块，分别是euraka-server注册中心，poervider服务提供者，customer消费者。新建一个空工程 在新建项目的时候我们可以使用【Spring Initializr】，在新建eurake-server模块的时候选上Eureka Server，新建provider和customer模块的时候可以选上Web的satrter和Eurake Discovery Client的satrter 建好后的项目结构： &nbsp;&nbsp; Eureka Server—注册中心的配置12345678910server: port: 8761eureka: instance: hostname: eureka-service #配置Eureka的主机名 client: register-with-eureka: false #不把自己注册到Eureka fetch-registry: false #不从Eureka获取注册信息 service-url: defaultZone: http://localhost:8761/eureka/ 在Eureka Server的启动类上使用@EnableEurekaServer开启Eureka服务 1234567891011121314151617181920package com.xust.iot.eureka.service;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;/** * 注册中心：服务提供把服务注册到注册中心，消费者可以在注册中心发现他需要的服务 * 1.在application.yml文件中配置Eureka有关的配置 * 2.使用@EnableEurekaServer 注解开启Eureka服务 */@EnableEurekaServer //开启Eureka服务@SpringBootApplicationpublic class EurekaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServiceApplication.class, args); &#125;&#125; 配置好后启动enureka-server，它将会在配置的端口8761启动，输入http://localhost:8761就可一个看到enureka-server的管理界面： &nbsp;&nbsp; Service Provider—服务提供方的配置在服务提供方的配置文件中配置如下信息： 1234567891011121314debug: trueserver: port: 8080 #服务的端口eureka: instance: prefer-ip-address: true #注册时使用ip进行注册 client: service-url: defaultZone: http://localhost:8761/eureka/ #服务将会按照这个路径注册到eureka server中spring: application: name: provider #服务的名字 实现一个服务，TicketService 12345678910@Servicepublic class TicketService &#123; private Logger log= LoggerFactory.getLogger(TicketService.class); public String order(int num)&#123; log.info("8080卖出"+num+"张票"); return "现在 ——G8888次——&gt; 未来"; &#125;&#125; Eureka的底层还是基于HTTP协议的，在消费者端要调用服务提供方的服务时，实际是通过HTTP请求的方式来调用的，因此需要在服务提供方给对应的service提供对应的controller。TicketController如下： 123456789101112@Controllerpublic class TicketController &#123; @Autowired TicketService ticketService; @ResponseBody @RequestMapping(value = "/ticket",method = RequestMethod.GET) public String getTicket(@RequestParam(value = "num",defaultValue = "1") int num)&#123; return ticketService.order(num); &#125;&#125; 最后在服务提供方的启动类上使用@EnableEurekaClient来告诉Spring这是Eureka的Cilent端，这个服务要注册到注册中心上去。（也可以使用@EnableDiscoveryClient注解，这两个注解的作用是相同的，但是还是有差别的，具体的可以参考@EnableDiscoveryClient与@EnableEurekaClient 区别）。 1234567891011/** * 服务提供者 */@EnableEurekaClient@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class, args); &#125;&#125; 配置完成后启动Server Provider（注意在启动Client端的服务时Eureka Server要保持运行），启动后可以正常访问http://localhost:8080/ticket,并且在注册中心可以看到8080端口的PROVIDER实例已经注册了就算是成功了。 我们可以开启多个服务提供方，方法是把当前的provider使用Maven命令(mvn install)打包成可执行jar包，然后在把server.port改成另一个端口再使用Maven命令打包后运行…下面是我启动了两个provider，分别在8080和8081端口 &nbsp;&nbsp; Service Customer—服务消费方的配置在服务消费方的配置文件中配置如下内容： 12345678910111213debug: truespring: application: name: customereureka: instance: prefer-ip-address: true #使用ip地址注册实例 client: service-url: defaultZone: http://localhost:8761/eureka/server: port: 8020 在服务消费方的启动类上使用@EnableDiscoveryClient注解告诉SpringBoot把这个服务注册到注册中心。并且注册RestTemplate到IoC容器中，可以使用他来远程调用服务提供方的服务。 12345678910111213141516171819/** * 消费者发现服务,并消费这些服务 */@EnableDiscoveryClient //开启发现服务的功能@SpringBootApplicationpublic class CustomerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(CustomerApplication.class, args); &#125; @LoadBalanced //开启负载均衡 @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 编写一个controller使用 RestTemplate来调用服务提供方的注册在服务中心的服务。 123456789101112131415161718@Controllerpublic class UserController &#123; @Autowired RestTemplate restTemplate; @ResponseBody @RequestMapping(value = "/buy",method = RequestMethod.GET) public String sellTicket(@RequestParam(value="num",defaultValue = "1") int num, @RequestParam(value = "name",defaultValue = "") String name)&#123; //使用RestTemplate提供的方法来获得目标服务，第一个参数是目标服务的url：http://服务提供者名/请求的服务 //这里使用getForObject通过http获得目标服务，与之相同的还有getForEntity(),这两个都是用get请求获得目标服务 //使用postForObject、postForEntity、postForLocation可以使用post请求的方式获的目标服务 String s = restTemplate.getForObject("http://PROVIDER/ticket?num=" + num, String.class); return name+"买了"+num+"张票"+"\n"+s; &#125;&#125; 最后启动服务消费方看看效果吧！ 首先我们可以访问http://localhost:8761/，可以在注册中心看到消费方也在注册中心注册了： 我们接着访问http://localhost:8020/buy?name=李四&amp;num=6就可以看到下面的页面： 微服务负载均衡的体现把另一个打包的可执行jar包在命令行使用java -jar 命令运行，注意不要让端口冲突。让两个服务提供方同时运行，然后我们访问http://localhost:8020/buy?name=李四&amp;num=6，不断改变num的值查看控制台的打印 发现这两个端口交替工作的，从而达到了一个负载均衡的作用。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Security—认证和授权]]></title>
    <url>%2F2019%2F09%2F16%2FSpringSecurity%2F</url>
    <content type="text"><![CDATA[认证（Authentication）：建立声明主体的过程。一般也就是指用户登录，表示让系统知道你的存在。授权（Authorization）：确定一个主体是否允许在你的应用程序里执行一个运动的过程，也就是赋予你用户能干什么。 &nbsp;&nbsp; 引入必要的pom文件这一步可以使用Spring Boot的初始化向导在新建工程的时候选上需要的starter，然后初始化向导就会自定引入选择的starter。或者你也可以在你已经建好的项目上直接粘贴复制下面的pom依赖到你的项目的pom文件中。 12345678910111213141516&lt;!--spring security--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf模板引擎--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--thymeleaf对spring-security的支持包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt; &lt;version&gt;3.0.4.RELEASE&lt;/version&gt;&lt;/dependency&gt; &nbsp;&nbsp; 配置使用Spring Security首先我们先搭建实验环境。 导入HTML页面具体的页面由于比较多而且又很简单的那种，所以这里就不贴出来了，这里仅仅是用于演示效果。 编写一个controller用于控制页面之间的跳转KufuController.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.xust.iot.security.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class KufuController &#123; private static final String PREFIX="pages"; @RequestMapping(value = "/") public String index() &#123; return "welcome"; &#125; @RequestMapping(value = "/userlogin") public String login()&#123; return PREFIX+"/login"; &#125; @RequestMapping(value = "/level1/&#123;page&#125;") public String toLevel11(@PathVariable("page")int page) &#123; return PREFIX+"/Level1/"+page; &#125; @RequestMapping(value = "/level2/&#123;page&#125;") public String toLevel24(@PathVariable("page")int page) &#123; return PREFIX+"/Level2/"+page; &#125; @RequestMapping(value = "/level3/&#123;page&#125;") public String toLevel37(@PathVariable("page")int page) &#123; return PREFIX+"/Level3/"+page; &#125;&#125; 这是我的项目结构： 启动SpringBoot看看效果：启动后在浏览器地址栏中输入https://localhost:8080来到welcome页面 配置Spring Security&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot中对Security有很多自动配置，我们要使用它只要编写一个配置类，并且让这个配置类继承自WebSecurityConfigurerAdapter，然后在配置类上使用EnableWebSecurity注解告诉Spring开启WebSecurity功能。以后我们需要定制有关认证和授权的功能的时候只需要重写WebSecurityConfigurerAdapter中的方法，下面是一个例子： 一个简单的Spring Security配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.xust.iot.security.config;import org.springframework.context.annotation.Bean;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.crypto.password.Pbkdf2PasswordEncoder;/** * 1、引入spring security的starter * 2、编写配置类继承WebSecurityConfigurerAdapter * 3、在配置类上标注@EnableWebSecurity开启WebSecurity */@EnableWebSecurity //开启Web Securitypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Override public void configure(WebSecurity web) &#123; //防止静态资源被拦截 web.ignoring().antMatchers("/config/**", "/css/**", "/fonts/**", "/img/**", "/js/**"); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; //设置Http安全规则 http.authorizeRequests().antMatchers("/").permitAll() //配置认证规则 .antMatchers("/level1/**").hasRole("VIP1") .antMatchers("/level2/**").hasRole("VIP2") .antMatchers("/level3/**").hasRole("VIP3"); //开启自动配置的登录功能 http.formLogin() .usernameParameter("username") //指定提交的表单中的用户名参数 .passwordParameter("password") //指定提交的表单中的密码参数 .loginPage("/userlogin") //指定自定义的登录页面 .loginProcessingUrl("/login") //指定处理登录请求的url .permitAll(); //开启自动配置的注销功能：注销后来到登录页面 http.logout() .deleteCookies() .logoutSuccessUrl("/userlogin") //注销成功后跳转的页面 .permitAll() .invalidateHttpSession(true); //记住我功能 http.rememberMe().rememberMeParameter("remember").tokenValiditySeconds(60 * 60 * 24 * 7); //关闭Spring提供的CSRF攻击保护，一般不建议这么做 /*http.csrf().disable();*/ &#125; //定义认证规则 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.inMemoryAuthentication() /*Spring Security 5.0开始必须要设置加密方式*/ .withUser("张三").password(passwordEncoder().encode("123456")).roles("VIP1", "VIP2", "VIP3") .and() .withUser("李四").password(passwordEncoder().encode("123456")).roles("VIP1"); &#125; //配置passwordEncoder @Bean public Pbkdf2PasswordEncoder passwordEncoder() &#123; return new Pbkdf2PasswordEncoder(); &#125;&#125; 注意：1、formLogin系统会自动配置/login请求去Spring内部默认的登录页面，如果想改成自己的实现，可以参考上面的配置2、如果登录失败系统默认会重定向到/login/error页面3、如果没有配置允许登录页面任何人可以访问，那么SpringBoot默认的登录页面的username是username，密码会在SpringBoot启动启动的时候自动生成，打印在控制台中。然而还有一种办法即使我们可以配置初始的用户密码，下面是一个配置示例： 123#spring boo默认会对所有的资源进行拦截，所以可以在这里配置个初始的用户名个密码spring.security.user.name=adminspring.security.user.password=123456 然而我们完全不必要这么做，我们可以对公共的资源放开权限就好了，具体的配置方法参照上面的配置。4、SpringBoot2.x抛弃了原来的NoOpPasswordEncoder，要求用户保存的密码必须要使用加密算法后存储，在登录验证的时候Security会将获得的密码在进行编码后再和数据库中加密后的密码进行对比，如果强行使用明码会报错： 在Web页面(HTML中)获得用户的身份、授权信息主要就是利用sec提供的方法。 sec:authorize=”isAuthenticated()”：是否授权成功 sec:authentication=”principal.authorities”：获取用户身份 sec:authentication=”name”：获取用户名字 sec:authorize=”hasRole()”：判断当前身份 要使用这些功能，需要先引入sec的名称空间 1234&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" &lt;!--引入sec名称空间，注意版本冲突的问题--&gt; xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"&gt; 不同授权的用户会有不同的操作权限，包括可以通过sec提供的这几个方法，动态的获取用户是否授权成功，用户有哪些身份…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org" xmlns:sec="http://www.thymeleaf.org/thymeleaf-extras-springsecurity5"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Welcome&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;欢迎光临武林秘籍管理系统&lt;/h1&gt; &lt;div sec:authorize="!isAuthenticated()"&gt; &lt;h2&gt;游客你好，如果想看武林秘籍&lt;a href="" th:href="@&#123;/userlogin&#125;" style="text-decoration: none"&gt;请登录&lt;/a&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div sec:authorize="isAuthenticated()"&gt; &lt;h2&gt;&lt;span sec:authentication="name"&gt;&lt;/span&gt;,你好，你的角色有 &lt;span sec:authentication="principal.authorities"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;/div&gt;&lt;/center&gt;&lt;form action="/logout" th:action="@&#123;/logout&#125;" method="post"&gt; &lt;!--解决SpringBoot由于CSFR保护而对空post请求的拦截问题--&gt; &lt;!--&lt;input type="hidden" name="$&#123;_csrf.parameterName&#125;" value="$&#123;_csrf.token&#125;"/&gt;--&gt; &lt;button type="submit"&gt;注销&lt;/button&gt;&lt;/form&gt;&lt;hr/&gt;&lt;div sec:authorize="hasRole('VIP1')"&gt;&lt;h3&gt;普通武林秘籍(限VIP1)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level1/1&#125;" style="text-decoration: none"&gt;罗汉拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level1/2&#125;" style="text-decoration: none"&gt;全真剑法&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level1/3&#125;" style="text-decoration: none"&gt;武当长拳&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP2')"&gt;&lt;h3&gt;高级武林秘籍(限VIP2)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level2/4&#125;" style="text-decoration: none"&gt;太极拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level2/5&#125;" style="text-decoration: none"&gt;七伤拳&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level2/6&#125;" style="text-decoration: none"&gt;梯云纵&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div sec:authorize="hasRole('VIP3')"&gt;&lt;h3&gt;绝世武林秘籍(限VIP3)&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level3/7&#125;" style="text-decoration: none"&gt;葵花宝典&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level3/8&#125;" style="text-decoration: none"&gt;龟派气功&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="" th:href="@&#123;/level3/9&#125;" style="text-decoration: none"&gt;孤独九剑&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 启动Spring Boot看看最终的效果：如果你没有登录，那么你将没有任何操作权限，登录后页面可以根据不同的用户的不同授权显示不同的操作权限可以操作的资源。 &nbsp;&nbsp; Demo的Github地址https://github.com/LoverITer/spring-security-test]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之异步任务、定时服务和邮件服务]]></title>
    <url>%2F2019%2F09%2F14%2FSpringBoot%E4%B9%8B%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[SpringBoot—异步任务&nbsp;&nbsp;&nbsp;&nbsp;异步调用是相对于同步调用而言的，同步调用是指程序按预定顺序一步步执行，每一步必须等到上一步执行完后才能执行，异步调用则无需等待上一步程序执行完即可执行。&nbsp;&nbsp;&nbsp;&nbsp;实现异步处理任务的方式有很多，我们可以自己通过多线程来实现或者也可以使用SpringBoot提供的@EableAysnc和@Aysnc这两个注解来实现。 通过多线程来实现异步处理任务直接在需要异步任务处理的方法中开启新的线程来处理任务。 12345678910111213141516171819202122@Servicepublic class AsyncService &#123; private Logger log= LoggerFactory.getLogger(AsyncService.class); /** * 手动开启一个线程来处理异步任务 */ public void async()&#123; log.info("开始处理任务"); //开启一个新新线程方式来异步处理任务 new Thread(() -&gt; &#123; try &#123; log.info("处理中，请稍等..."); Thread.sleep(3000); //处理过程中 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); log.info("任务提前返回，交给另一个线程处理"); &#125;&#125; 执行结果如下： 使用SpringBoot提供的注解处理异步任务首先在需要异步任务处理的方法上加上@Async注解告诉SpringBoot这个方法需要异步处理 123456789101112131415161718@Servicepublic class AsyncService &#123; private Logger log= LoggerFactory.getLogger(AsyncService.class); @Async //开启异步任务 public void async()&#123; log.info("开始处理"); try &#123; log.info("处理中，请稍等..."); Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; log.info("处理完成....."); &#125;&#125; 然后在主配置类使用@EnableAsync注解开启异步注解功能 1234567891011121314package com.xust.iot.task;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;@EnableAsync //开启异步注解功能@SpringBootApplicationpublic class SpringBootTaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootTaskApplication.class, args); &#125;&#125; 执行结果如下，SpringBoot也是开启了一个新的线程task-1来处理这个任务的： SpringBoot—定时任务定时任务就是提前设置好时间点，然后每到这个时间点就会执行的任务。SpringBoot中可以通过@Scheduled和@EableScheduled这两个注解来实现定时任务。同样在需要定时任务对方法上标注@Scheduled注解，然后在主配置类上标注@EableScheduled注解开启定时注解功能 123456789101112131415161718192021222324252627@Servicepublic class ScheduledService &#123; private Logger log= LoggerFactory.getLogger(ScheduledService.class); //0 * * * * MON-FRI //秒 分 时 日 月 星期 @Scheduled(cron="0 * * * * 1-7") //星期一~星期天 每分钟的整秒（00秒）执行该任务 public void service1()&#123; log.info("执行定时任务service1@"+ LocalDateTime.now()); &#125; @Scheduled(cron="1,11,21,31,41,51 * * * * 1-7") //星期一~星期天 每分钟的1秒，11秒，21秒，31秒，41秒，51秒的时候执行该任务 public void service2()&#123; log.info("执行定时任务service2@"+ LocalDateTime.now()); &#125; @Scheduled(cron = "0-5 * * * * 1-7") //星期一~星期天 每分钟的00秒~05秒执行该任务 public void service3()&#123; log.info("执行定时任务service3@"+ LocalDateTime.now()); &#125; @Scheduled(cron = "0/5 * * * * 1-7") //星期一~星期天 从00秒开始每隔5秒执行该任务 public void service4()&#123; log.info("执行定时任务service4@"+ LocalDateTime.now()); &#125;&#125; 执行结果： 从上面这个例子中可以看到，对于定时任务使用主要就是对cron表达式的编写，cron允许的值可以有以下几种： 字段允许值允许的特殊字符 秒0-59, - * / 分0-59, - * / 小时0-23, - * / 日1-31, - * / ? L W C 月1-12, - * / 星期0-7或SUN-STA, - * / ? L W C # 解释： , ：表示枚举，可以用它在一个一段上枚举多个值 — ：表示一个区间 * ：表示任意 / ：步长 ？：日/星期冲突匹配 L ： 最后 W： 工作日 C ： 和Calendar联系后计算后的值 # :星期，例如4#2 表示第二个星期四 下面是几个用法示例： 12345678910111213141516171819202122232425262728293031@Servicepublic class ScheduledService &#123; private Logger log= LoggerFactory.getLogger(ScheduledService.class); @Scheduled(cron="0 0/5 14,18 * * ?") //每天14点整合18点整，每隔5分钟执行一次该任务 public void service5()&#123; log.info("执行定时任务service5@"+ LocalDateTime.now()); &#125; @Scheduled(cron="0 30 12 ? * 1-6") //每月的周一~周六12:30执行一次该任务 public void service6()&#123; log.info("执行定时任务service6@"+ LocalDateTime.now()); &#125; @Scheduled(cron = "0 0 12 ? * 6L") //每月的最后一个周六中午12点执行一次 public void service7()&#123; log.info("执行定时任务service7@"+ LocalDateTime.now()); &#125; @Scheduled(cron = "0 0 12 LW * ?") //每月的最后一个工作日的12点执行一次 public void service8()&#123; log.info("执行定时任务service8@"+ LocalDateTime.now()); &#125; @Scheduled(cron = "0 0 6/1 ? * 4#2") //每月的第二个星期四在六点整开始每隔一小时执行一次 public void service9()&#123; log.info("执行定时任务service9@"+ LocalDateTime.now()); &#125;&#125; SpringBoot—邮件任务 &nbsp; &nbsp; &nbsp; &nbsp;Spring Email 抽象的核心是 MailSender 接口，MailSender 的实现能够把 Email 发送给邮件服务器，由邮件服务器实现邮件发送的功能。 &nbsp; &nbsp; &nbsp; &nbsp;Spring 自带了一个 MailSender 的实现JavaMailSenderImpl，它会使用 JavaMail API 来发送 Email。Spring 或 SpringBoot 应用在发送 Email 之前，我们必须要把JavaMailSenderImpl 装配为 Spring应用上下文的一个 bean。 首先引入邮件服务的starter1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 邮件配置1234567spring: mail: host: smtp.qq.com #smpt主机 password: ceozdvepgtlydihg #这里的password是生成的授权码，不是账户密码 username: huangxin9830@qq.com #发送邮件的账户名 properties: #properties的值应该是一个Map mail.smpt.ssl: true #设置使用SSL安全协议 简单邮件服务—SimpleMessage使用简单邮件服务只能发送文本消息 1234567891011121314@AutowiredJavaMailSenderImpl mailSender;@Testpublic void contextLoads() &#123; //简单邮件服务 SimpleMailMessage message = new SimpleMailMessage(); message.setSubject("你好，这是SpringBootMail"); message.setFrom("2489868503@qq.com"); message.setText("Hello JMail!"); message.setTo("2489868503hx@gmail.com"); mailSender.send(message);&#125; 执行的结果，收到了邮件： 复杂邮件服务—MimeMessage使用复杂邮件服务可以发送文本消息、HTML语句、甚至支持上传附件 12345678910111213141516171819@Test public void test02()&#123; //复杂邮件服务 MimeMessage mimeMessage = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject("你好，陌生人！"); helper.setFrom("2489868503@qq.com"); //HTML语句 helper.setText("&lt;font color='red'&gt;你中奖啦！！！&lt;/font&gt;"，true); helper.setTo("2489868503hx@gmail.com"); //上传附件 helper.addAttachment("1.jpg",new File("D:\\pic\\1.jpg")); helper.addAttachment("2.jpg",new File("D:\\pic\\2.jpg")); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; mailSender.send(mimeMessage); &#125; 执行结果：在GMail收到了邮件，并且设置HTML样式起作用了，附件也上传成功了。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之缓存二（使用Redis作为缓存）]]></title>
    <url>%2F2019%2F09%2F11%2FSpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B9%8B%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;在我的上一篇笔记SpringBoot之缓存一（基本的缓存注解）中学习了一下SpringBoot对缓存的处理机制，重点介绍了SpringBoot提供的基于JCache的几个缓存注解的使用，这篇笔记跟随上篇对Redis做一下整合。首先在原有的pom文件的基础上引入Redis的pom依赖： 12345&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; &nbsp;&nbsp;&nbsp;&nbsp;在我的上一篇笔记在我的上一篇笔记SpringBoot之缓存一（基本的缓存注解）中提到过，当我们没有导入其他第三方的缓存的时候，SpringBoot默认给我们实例化的缓存是SimpleCacheConfiguration的对象，如果我们导入了任何其他第三方的缓存，SpringBoot就会自动切换成第三方的缓存。所以在我们导入Redis的starter后要想正常使用缓存，就需要对他做配置在application.yml文件中添加如下基本的配置： 1234567891011121314#Redis配置spring: redis: host: 192.168.92.128 # redis主机 port: 6379 # redis端口 password: # redis密码，默认没有密码 database: 0 # Redis数据库索引，默认是0 jedis: pool: max-active: 8 # 连接池最大连接数，使用负值表示没有限制 max-wait: -1 # 连接池最大阻塞等待时间，默认是负值表示无限等待 max-idle: 5 # 连接池的最大空闲连接 min-idle: 0 # 连接池的最小空闲连接 timeout: 1200 # 连接超时时间(ms) 配置Redis缓存管理器&nbsp;&nbsp;&nbsp;&nbsp;通过配置Spring的CacheManager为redis，即可指定使用redis做缓存，具体的配置方式跟1.0也有所不同，在1.0中使用RedisTemplate即可实例化一个RedisCacheManager：RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);在2.0中删除了这个构造器，同时也不可以通过之前的setDefaultExpiration方法设置默认的缓存过期时间等，在新版本中可以通过以下的两种方式构造一个RedisCacheManager： 通过RedisCacheManager的静态方法create():123456@Beanpublic RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory)&#123; RedisCacheManager redisCacheManager =RedisCacheManager.create(redisConnectionFactory); return redisCacheManager; &#125; 通过Spring提供的RedisCacheConfiguration类构造一个自己的Redis配置类，从该配置类中可以设置一些初始化的缓存命名空间、及对应的默认过期时间等属性，再利用RedisCacheManager中的builder.build()的方式生成cacheManager： 123456789101112131415161718192021222324252627282930313233343536package com.xust.iot.learningspirngbootcache01.config;import com.xust.iot.learningspirngbootcache01.bean.User;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import java.net.UnknownHostException;import java.time.Duration;@Configurationpublic class RedisCache &#123; @Bean public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123; //生成默认配置 RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds(60L)); //不缓存空值 redisCacheConfiguration = redisCacheConfiguration.disableCachingNullValues(); //设置序列化 RedisSerializationContext.SerializationPair&lt;User&gt; serializationPair = RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer&lt;User&gt;(User.class)); //把User对象转成JSON格式 redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith(serializationPair); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory) // 使用自定义的缓存配置初始化一个cacheManager .cacheDefaults(redisCacheConfiguration) //这里一定要把我们的配置设置成默认的额缓存配置才会有效果 .build(); return cacheManager; &#125;&#125; 在设置的时候有一个坑要特别注意RedisCacheConfiguration是有返回值的，也就是说，每设置一次都要重新复制给RedisCacheConfiguration对应的那个对象，不然设置无效。 启动SpringBoot连续查询几次重复的查询1号User后发现第一次是查的数据库，以后都是去Redis中取得值，而且缓存在Redis中的数据也被格式化为JSON格式了：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot之缓存一（基本的缓存注解）]]></title>
    <url>%2F2019%2F09%2F09%2FSpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; JSR-107规范JSP-107是什么？ &nbsp;&nbsp;&nbsp;&nbsp;要回答这个问题，首先要知道JSR是什么，JSR是Java Specification Requests 的缩写 ，Java规范请求，故名思议就是Java规范，大家一同遵守这个规范的话，会让大家‘沟通’起来更加轻松。规范是很重要的 ，举个例子大家都知道红灯停，路灯行吧，如果每个城市的信号灯代表不一样，那就麻烦了，B城市红灯行，绿灯停，C城市甚至出现紫灯行，闪灯行，想想都知道，如果我们保证不出问题，必须知道每个城市的信号等代表的意义。我们一直使用的JDBC就一个访问数据库的一个规范的例子。 而 JSR-107呢就是关于如何使用缓存的规范。 JSR-107核心APIJava Caching定义了5个核心接口，分别是CachingProvider,CacheManager,Cache,Entry和Expiry。CachingProvider用于定义创建、配置、获取、管理和控制CacheManager。CacheManager用于定义了建立，配置，得到，管理和控制有着唯一名字的Cache ，一个CacheManager被包含在单一的CachingProvider。CacheCache是一个Map类型的数据结构，用来存储基于键的数据，很多方面都像java.util.Map数据类型。一个Cache 存在在单一的CacheManager。EntryEntry是一个存在于Cache的key-value键值对Expiry每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy来设置。这些接口之间的关系可以用下图表示： &nbsp;&nbsp; Spring缓存抽象Spring 从3.1版本开始在org.springframework.cache包下定义了Cache和CacheManager接口来统一不同的缓存技术，并使用JCache(JSR-107)注解简化我们的开发。 Cache接口为缓存的组件规范定义，包含缓存的各种操作集合 Cache接口下Spring提供了各种xxxCache的实现，如RedisCache、EncheCache、ConcurrentMapCache…… 每次调用需要缓存功能的方法是，Spring会检查指定的参数的是定目标方法时候已经被调用过，如果有就直接从缓存中获取方法调用后对结果，如果没有就调用方法去数据库查询并缓存结果后返回给用户，下次回直接从缓存中获取。 重要的缓存注解 注解功能 Cache缓存接口，定义缓存操作。 CacheManager缓存管理器。管理和中缓存组件 @Cacheable主要用于方法，能够根据方法的请求参数对其进行缓存 @CachePut方法被调用，并且在调用后结果被缓存，主要用于更新操作 @CacheEvict清除缓存 @EnableCaching开启基于注解的缓存 @Caching配置复杂对缓存策略 @CacheConfig同一配置本类的缓存注解额属性 serialize缓存数据的value序列haul策略 @Cacheable/@CachePut/@CacheEvict 主要的参数 参数解释 value/cacheNames缓存的名字。必须指定至少一个，可以配置多个例如：@Cacheable(value={"cache1","cache2"}) key缓存的key。可以为空，如果指定要使用SpEL。默认将方法的所有参数组合起来作为key。例如：@Cacheable(value="cache1",key="#id") keyGenerator定义自动生成主键的策略，使用的时候key和keyGenerator二选一 condition作缓存的条件。可以为空，使用SpEL表达式指定，返回true表示作缓存，否者不缓存。例如：@Cacheable(vlaue="cache",condition="#id&gt;0") unless也是作缓存的条件。当条件为true时，就不缓存（和condition的效果是反的）。例如：@Cacheable(value="cache",unless="#id&lt;0") sync(@Cacheable)是否使用异步支持，这是Spring 4.3以后才支持的,默认值false，不开启异步模式例如：@Cacheable(value="cache",sync=true) //开启异步模式 allEntries(@CacheEvict)是否清空所有缓存内容。默认为false,如果指定为true，则方法调用后将立即清空所有缓存。 beforeInvocation(@CacheEvict)是否在方法执行前清空缓存。默认为false，如果指定为true,则方法还没有执行的时候就清空缓存。默认情况下如果方法抛出异常，就没有办法清空缓存了。 SpEL上下文数据Spring 提供了一些供我们使用的SpEL表达式， 名称位置描述 用法示例 methodName(方法名) root对象 当前被调用的方法名 #root.methodname method(方法) root对象 当前被调用的方法 #root.method.name target(当前对象) root对象 当前被调用的目标对象实例 #root.target targetClass(目标类)root对象 当前被调用的目标对象的类 #root.targetClass args(参数列表) root对象 当前被调用的方法的参数列表 #root.args[0] caches(缓存列表)root对象 当前方法调用使用的缓存列表 #root.caches[0].name Argument Name(参数名)执行上下文 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 #artsian.id result(方法返回值) 执行上下文 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） #result &nbsp;&nbsp; Spring缓存的配置和使用先把基本的实现环境搭建起来 首先引入需要的pom依赖12345678910111213141516171819202122232425&lt;!--springboot 缓存--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--数据库连接--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--druid数据源--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 接下来依次配置数据库连接信息、配置Druid数据源，配置MyBatis，这些配置好后就可以使用SpringBoot默认配置的缓存(SimpleCacheConfiguration)了。如果要使用别的第三方缓存，直接在pom文件中导入相应的starter就可以了。SpringBoot默认配置的缓存是SimpleCacheConfiguration： 首先创建一个实体类User1234567public class User implements Serializable &#123; private Integer id; private String name; private Integer age; private String email; //getter 、setter....&#125; 创建Mapper接口(DAO层) UserMapper.java；123456789101112131415161718192021222324package com.xust.iot.learningspirngbootcache01.mapper;import com.xust.iot.learningspirngbootcache01.bean.User;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserMapper &#123; //增加一个User Integer addOneUser(User usr); //根据id删除一个User boolean deleteUserById(Integer id); //根据id查询一个User User selectUserById(Integer id); //查询所有User List&lt;User&gt; selectAllUser(); //根据id更新一个User boolean updateUserById(@Param("id") Integer id,@Param("user") User user);&#125; 对应的mapper映射文件,UserMapper.xml： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xust.iot.learningspirngbootcache01.mapper.UserMapper"&gt; &lt;insert id="addOneUser" useGeneratedKeys="true" keyProperty="id" &gt; insert into user(name,age,email) values (#&#123;name&#125;,#&#123;age&#125;,#&#123;email&#125;) &lt;/insert&gt; &lt;delete id="deleteUserById" parameterType="integer"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;select id="selectUserById" parameterType="integer" resultType="com.xust.iot.learningspirngbootcache01.bean.User"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id="selectAllUser" parameterType="integer" resultType="com.xust.iot.learningspirngbootcache01.bean.User"&gt; select * from user &lt;/select&gt; &lt;update id="updateUserById" &gt; update user &lt;set&gt; name=#&#123;user.name&#125;,email=#&#123;user.email&#125;,age=#&#123;user.age&#125; &lt;/set&gt; &lt;/update&gt;&lt;/mapper&gt; 接下来就是今天的主角——service层。首先编写一个Service层的基接口ServiceBase&lt;T&gt;,在这个接口抽取了service层中通用的CRUD方法，如下： 123456789101112public interface ServiceBase&lt;T&gt; &#123; Integer register(T t); boolean delete(Integer id); User get(Integer id); List&lt;User&gt; getAll(); boolean update(Integer id, T t);&#125; 然后定义IUserService接口，让他去继承ServiceBase接口，由于IUserService接口中这里没有定义新的方法，只是个空类（但它任然有存在的意义），这里就不贴出来了。之后定义IUserService接口的实现类UserServiceImpl.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.xust.iot.learningspirngbootcache01.service.impl;import com.xust.iot.learningspirngbootcache01.bean.User;import com.xust.iot.learningspirngbootcache01.mapper.UserMapper;import com.xust.iot.learningspirngbootcache01.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.*;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;/** * @Author: HuangXin * @Date: Created in 15:00 2019/9/9 2019 * @Description: */@Transactional //开启事务@Servicepublic class UserServiceImpl implements IUserService&lt;User&gt; &#123; @Autowired UserMapper userMapper; @Override public Integer register(User user) &#123; return userMapper.addOneUser(user); &#125; @Override public boolean delete(Integer id) &#123; return userMapper.deleteUserById(id); &#125; @Override public User get(Integer id) &#123; return userMapper.selectUserById(id); &#125; @Override public List&lt;User&gt; getAll() &#123; return userMapper.selectAllUser(); &#125; @Override public boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id, user); &#125;&#125; 在SpringBoot的启动类头上添加注解@EnableCaching 开启开启基于注解的缓存配置或者使用@MapperScan(value = &quot;com.xust.iot.learningspirngbootcache01.mapper&quot;) 扫描com.xust.iot.learningspirngbootcache01.mapper路径下的所有Mapper接口 之后写一个controller,UserController.java 1234567891011121314151617181920212223242526272829303132@Controllerpublic class UserController &#123; @Autowired IUserService&lt;User&gt; iUserService; @ResponseBody @RequestMapping(value = "/user/&#123;id&#125;") public User selectUser(@PathVariable("id") Integer id) &#123; return iUserService.get(id); &#125; @ResponseBody @RequestMapping(value = "/user/add") public User register(User user) &#123; int id = iUserService.register(user); return user; &#125; @ResponseBody @RequestMapping(value = "/user/all") public List&lt;User&gt; showAllUser()&#123; return iUserService.getAll(); &#125; @ResponseBody @RequestMapping(value = "/user/del/&#123;id&#125;") public ResponseEntity delete(@PathVariable("id") Integer id)&#123; iUserService.delete(id); return new ResponseEntity(HttpStatus.OK); &#125;&#125; 这样搭建好环境后是没有缓存的，使用缓存的方法有很多种，这里就使用SpringBoot提供的注解来使用缓存 @Cacheable@Cacheable注解会先查询是否已经有缓存，有的话会使用缓存，没有则会执行方法并缓存。 12345@Cacheable(value="user",key = "#root.methodName+'('+#id+')'")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; 在CacheAspectSupport这个类的findCachedItem方法上打上断点，观察发现我们配置的key是有效： 自定义主键生成策略1234567891011121314151617package com.xust.iot.learningspirngbootcache01.config;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import java.util.Arrays;@Configurationpublic class CacheConfig &#123; @Bean("userKey") //bean的名字就是主键生成策略的名字 public KeyGenerator keyGenerator()&#123; //主键策略：方法的hashcode+@+[参数] return (target, method, params) -&gt; method.getName().hashCode()+"@"+ Arrays.toString(params); &#125;&#125; 在方法中可以这么使用： 12345@Cacheable(value="user",keyGenerator = "userKey")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; 同样，通过打断点发现我们配置的主键生成也起作用了： 其他参数的用法可以参考下面的程序： 1234567891011121314151617181920212223242526 /** *自定义缓存策略，并且只有当返回值不是null的时候才缓存 */@Cacheable(value="user",keyGenerator = "userKey",condition = "#result!=null")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; /** *自定义缓存策略，并且当返回值是null的时候不缓存，也就相当于上面的写法，只不过unless是判断为false的时候才做缓存 */@Cacheable(value="user",keyGenerator = "userKey",unless = "#result==null")@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; /** *自定义缓存策略，并且开启异步缓存 */@Cacheable(value="user",keyGenerator = "userKey",sync = true)@Overridepublic User get(Integer id) &#123; return userMapper.selectUserById(id);&#125; @CachePut&nbsp;&nbsp;&nbsp;&nbsp;@CachePut注解的作用主要用于对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 。简单来说就是用户更新缓存数据。但需要注意的是该注解的value 和 key 必须与要更新的缓存相同，也就是与@Cacheable 相同。 123456//方法本调用后，总是会执行方法，返回后如果条件瞒住就来缓存@CachePut(value = "user",keyGenerator = "userKey",condition = "#result==true")@Overridepublic boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id,user);&#125; @CachePut的其他参数的用法和一样@Cacheable参数的用法一样。这里不再赘述。 @CacheEvict@CachEvict 的作用主要用于方法的配置，能够根据一定的条件对缓存进行清空 。 123456789101112131415161718192021222324252627@CacheEvict(value = "user",beforeInvocation = false) //默认就是false,会在方法执行后清缓存public boolean delete(Integer id) &#123; int i/0; //这里发生异常了，缓存无法清空 return userMapper.deleteUserById(id);&#125; @CacheEvict(value = "user",beforeInvocation = true) //在方法执行前清除缓存@Overridepublic boolean delete(Integer id) &#123; int i/0; //即使这里会发生异常，还是会清空缓存，因为清除缓存是在方法执行前执行的 return userMapper.deleteUserById(id);&#125; @CacheEvict(value = "user",allEntries = true) //方法调用后清空所有缓存@Overridepublic boolean delete(Integer id) &#123; return userMapper.deleteUserById(id);&#125;@CacheEvict(value = "user",allEntries = false) //默认不清空所有缓存@Overridepublic boolean delete(Integer id) &#123; return userMapper.deleteUserById(id);&#125; @Caching有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。 123456789101112131415 //组合缓存策略，Caching只有下面三个属性@Caching(cacheable = &#123; @Cacheable(value = "user", keyGenerator = "userKey") &#125;, put = &#123; @CachePut(value = "user", keyGenerator = "userKey") &#125;, evict = &#123; @CacheEvict(beforeInvocation = true, allEntries = true) &#125; ) @Override public boolean delete(Integer id) &#123; return userMapper.deleteUserById(id); &#125; @CachingConfig当我们需要缓存的地方越来越多，你可以使用@CacheConfig(cacheNames = {“cacheName”})注解来统一指定value/cacheNames的值，这时可省略value/cacheNames，如果你在你的方法依旧写上了value/cacheNames，那么依然以方法的@CacheConfig配置的值为准。使用方法如下： 12345678910111213141516171819@CacheConfig(cacheNames = "user") //在类名头上只用@CacheConfig来指定这个类全局的缓存的名字@Servicepublic class UserServiceImpl implements IUserService&lt;User&gt; &#123; @Autowired UserMapper userMapper; @Cacheable(keyGenerator = "userKey", sync = true) @Override public User get(Integer id) &#123; return userMapper.selectUserById(id); &#125; @CachePut(value = "user", keyGenerator = "userKey", condition = "#result==true") @Override public boolean update(Integer id, User user) &#123; return userMapper.updateUserById(id, user); &#125;&#125; @CacheConfig可以配置单的属性如下： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig &#123; String[] cacheNames() default &#123;&#125;; //缓存名字，它里面没有value String keyGenerator() default ""; //主键生成策略 String cacheManager() default ""; //指定缓存管理器 String cacheResolver() default ""; //缓存处理器&#125;]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot之自定义starter]]></title>
    <url>%2F2019%2F09%2F08%2FSpringBoot%E8%87%AA%E5%AE%9A%E4%B9%89starter%2F</url>
    <content type="text"><![CDATA[Spring Boot中提供了各种starter，starter可以理解为一个可拔插式的插件，当我们要使用的时候只用导入需要的starter即可。例如：你想使用jdbc插件，那么可以使用spring-boot-starter-jdbc；如果想使用mongodb，可以使用spring-boot-starter-data-mongodb。但是当我们需要的场景没有的时候我们可以来定制starter。 创建一个maven工程首先在IDEA中创建一个空工程，在其中创建两个Model，一个是hello-spring-boot-starter,另一个是hello-spring-boot-starter-configurer，目结构如下： 要特别注意artifactId的命名规则：Spring官方starter通常命名为spring-boot-starter-{name},如 spring-boot-starter-web Spring官方建议非官方Starter命名应遵循{name}-spring-boot-starter的格式, 如mybatis-spring-boot-starter。 一般我们不会直接在starter中写配置，starter一般只一个空项目，然后主要的配置写在这个starter对应的autoconfigurer中，让starer依赖configurer就可以了。 在starter中引入对应的configurer依赖starter一般是一个空模块，真正的实现放在configurer中，让starter依赖configurer，以后需要使用这个模块的时候只用引入starter就可以引入它所依赖的configurer。 12345678&lt;dependencies&gt; &lt;!--在自定义的start中引入对应的配置类--&gt; &lt;dependency&gt; &lt;groupId&gt;com.xust.iot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter-configurer&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在hello-spring-boot-starter-configurer模块中写我们需要的配置XxxProperties123456789101112131415package com.xust.iot.starter;import org.springframework.boot.context.properties.ConfigurationProperties;/** * 用户的配置信息类 */@ConfigurationProperties(prefix = "com.xust.user")public class UserProperties &#123; private String username; //用户名 private Integer age; //用户年龄 private String gender="M"; //用户性别 //getter、setter。。。 核心业务类123456789101112131415161718192021package com.xust.iot.starter;/** * 核心服务类 */public class UserService &#123; private UserProperties userProperties; public UserService()&#123; &#125; public UserService(UserProperties userProperties) &#123; this.userProperties = userProperties; &#125; public String sayHello()&#123; return "大家好，我叫"+userProperties.getUsername()+",今年"+userProperties.getAge()+"岁，"+"性别："+userProperties.getGender(); &#125;&#125; 自动配置类XxxAutoConfigurer12345678910111213141516171819202122package com.xust.iot.starter;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configuration //说明这是配置@ConditionalOnWebApplication //说明在Web环境下该类起作用@EnableConfigurationProperties(UserProperties.class) //自动配置UserProperties中的属性public class UserServiceAutoConfigurer &#123; @Autowired private UserProperties userProperties; @Bean public UserService userService() &#123; UserService userService = new UserService(userProperties); return userService; &#125;&#125; src/main/resources/META-INF/spring.factories然后需要在hello-spring-boot-starter-configurer的src/main/resources文件夹下新建META-INF文件夹然后新建spring.factories文件,配置这个类让他可以自动启动。 12org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.xust.iot.starter.UserServiceAutoConfigurer 打包mvn clean install使用Maven命令mvn clean install或直接使用IDEA提供的Maven插件执行install命令把我们的这个starter安装到本地Maven仓库。注意：如果提示没有找到pom文件的错误，那就使用命令行找到对应的项目执行Maven命令 测试一下之后我们再新建一个普通的Spring Boot项目，引入我们自定义的starter 123456&lt;!--在别的项目中引入我们自己的starter,只需要引入starter就可以了--&gt;&lt;dependency&gt; &lt;groupId&gt;com.xust.iot&lt;/groupId&gt; &lt;artifactId&gt;hello-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 引入后的效果： 写一个controller来测试一下我们的starter是否有效 123456789101112@Controllerpublic class UserController &#123; @Autowired UserService userService; @ResponseBody @RequestMapping(value = "/user") public String hello()&#123; return userService.sayHello(); &#125;&#125; 可以在主配置文件中配置UserProperties中的属性（不配置将会使用默认值） 123com.xust.user.username=李四com.xust.user.age=21com.xust.user.gender=M 启动运行看看效果：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot之MyBatis的配置和使用（注解和XML配置）]]></title>
    <url>%2F2019%2F09%2F07%2FSpirngBoot%E4%B9%8BMybatis%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关于MyBatis，大部分人都很熟悉。MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。这篇文章主要介绍了Spring Boot集成MyBatis的两种方式（注解和XML文件配置）,需要的朋友可以参考下 &nbsp;&nbsp; 使用XML配置MyBatis在pom.xml文件中引入MyBatis的依赖12345 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt; 编写MyBatis的主配置文件Mybatis-config.xml在src/main/resources目录下新建mybatis文件夹，然后新建Mybatis-config.xml文件并配置如下： 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--一些有关于mybatis运行时行为的设置--&gt; &lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--开启懒加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!--aggressvieLazyLoading当这个参数为true的时候，对任意延迟属性都会完全的加载，当为false时会按需加载--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;!--开启自动映射--&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;!--开启驼峰--&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 编写Mapper接口以及对应的Mapper映射文件在src/main/java下新建mapper包，然后新建ArticleMapper接口如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/***对article表的CRUD*/@Repository@Mapper //特别注意一定要加上@Mapper注解(或者也可以在启动类中使用@MapperScan)public interface ArticleMapper &#123; /** * 增加一片文章 * * @param article 文章对象 * @return */ Integer add(Article article) throws SQLException; /** * 删除一片文章 * * @param id 文章id * @return */ boolean delete(Integer id) throws SQLException; /** * 修改一片文章 * * @param id * @return * @throws SQLException */ boolean update(@Param("id") Integer id, @Param("article") Article article) throws SQLException; /** * 根据传入的参数查询文章 * * @param id * @return * @throws SQLException */ List&lt;Article&gt; getArticle(@Param("id") Integer id, @Param("title") String title) throws SQLException; /** * 查询所有的文章 * * @return * @throws SQLException */ List&lt;Article&gt; getAll() throws SQLException;&#125; 在src/main.resoures下新建mapper文件夹，然后在mapper文件夹中新建对应的Mapper映射文件ArticleMapper.xml如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xust.iot.springboot_db.mapper.ArticleMapper"&gt; &lt;insert id="add" parameterType="com.xust.iot.springboot_db.bean.Article" useGeneratedKeys="true" keyProperty="id"&gt; INSERT INTO article ( title, summary, content,level, ctimes, picture ) VALUES (#&#123;title&#125;,#&#123;summary&#125;,#&#123;content&#125;,#&#123;level&#125;,#&#123;ctimes&#125;,#&#123;picture&#125;) &lt;/insert&gt; &lt;delete id="delete" parameterType="integer"&gt; delete from article where id=#&#123;id&#125; &lt;/delete&gt; &lt;update id="update"&gt; update article &lt;if test="article!=null"&gt; &lt;set&gt; &lt;if test="article.title!=null"&gt;title=#&#123;article.title&#125;&lt;/if&gt; &lt;if test="article.summary!=null"&gt;summary=#&#123;article.summary&#125;&lt;/if&gt; &lt;if test="article.content!=null"&gt;content=#&#123;article.content&#125;&lt;/if&gt; &lt;if test="article.level!=null"&gt;level=#&#123;article.level&#125;&lt;/if&gt; &lt;if test="article.ctimes!=null"&gt;ctime=#&#123;article.times&#125;&lt;/if&gt; &lt;if test="article.picture!=null"&gt;picture=#&#123;article.picture&#125;&lt;/if&gt; &lt;/set&gt; &lt;/if&gt; &lt;where&gt; id=#&#123;id&#125; &lt;/where&gt; &lt;/update&gt; &lt;select id="getArticle" resultType="com.xust.iot.springboot_db.bean.Article"&gt; select * from article &lt;where&gt; &lt;choose&gt; &lt;when test="id!=null"&gt;id=#&#123;id&#125;&lt;/when&gt; &lt;/choose&gt; &lt;choose&gt; &lt;when test="title!=null"&gt;title=#&#123;title&#125;&lt;/when&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="getAll" resultType="com.xust.iot.springboot_db.bean.Article"&gt; select * from article &lt;/select&gt;&lt;/mapper&gt; 然后在application.yml文件中配置mybatis这两个文件的位置： 123456mybatis: config-location: classpath:/mybatis/mybatis-config.xml #MyBatis主配置文件的位置 mapper-locations: classpath:/mybatis/mapper/*.xml #mapper文件的位置 这种写法就注册了所有mapper包下的mapper映射文件logging: level: com.xust.iot.learningspirngbootcache01.mapper: debug #对mapper包开启debug,可以看到MyBatis执行SQL的日志打印 编写一个controller，简单测试一下看看我们配置的MyBatis能不能用。这里为了简单就没有写对应的service。 1234567891011121314@Controllerpublic class ArticleController &#123; @Autowired ArticleMapper articleMapper; @ResponseBody @RequestMapping("/article/&#123;id&#125;") public List&lt;Article&gt; getArticle(@PathVariable("id") Integer id) &#123; List&lt;Article&gt; articles=articleMapper.getArticle(id,null); //articles.forEach(article -&gt; System.out.println("article"+article)); return articles; &#125;&#125; 测试结果： &nbsp;&nbsp; 使用注解配置MyBatis在src/main/java/mapper下新建CourseMapper接口 12345678910111213141516171819@Repositorypublic interface CourseMapper &#123; @Options(useGeneratedKeys = true,keyProperty = "id") @Insert("insert into course(cid,cname) values(#&#123;cid&#125;,#(cname))") int add(Course course); @Delete("delete from course where id=#&#123;id&#125;") boolean delete(Integer id); @Update("update course set cid=#&#123;course.cid&#125;,cname=#&#123;course.cname&#125;") boolean update(@Param("id") Integer id, @Param("course") Course course); @Select("select * from course where id=#&#123;id&#125;") Course getOne(Integer id); @Select("select * from course") List&lt;Course&gt; getAll();&#125; 在启动类上使用@MapperScan扫描mapper包下的所有的Mapper接口，这样做的好处是可以省去在每个Mapper接口上写@Mapper注解。 12345678@MapperScan(value = "com.xust.iot.springboot_db.mapper")@SpringBootApplicationpublic class SpringbootDbApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDbApplication.class, args); &#125;&#125; 还可以写一个配置类彻底取代MyBatis的所有XML文件MyBatisConfig.java 12345678910111213141516@Configurationpublic class MybatisConfig &#123; /** * @return */ public ConfigurationCustomizer configurationCustomizern()&#123; return configuration -&gt; &#123; configuration.setMapUnderscoreToCamelCase(true); //开启驼峰命名 configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL); configuration.setCacheEnabled(true); //.....在mybatis主配置文件可以设置的在这里都可以设置 &#125;; &#125;&#125; 编写一个controller，看看实际的效果： 1234567891011121314@Controllerpublic class CourseController &#123; @Autowired CourseMapper courseMapper; @ResponseBody @RequestMapping(value = "/course") public List&lt;Course&gt; show()&#123; List&lt;Course&gt; courses = courseMapper.getAll(); courses.forEach(course -&gt; System.out.println("course；"+course)); return courses; &#125;&#125; 测试结果：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合Druid数据源]]></title>
    <url>%2F2019%2F09%2F07%2FSpringboot%E9%85%8D%E7%BD%AEdruid%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[java实现的数据库连接池有很多，c3p0,dbcp等，还有号称速度最快的HikariCP，并且springboot2.0.2版本默认使用的就是HikariCP。为什么选用Druid呢？ 性能够好，比c3p0,dbcp强一些 经过考验，毕竟是阿里开源出来的项目 最关键的是带一个强大的数据库监控 &nbsp;&nbsp; Druid能监控那些数据 1. 数据源 2. SQL监控 ，对执行的MySQL语句进行记录，并记录执行时间、事务次数等 3. SQL防火墙 ，对SQL进行预编译，并统计该条SQL的数据指标 4. Web应用， 对发布的服务进行监控，统计访问次数，并发数等全局信息 5. URI监控， 对访问的URI进行统计，记录次数，并发数，执行jdbc数等 6. Session监控， 对用户请求后保存在服务器端的session进行记录，识别出每个用户访问了多少次数据库等 7. Spring监控 ，（按需配置）利用aop对各个内容接口的执行时间、jdbc数进行记录 &nbsp;&nbsp; 如何配置使用Druid想达到的目标效果，监控sql，监控sql防火墙，监控url，监控session，监控spring 其中监控sql、监控url、基础信息，几乎不怎么需要配置，集成好druid，配置好监控页面，就可以显示。需要我们配置的大概分为3部分，基础连接池配置，基础监控配置，定制化监控配置 首先需要引入Druid的依赖123456&lt;!--这里最好引入spring提供的这个starter，在druid-spring-boot-starter这个pom文件中已经引入了源工程的pom文件--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt; 基础连接池配置主要配置用户名，密码，数据库驱动、数据库连接…..以及和连接池有关的配置 1234567891011121314151617181920212223242526272829303132spring: datasource: # 数据源基本配置 username: root password: 123456 url: jdbc:mysql://localhost:3306/xust?useSSL=false&amp;set global time_zone="+8:00" driver-class-name: com.mysql.cj.jdbc.Driver #使用type指定使用Druid type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 # 初始化连接池的连接数量 大小，最小，最大 initialSize: 5 minIdle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 是否缓存preparedStatement，也就是PSCache 官方建议MySQL下建议关闭 如果想用SQL防火墙 建议打开 poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true # 通过connectProperties属性来打开mergeSql功能 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 导入Druid数据源的其他属性上面的配置文件中和数据库连接池有关的配置属性在Spring Boot是没有的，因此我们需要告诉Spring Boot，让他在启动的时候去找加载这些属性，因此我们需要写一个配置类。没有写配置类之前的效果： 写一个配置类 12345678910@Configurationpublic class DruidConfig &#123; //配置Druid的其他属性 @Bean @ConfigurationProperties(prefix = "spring.datasource") //让Spring boot去加载这些属性，完成对连接池的初始化 public DataSource druid()&#123; return new DruidDataSource(); &#125;&#125; 写配置类后的效果，配置类起作用了： 配置Durid监控主要就是配置一个后台管理的Servlet—StarViewServlet和Web监控过滤器—WebStatFilter。具体有哪些初始化参数可以设置，可以参考这两个类以及他们的父类，都是以常量的方式出现的，配置的时候配置他们的值就可以了。 123456789101112131415161718192021222324252627282930313233@Configurationpublic class DruidConfig &#123; //配置Druid数据监控 //1.配置管理后台的Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean=new ServletRegistrationBean(new StatViewServlet(),"/druid/*"); //设置后台管理的路径是/druid/* Map&lt;String,String&gt; initParams= new HashMap&lt;&gt;(); initParams.put("loginUsername","admin"); initParams.put("loginPassword","123456"); initParams.put("allow",""); //默认就是允许所有访问 initParams.put("deny","192.168.15.21"); //设置不允许访问ip initParams.put("resetEnable","false"); //是否手动清除监控数据 //设置一些初始化的参数 bean.setInitParameters(initParams); return bean; &#125; //2.配置一个Web监控的Filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean=new FilterRegistrationBean(new WebStatFilter()); Map&lt;String,String&gt; initParams=new HashMap&lt;&gt;(); initParams.put("exclusions","*.js,*.css,/druid/*"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList("/*")); return bean; &#125;&#125; 写一个controller启动看看效果： 1234567891011121314@Controllerpublic class HelloController &#123; @Autowired JdbcTemplate jdbcTemplate; @ResponseBody @RequestMapping(value = "/query") public List&lt;Map&lt;String,Object&gt;&gt; hello()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList("select * from article"); return maps; &#125;&#125; 启动后在浏览器地址栏输入localhost:8080/query，执行一次请求启动后在浏览器地址栏输入localhost:8080/druid，可以看到Druid后台管理的登录界面 输入刚刚设置的用户名个密码，来到后台管理页面，点击SQL监控就可以看到刚才执行的SQL被记录了。 上面Druid监控的配置还可以直接在properties/yml文件中配置，下面是关于Druid监控的配置片段： 123456789101112131415debug: truespring: datasource: # Druid监控配置 druid: stat-view-servlet: enabled: true #开启后台管理 ，默认也是true url-pattern: /druid/* #后台管理页面的路径 login-password: 123456 login-username: admin reset-enable: false #禁止手动清除监控数据 web-stat-filter: enabled: true exclusions: .js,.css,.html,/druid/* url-pattern: /*]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot配置外部Servlet容器（Tomcat）]]></title>
    <url>%2F2019%2F09%2F04%2FSpringBoot%E9%85%8D%E7%BD%AE%E5%A4%96%E7%BD%AEServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[嵌入式Servlet容器：将应用打成可执行的jar包 ​优点：简单、便携； ​缺点：默认不支持JSP、优化定制比较复杂； 外置的Servlet容器：在外面安装Tomcat(或者使用外部已经安装好的Tomcat)，项目完成后把项目打包成war包，然后放到外部Tomcat容器中运行。 &nbsp;&nbsp; 配置步骤修改打包的方式修改的方法有两种：一种是在使用【Spring Initializr】新建项目的时候选择Packing为war；另一种是在Maven pom.xml文件中修改&lt;packaging&gt;jar&lt;/packaging&gt;使用【Spring Initializr】新建项目的时候选择Packing为war pom.xml文件中修改 1234&lt;artifactId&gt;springboot_servlet_contanier&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;!--修改为war的打包方式--&gt;&lt;packaging&gt;war&lt;/packaging&gt; 修改原有嵌入式的Tomcat的作用域为provided&lt;/&gt;123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;!--provided的意思是告诉Spring Boot 外部提供了，使用外部提供的这个。--&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 添加servlet-api依赖1234567891011121314151617181920212223242526&lt;!--添加原生tomcat依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--使用jsp还要添加下面对依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 编写一个SpringBootServletInitializer的子类，并调用configure方法【必须】12345678public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; //参数是当前项目的启动类的class return application.sources(SpringbootServletContanierApplication.class); &#125;&#125; 如果使用的是【Spring Initializr】创建的项目，正常操作后就会自动生成这个类。 最后在项目中新建webapp目录，启动服务器就可以使用了。 注意：如果发生使用JSP EL表达式无法解析的情况时，可以在jsp页面写上&lt;%@ page isELIgnored=&quot;false&quot; %&gt;这条语句就可以了。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot之嵌入式Servlet容器的配置、切换和启动原理]]></title>
    <url>%2F2019%2F09%2F04%2FSpringBoot%E5%B5%8C%E5%85%A5%E5%BC%8FServer%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[注意：以下的所有操作、原理、源码全部是建立在Spring Boot 2.1.7基础上的。 &nbsp;&nbsp; 修改SpringBoot对嵌入式Server容器的默认配置&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot默认使用Tomcat作为嵌入式的Servlet容器。实际应用中我们需要对他进行专门的定制。定制的方式不外乎两种：application.proeprties(yml)或在配置类中注册组件的方式，但是这里介绍了3种方法，其实后面两种方法大同小异，原理都是一样的。 方式1：直接在application.properties/application.xml文件中配置和server有关的属性配置方式是server.属性名=值，下面是ServerProperties类中定义的绝大多数可以配置的属性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273server配置server.address 指定server绑定的地址server.compression.enabled 是否开启压缩，默认为false.server.compression.excluded-user-agents 指定不压缩的user-agent，多个以逗号分隔，默认值为:text/html,text/xml,text/plain,text/cssserver.compression.mime-types 指定要压缩的MIME type，多个以逗号分隔.server.compression.min-response-size 执行压缩的阈值，默认为2048server.context-parameters.[param name] 设置servlet context 参数server.context-path 设定应用的context-path.server.display-name 设定应用的展示名称，默认: applicationserver.jsp-servlet.class-name 设定编译JSP用的servlet，默认: org.apache.jasperservlet.JspServlet)server.jsp-servlet.init-parameters.[param name] 设置JSP servlet 初始化参数.server.jsp-servlet.registered 设定JSP servlet是否注册到内嵌的servlet容器，默认trueserver.port 设定http监听端口server.servlet-path 设定dispatcher servlet的监听路径，默认为: /cookie、session配置server.session.cookie.comment 指定session cookie的commentserver.session.cookie.domain 指定session cookie的domainserver.session.cookie.http-only 是否开启HttpOnly.server.session.cookie.max-age 设定session cookie的最大age.server.session.cookie.name 设定Session cookie 的名称.server.session.cookie.path 设定session cookie的路径.server.session.cookie.secure 设定session cookie的“Secure” flag.server.session.persistent 重启时是否持久化session，默认falseserver.session.timeout session的超时时间server.session.tracking-modes 设定Session的追踪模式(cookie, url, ssl).ssl配置server.ssl.ciphers 是否支持SSL ciphers.server.ssl.client-auth 设定client authentication是wanted 还是 needed.server.ssl.enabled 是否开启ssl，默认: trueserver.ssl.key-alias 设定key store中key的别名.server.ssl.key-password 访问key store中key的密码.server.ssl.key-store 设定持有SSL certificate的key store的路径，通常是一个.jks文件.server.ssl.key-store-password 设定访问key store的密码.server.ssl.key-store-provider 设定key store的提供者.server.ssl.key-store-type 设定key store的类型.server.ssl.protocol 使用的SSL协议，默认: TLSserver.ssl.trust-store 持有SSL certificates的Trust store.server.ssl.trust-store-password 访问trust store的密码.server.ssl.trust-store-provider 设定trust store的提供者.server.ssl.trust-store-type 指定trust store的类型.tomcat配置server.tomcat.access-log-enabled 是否开启access log ，默认: false)server.tomcat.access-log-pattern 设定access logs的格式，默认: commonserver.tomcat.accesslog.directory 设定log的目录，默认: logsserver.tomcat.accesslog.enabled 是否开启access log，默认: falseserver.tomcat.accesslog.pattern 设定access logs的格式，默认: commonserver.tomcat.accesslog.prefix 设定Log 文件的前缀，默认: access_logserver.tomcat.accesslog.suffix 设定Log 文件的后缀，默认: .logserver.tomcat.background-processor-delay 后台线程方法的Delay大小: 30server.tomcat.basedir 设定Tomcat的base 目录，如果没有指定则使用临时目录.server.tomcat.internal-proxies 设定信任的正则表达式，默认:“10\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;| 192\.168\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;| 169\.254\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;| 127\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;| 172\.1[6-9]&#123;1&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;| 172\.2[0-9]&#123;1&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;|172\.3[0-1]&#123;1&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;”server.tomcat.max-http-header-size 设定http header的最小值，默认: 0server.tomcat.max-threads 设定tomcat的最大工作线程数，默认为: 0server.tomcat.port-header 设定http header使用的，用来覆盖原来port的value.server.tomcat.protocol-header 设定Header包含的协议，通常是 X-Forwarded-Proto，如果remoteIpHeader有值，则将设置为RemoteIpValve.server.tomcat.protocol-header-https-value 设定使用SSL的header的值，默认https.server.tomcat.remote-ip-header 设定remote IP的header，如果remoteIpHeader有值，则设置为RemoteIpValveserver.tomcat.uri-encoding 设定URI的解码字符集.undertow配置server.undertow.access-log-dir 设定Undertow access log 的目录，默认: logsserver.undertow.access-log-enabled 是否开启access log，默认: falseserver.undertow.access-log-pattern 设定access logs的格式，默认: commonserver.undertow.accesslog.dir 设定access log 的目录.server.undertow.buffer-size 设定buffer的大小.server.undertow.buffers-per-region 设定每个region的buffer数server.undertow.direct-buffers 设定堆外内存server.undertow.io-threads 设定I/O线程数.server.undertow.worker-threads 设定工作线程数 配置示例： 12345678910server: port: 80 #端口 servlet: context-path: /crud #项目的context-path tomcat: uri-encoding: UTF-8 #tomcat URI的字符编码 basedir: localhost/crud #tomcat基路径 compression: #是否开启压缩文件 enabled: true #true是开启 mime-types: text/html,text/css,text/javascript #压缩的文件类型 方式2：向IoC容器中添加servlet容器工厂定制器 WebServerFactoryCustomizer123456789101112131415161718@Configurationpublic class ServerConfig &#123; @Bean //注册到IOC容器中 public WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; webServerFactoryCustomizer()&#123; return factory -&gt; &#123; //在这里设置server有关对属性 factory.setPort(8085); factory.setContextPath("/crud"); factory.setUriEncoding(Charset.forName("utf-8")); Compression compression = new Compression(); compression.setEnabled(true); String []mimes=&#123;"text/html","text/css"&#125;; compression.setMimeTypes(mimes); factory.setCompression(compression); &#125;; &#125;&#125; 运行结果： 如果使用的是Spring Boot 1.x版本可以参考下面的方法来使用配置 123456789101112public class ServerConfig extends WebMvcConfigurerAdapter &#123; public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer() &#123; return new EmbeddedServletContainerCustomizer() &#123; @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; //配置server属性 container.setPort(8083); ... &#125; &#125;; &#125;&#125; 方式3：向IoC容器中添加可配置的servlet容器工厂 ConfigurableServletWebServerFactory123456789101112131415161718@Configurationpublic class ServerConfig &#123; @Bean public ConfigurableServletWebServerFactory configurableServletWebServerFactory() &#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); //设置属性 factory.setPort(8089); factory.setContextPath("/springboot"); factory.setUriEncoding(Charset.forName("utf-8")); Compression compression = new Compression(); compression.setEnabled(true); String[] mimes = &#123;"text/html", "text/css"&#125;; compression.setMimeTypes(mimes); factory.setCompression(compression); return factory; &#125;&#125; 运行自然是没有什么问题，在地址栏输入localhost:8089/springboot/也来到了目标页面： 在Spring Boot中注册Servlet三大组件【Servlet、Filter、Listener】以前注册这些组件都是在web.xml中配置，由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动Spring Boot的web应用，默认就没有web.xml文件了。那怎么办呢？Spring Boot给的解决办法很简单，就是使用对应的XxxRegistrationBean来注册，具体的方法参考下面示例 注册三大组件用以下方式： 1、借助ServletRegistrationBean注册自定义Servlet组件； 自定义MyServlet.java： 12345678public class MyServlet extends HttpServlet &#123; //重写service方法 @Override protected void service(HttpServletRequest req,HttpServletResponse resp)&#123; resp.getWriter().write("Hello Spring Boot!"); &#125;&#125; 借助ServletRegistrationBean来注册一个Servlet并放入容器中： 12345@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),"/myServlet"); return registrationBean;&#125; 2、借助FilterRegistrationBean注册自定义Filter组件(自定义的MyFilter忽略) 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList("/hello","/myServlet")); return registrationBean;&#125; 3、借助ServletListenerRegistrationBean注册自定义Listener组件(自定义的MyListener忽略) 12345@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; &nbsp;&nbsp; 嵌入式Servlet容器切换三大容器比较 容器 优点 缺点 默认 tomcat 功能齐全 庞大，荣泽 true jetty 轻量 功能不全 false undertow 异步，高效 不支持jsp false 容器切换 Tomcat Spring Boot引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器。 1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Jetty 123456789101112131415161718&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!--排除tomcat--&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入jetty容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; undertow 1234567891011121314151617&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; &nbsp;&nbsp; 嵌入式Servlet容器自动配置原理主要的三个类： ServletWebServerFactoryConfiguration ServletWebServerFactoryAutoConfiguration ServletWebServerFactoryCustomizer ServletWebServerFactoryConfiguration首先从ServletWebServerFactoryConfiguration这个配置类说起，在它里面主要有三个嵌入式的Web容器：EmbeddedUndertow ，EmbeddedJetty，EmbeddedTomcat以及@Conditionalxxx 标注的类（条件检查，只有条件满足才向容器中添加组件）。这个类的作用就是根据配置的环境，产生一个对应容器的工厂类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configurationclass ServletWebServerFactoryConfiguration &#123; //默认配置的就是Tomcat @Configuration //条件检查：类路径下存在servlet.class(存在servlet依赖) tomcat.class(tomcat依赖) 才会执行向容器中添加组件 @ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;) //判断容器中有没有用户自定义的ServletWeServerbFactory @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedTomcat &#123; //向IOC容器中添加tomcat工厂，之后由工厂产生嵌入式的tomcat实例 @Bean public TomcatServletWebServerFactory tomcatServletWebServerFactory() &#123; return new TomcatServletWebServerFactory(); &#125; &#125; /** * 如果配置了Jetty就会自动配置jetty */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class, WebAppContext.class &#125;) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedJetty &#123; @Bean public JettyServletWebServerFactory JettyServletWebServerFactory() &#123; return new JettyServletWebServerFactory(); &#125; &#125; /** * 如果配置了Undertow就会自动配置Undertow */ @Configuration @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;) @ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT) public static class EmbeddedUndertow &#123; @Bean public UndertowServletWebServerFactory undertowServletWebServerFactory() &#123; return new UndertowServletWebServerFactory(); &#125; &#125;&#125;&#125; ServletWebServerFactory：嵌入式Servlet工厂。作用：创建嵌入式Servlet容器 1234567@FunctionalInterfacepublic interface ServletWebServerFactory &#123; //ServletWebServerFactory只有一个接口方法getWebServer，他会拿到Spring Boot在启动的时候初始化的参数 WebServer getWebServer(ServletContextInitializer... initializers);&#125; 在判断@ConditionalOnClass({Servlet.class, Tomcat.class, UpgradeProtocol.class})是否导入依赖，满足条件后return new TomcatServletWebServerFactory(); 添加对应的Servlet容器工厂；通过工厂的唯一方法getWebServer 获取对应的Servlet容器TomcatServer. TomcatServletWebServerFactory 123456789101112131415161718192021222324252627282930313233public class TomcatServletWebServerFactory extends AbstractServletWebServerFactory implements ConfigurableTomcatWebServerFactory, ResourceLoaderAware &#123; public WebServer getWebServer(ServletContextInitializer... initializers) &#123; // 1. 创建Tomcat对象 Tomcat tomcat = new Tomcat(); //设置tomcat的基路径 File baseDir = this.baseDirectory != null ? this.baseDirectory : this.createTempDir("tomcat"); tomcat.setBaseDir(baseDir.getAbsolutePath()); // 2.完成tomct 配置的基本操作 Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); this.customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); this.configureEngine(tomcat.getEngine()); Iterator var5 = this.additionalTomcatConnectors.iterator(); while(var5.hasNext()) &#123; Connector additionalConnector = (Connector)var5.next(); tomcat.getService().addConnector(additionalConnector); &#125; this.prepareContext(tomcat.getHost(), initializers); 3.将tomcat 传入方法：getTomcatWebServer() return this.getTomcatWebServer(tomcat); &#125;&#125; TomcatWebServer 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class TomcatWebServer implements WebServer &#123; //TomcatWebServer的构造器中真正的实例化tomcat，并且启动tomcat public TomcatWebServer(Tomcat tomcat, boolean autoStart) &#123; this.monitor = new Object(); this.serviceConnectors = new HashMap(); Assert.notNull(tomcat, "Tomcat Server must not be null"); this.tomcat = tomcat; this.autoStart = autoStart; this.initialize(); &#125; //initialize方法执行初始化 private void initialize() throws WebServerException &#123; logger.info("Tomcat initialized with port(s): " + getPortsDescription(false)); synchronized (this.monitor) &#123; try &#123; addInstanceIdToEngineName(); Context context = findContext(); context.addLifecycleListener((event) -&gt; &#123; if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123; //服务启动的时候执行 removeServiceConnectors(); &#125; &#125;); //启动tomcat this.tomcat.start(); // We can re-throw failure exception directly in the main thread rethrowDeferredStartupExceptions(); try &#123; ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader()); &#125; catch (NamingException ex) &#123; // Naming is not enabled. Continue &#125; // Unlike Jetty, all Tomcat threads are daemon threads. We create a // blocking non-daemon to stop immediate shutdown startDaemonAwaitThread(); &#125; catch (Exception ex) &#123; stopSilently(); destroySilently(); throw new WebServerException("Unable to start embedded Tomcat", ex); &#125; &#125; &#125;&#125; ServletWebServerFactoryAutoConfiguration修改定制嵌入式Servlet 容器的方法:&nbsp;&nbsp;&nbsp;1、配置文件中添加配置。&nbsp;&nbsp;&nbsp;2、ServerProperties 绑定/修改定制组件 WebServerFactoryCustomizer 他们的本质是一样的：在ServletWebServerFactoryAutoConfiguration配置类中@EnableConfigurationProperties({ServerProperties.class})。导入了BeanPostProcessorsRegistrar，在这个类的方法中添加了组件WebServerFactoryCustomizerBeanPostProcessor(定制器后置处理器)。也就是说一旦容器中添加任何组件都会启动定制后置处理器，进行Servlet的赋值。 ServletWebServerFactoryCustomizer在这个配置类中使用customize(ConfigurableServletWebServerFactory factory)这个方法 完成了Tomcat的各项配置的修改和定制 1234567891011121314151617181920public class ServletWebServerFactoryCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;, Ordered &#123; //具体对Tomcat的配置细节 @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull(); map.from(this.serverProperties::getPort).to(factory::setPort); map.from(this.serverProperties::getAddress).to(factory::setAddress); map.from(this.serverProperties.getServlet()::getContextPath).to(factory::setContextPath); map.from(this.serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName); map.from(this.serverProperties.getServlet()::getSession).to(factory::setSession); map.from(this.serverProperties::getSsl).to(factory::setSsl); map.from(this.serverProperties.getServlet()::getJsp).to(factory::setJsp); map.from(this.serverProperties::getCompression).to(factory::setCompression); map.from(this.serverProperties::getHttp2).to(factory::setHttp2); map.from(this.serverProperties::getServerHeader).to(factory::setServerHeader); map.from(this.serverProperties.getServlet()::getContextParameters).to(factory::setInitParameters); &#125;&#125; 配置修改定制原理(以tomcat为例)1、Spring Boot根据根据导入依赖的情况，给容器中添加相应的ServletWebServerFactory（比如tomcat就会添加TomcatServletWebServerFactory） 2、如果使用的是通过application.properties 修改配置，那么server 相关的配置修改是与ServerProperties 类绑定的，所以相关的修改会直接通过ServerProperties 的方法实现【相关的配置类：ServletWebServerFactoryCustomizer】 3、如果使用的是修改定制器 WebServerFactoryCustomizer的方法来配置server，那么定制器会创建ConfigurableWebServerFactory对象，这样一来就会触发WebServerFactoryCustomizerBeanPostProcessor 后置处理器，判断是否为WebServerFactory 类型；满足条件后，就会获取容器中的所有定制器（customizer.cutomize(bean)），为Servlet容器修改和定制配置【相关的配置类ServletWebServerFactoryAutoConfiguration，导入了定制处理器】 &nbsp;&nbsp; 嵌入式Servlet 容器启动的原理（tomcat）几个重要的回调机制：配置在META-INF/spring.factories ApplicationContextInitializer SpringApplicationRunListener 只需要放在ioc容器中 ApplicationRunner CommandLineRunner 1、SpringBoot 应用启动，运行run()方法跟随源码我们来到SpringApplication类中发现他对run方法进行了几次封装 1234567891011121314151617181920212223242526272829303132333435//这是我们在启动类中调用的run()方法public static ConfigurableApplicationContext run(Class&lt;?&gt; primarySource, String... args) &#123; //调用了本类中的另一个run()方法,也就是紧跟着下面的这个方法 return run(new Class[]&#123;primarySource&#125;, args);&#125;public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; //调用了SpringApplication中的构造器创建了一个SpringAapplication的对象，并最终调用了真正的run方法 return (new SpringApplication(primarySources)).run(args);&#125;//最终执行初始化SpringApplication的构造器public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123; this.sources = new LinkedHashSet(); this.bannerMode = Mode.CONSOLE; this.logStartupInfo = true; //默认开启命令行参数 this.addCommandLineProperties = true; this.addConversionService = true; this.headless = true; this.registerShutdownHook = true; //多profiles初始化，使用的是HashSet来保存 this.additionalProfiles = new HashSet(); this.isCustomEnvironment = false; this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath(); //设置初始化参数 this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class)); //设置监听器 this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class)); //从多个主配置类中找到有main方法的的主配置类（启动类） this.mainApplicationClass = this.deduceMainApplicationClass();&#125; 运行run()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); //获取SpringApplictionRunListeners对象，从META-INF/factroies下加载 SpringApplicationRunListeners listeners = getRunListeners(args); //回调所有的SpringApplicationRunListeners的startings方法 listeners.starting(); try &#123; //封装命令行参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //准备环境，在这个方法内部当环境创建完成后会调用SpringApplicationRunListener的environmentPrepared()方法表示环境准备完成 ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); //Spring Boot一启动打印Spring图标就是在这里完成的 Banner printedBanner = printBanner(environment); //创建ioc容器 context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); //准备上下文环境：将environment保存到ioc容器中 prepareContext(context, environment, listeners, applicationArguments, printedBanner); //刷新容器：扫描、加载、创建所有组件的地方（如果Web环境默认还会创建嵌入式的tomcat容器） refreshContext(context); //从ioc容器中获取所有的ApplicationRunner和CommandLineRunner进行回调。ApplicationRunner先回调，CommandLineRunner再回调 afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; //Spring Boot引用启动完成后返回ioc容器 return context; &#125; 2、SpringApplication类中的run方法中调用refreshContext(context) 刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】,如果是web应用创建AnnotationConfigEmbeddedWebApplicationContext，否则普通应用创建AnnotationConfigApplicationContext 1234567891011121314151617private void refreshContext(ConfigurableApplicationContext context) &#123; //直接调用的是本类中的refresh方法 refresh(context); if (this.registerShutdownHook) &#123; try &#123; context.registerShutdownHook(); &#125; catch (AccessControlException ex) &#123; // Not allowed in some environments. &#125; &#125; &#125; //在这里真正调用AbstractApplicationContext类中的refersh方法来刷新容器 protected void refresh(ApplicationContext applicationContext) &#123; Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext); ((AbstractApplicationContext) applicationContext).refresh(); &#125; 3、refresh()刷新刚才创建好的ioc容器AbstractApplicationContext 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Override public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn("Exception encountered during context initialization - " + "cancelling refresh attempt: " + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; 4、Web模块的IOC容器重写了onRefresh()方法，创建了嵌入式的Servlet容器5、获取嵌入式工厂容器组件：ServletWebServerFactory factory = this.getServletWebServerFactory (); TomcatServletWebServerFactory 对象被创建，触发后置处理器，配置类中：@EnableConfigurationProperties({ServerProperties.class}) 根据配置文件，获取所有的定制器为Servlet容器赋值6、TomcatServerWebServletFactory 获取后使用这个容器工厂获取Servlet容器TomcatWebServer(其他容器类似) 完成自启动7、嵌入式的Servlet容器创建对象并启动Servlet容器 IOC容器启动创建嵌入式的Servlet容器，再启动嵌入式的Servlet容器，再将IOC容器中剩下没有创建出的对象获取出来]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 错误处理机制]]></title>
    <url>%2F2019%2F09%2F02%2FSpringBoot%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; Spring Boot默认的错误处理机制（现象）&nbsp;&nbsp;&nbsp;&nbsp;当我们使用Spring Boot发生错误的时候，如果我们没有配置错误的处理规则，那么Spring Boot就会启用内部的默认错误处理办法。比如当发生404错误的时候，网页端的效果如下： 而在别的客户端访问的时候如果出现了404错误，默认会给客户端发送一串错误消息的JSON数据 客户端的测试使用到了一个工具：Postman,感兴趣的小伙伴可以去Postman官网下载后来测试。 &nbsp;&nbsp; Spring Boot默认的错误处理机制（原理）&nbsp;&nbsp;&nbsp;&nbsp;看到这些现象我们不禁会有疑问，Spring Boot的底层是如何生成不同错误的默认错误页面的？还有他是如何区分浏览器和普通客户端的？带着疑问我们继续往下看。&nbsp;&nbsp;&nbsp;&nbsp;我们参照源码来分析一下（Spring Boot 2.1.7版本），具体在ErrorMvcAutoConfiguration这个错误处理自动配置类,下面是在这个类中注册的几个重要的组件的源码： ErrorMvcAutoConfiguration源码片段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class &#125;)// Load before the main WebMvcAutoConfiguration so that the error View is available@AutoConfigureBefore(WebMvcAutoConfiguration.class)@EnableConfigurationProperties(&#123; ServerProperties.class, ResourceProperties.class, WebMvcProperties.class &#125;)public class ErrorMvcAutoConfiguration &#123; //注册DefaultErrorAttributs @Bean @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() &#123; return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); &#125; //注册BaseErrorController @Bean @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT) public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123; return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers); &#125; //注册ErrorPageCustomizer @Bean public ErrorPageCustomizer errorPageCustomizer() &#123; return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath); &#125; //配置DefaultErrorViewResolver内部类 @Configuration static class DefaultErrorViewResolverConfiguration &#123; private final ApplicationContext applicationContext; private final ResourceProperties resourceProperties; DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, ResourceProperties resourceProperties) &#123; this.applicationContext = applicationContext; this.resourceProperties = resourceProperties; &#125; //在这个静态内部内中配置了DefaultErrorViewResolver @Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean public DefaultErrorViewResolver conventionErrorViewResolver() &#123; return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); &#125; &#125;&#125; 可以看到，ErrorMvcAutoConfiguration这个错误处理类中配置了几个重要的组件： DefaultErrorAttributs ：翻译这个类的名字：默认的错误属性，他就是和错误信息的填充有关。 BasicErrorController ：他是Spring Boot中默认处理/error请求的Controller ErrorPageCustomizer ：系统出现错误以后来到error请求进行处理 DefaultErrorViewResolver ：默认的错误视图解析器 继续跟踪源码 DefaultErrorAttributs源码片段 12345678910111213141516171819@Order(Ordered.HIGHEST_PRECEDENCE)public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123; //获得错误的属性信息，在页面上默认显示的错误信息都由这来的 @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; //new了一个Map Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;(); //产生错误放生的时间戳 errorAttributes.put("timestamp", new Date()); //产生错误的状态码 addStatus(errorAttributes, webRequest); //错误的细节 addErrorDetails(errorAttributes, webRequest, includeStackTrace); //错误的路径 addPath(errorAttributes, webRequest); return errorAttributes; &#125;&#125; BasicErrorController源码片段 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping("$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;")public class BasicErrorController extends AbstractErrorController &#123; //浏览器的错误请求用这个处理方法来处理，产生HTML数据 @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; //得到状态码 HttpStatus status = getStatus(request); //把ErrorAttributs中的错误信息填充到model中 Map&lt;String, Object&gt; model = Collections .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); //设置响应码 response.setStatus(status.value()); //去哪个页面作为错误页面,包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); //如果没有映射到可以去的错误页面就会去默认的错误页面(就是看到的那个白板页面) return (modelAndView != null) ? modelAndView : new ModelAndView("error", model); &#125; //返回JSON格式的数据，非浏览器访问后错误的处理方法 @RequestMapping public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); //返回Json数据 return new ResponseEntity&lt;&gt;(body, status); &#125;&#125; BasicErrorController中调用了它父类AbstractErrorControlle的方法resolveErrorView来处理ModelAndViewAbstractErrorController源码片段 123456789101112public abstract class AbstractErrorController implements ErrorController &#123;protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status,Map&lt;String, Object&gt; model) &#123; //遍历所有的错误视图处理器 for (ErrorViewResolver resolver : this.errorViewResolvers) &#123; ModelAndView modelAndView = resolver.resolveErrorView(request, status, model); if (modelAndView != null) &#123; return modelAndView; &#125; &#125; return null; &#125;&#125; ErrorPageCustomizer源码片段 123456789101112131415161718192021222324252627 /** *ErrorMvcAutoConfiguration的内部类 * &#123;@link WebServerFactoryCustomizer&#125; that configures the server's error pages. */private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered &#123; private final ServerProperties properties; private final DispatcherServletPath dispatcherServletPath; protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) &#123; this.properties = properties; this.dispatcherServletPath = dispatcherServletPath; &#125; @Override public void registerErrorPages(ErrorPageRegistry errorPageRegistry) &#123; ErrorPage errorPage = new ErrorPage( this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())); errorPageRegistry.addErrorPages(errorPage); &#125; @Override public int getOrder() &#123; return 0; &#125;&#125; DefaultErrorViewResolver源码片段 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered &#123; private static final Map&lt;Series, String&gt; SERIES_VIEWS; //错误状态码 static &#123; Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class); views.put(Series.CLIENT_ERROR, "4xx"); views.put(Series.SERVER_ERROR, "5xx"); SERIES_VIEWS = Collections.unmodifiableMap(views); &#125; @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; // 这里如果没有拿到精确状态码(如404)的视图，则尝试拿4XX(或5XX)的视图 ModelAndView modelAndView = resolve(String.valueOf(status.value()), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView; &#125; private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; //默认情况下Spring Boot会在error/目录下去找视图，比如error/404.html或error/4xx String errorViewName = "error/" + viewName; //如果模板引擎可以解析就有模板引擎来解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; //模板引擎可用的情况下返回到errorViewName指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面 error/404.html return resolveResource(errorViewName, model); &#125; //从静态资源文件夹下面找错误页面 private ModelAndView resolveResource(String viewName, Map&lt;String, Object&gt; model) &#123; //遍历所有静态资源文件到的路径来看看有没有和viewName同名的视图名（网页名） for (String location : this.resourceProperties.getStaticLocations()) &#123; try &#123; Resource resource = this.applicationContext.getResource(location); resource = resource.createRelative(viewName + ".html"); if (resource.exists()) &#123; //如果有就返回该视图的ModelAndView return new ModelAndView(new HtmlResourceView(resource), model); &#125; &#125; catch (Exception ex) &#123; &#125; &#125; //没有就返回null return null; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;大致分析源码后可以总结Spring Boot对错误的处理流程如下：如果系统出现4xx或者5xx之类的错误，ErrorPageCustomizer就会生效（定制错误的响应规则），就会发出/error请求，然后就会被BasicErrorController处理并返回ModelAndView（网页）或者JSON（客户端）。 &nbsp;&nbsp; 使用Spring Boot默认的错误处理机制来处理我们程序中的错误情况&nbsp;&nbsp;&nbsp;&nbsp;通过分析源码我们可以发现，如果要使用Spring Boot默认的错误处理机制，我们可以把我们定制的错误页面放在/templates/error目录下的，交给模板引擎来处理；或者不使用模板引擎那就放在static/error目录下。并且给这些错误页面命名为错误码.html或4xx.html、5xx.html。Spring Boot就可以自动帮我们映射到错误页面。例如，处理404错误：在/templates/error目录下放404.html &nbsp;&nbsp;&nbsp;&nbsp;访问浏览器，在地址栏中随便输入一个地址让他发生404错误，结果来到了我们定制的404错误页面，而不是Spring Boot默认的那个难看的白板页面。 4xx.html 123456789101112131415161718192021&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="Generator" content="EditPlus®"&gt; &lt;meta name="Author" content=""&gt; &lt;meta name="Keywords" content=""&gt; &lt;meta name="Description" content=""&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;main role="main" class="col-md-9 ml-sm-auto col-lg-10 pt-3 px-4"&gt; &lt;h1&gt;status:[[$&#123;status&#125;]]&lt;/h1&gt; &lt;h2&gt;timestamp:[[$&#123;timestamp&#125;]]&lt;/h2&gt; &lt;h2&gt;exception:[[$&#123;exception&#125;]]&lt;/h2&gt; &lt;h2&gt;message:[[$&#123;message&#125;]]&lt;/h2&gt; &lt;h2&gt;ext:[[$&#123;ext.code&#125;]]&lt;/h2&gt; &lt;h2&gt;ext:[[$&#123;ext.message&#125;]]&lt;/h2&gt;&lt;/main&gt; &lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp;&nbsp; 定制自己的错误信息默认情况下，Spring Boot的错误页面中可以可得一下错误信息： 123456​timestamp：时间戳​status：状态码​error：错误提示exception：异常对象message：异常消息errors：JSR303数据校验的错误 第一种方式：使用Spring MVC的异常处理器12345678910111213@ControllerAdvicepublic class MyExceptionHandler &#123; @ResuestBody @ExceptionHandler(NullPointerException.class) public Map&lt;String,Object&gt; handleException(Exception e, HttpServletResponse response)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put("code",""); map.put("message",e.getMessage()); map.put("exception",e.getClass()); return map; &#125; &#125; 这样无论是浏览器还是别的客户端，只要出错了就全部返回的JSON数据。 ##### 第二种方式：转发到/error请求进行自适应效果处理 12345678910111213141516@ControllerAdvicepublic class MyExceptionHandler &#123; @ExceptionHandler(NullPointerException.class) public String handleException(Exception e,HttpServletResponse response, HttpServletRequest request)&#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); //设置状态码【必须】 request.setAttribute("javax.servlet.error.status_code",500); map.put("code","null exception"); map.put("message",e.getMessage()); map.put("exception",e.getClass()); //转发到/error return "forward:/error"; &#125;&#125; 第三种方式：编写一个MyErrorAttributes继承自DefaultErrorAttributes重写其getErrorAttributes方法前两种虽然都可以解决错误，但是单当我们自己定义一个错误属性（比如上面的code属性）就没办法带到页面，因此我们设置的信息也就无法被带到页面显示。我们可以编写一个MyErrorAttributes继承自DefaultErrorAttributes重写其getErrorAttributes方法将我们的错误数据添加进去。 12345678910111213@Component //使用我们的ErrorAttributespublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123; //得到原有的errorAttributes Map&lt;String,Object&gt; errorAttributes=super.getErrorAttributes(webRequest,includeStackTrace); errorAttributes.put("code","MyError"); errorAttributes.remove("exception"); errorAttributes.put("path",webRequest.getContextPath()); return errorAttributes; &#125;&#125; 最终的效果：响应是自适应的，以后可以通过定制ErrorAttributes改变需要返回的内容。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot自动配置Spring MVC的原理]]></title>
    <url>%2F2019%2F08%2F29%2FSpringBootMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; Spring MVC自动配置&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot对Spring MVC自动配置的详细可以参考管方文档。Spring Boot为Spring MVC提供的AutoConfiguration适用于大多数应用场景，Spring Boot对Spring MVC做了以下默认的自动配置： 1.引入ContentNegotiatingViewResolver 和 BeanNameViewResolver 。 2.对静态资源的支持，包括对WebJars 的支持。 3.自动注册Converter，GenericConverter，Formatter。 4.对HttpMessageConverters 的支持。 5.自动注册MessageCodeResolver。 6.对静态index.html的支持。 7.对自定义Favicon的支持。 8.自动使用 ConfigurableWebBindingInitializer bean。 &nbsp;&nbsp;&nbsp;&nbsp;Spring Boot默认情况下是自动配置好Spring MVC的，可以直接使用，但是Spring Boot也支持我们修改Spring Boot对SpringMVC的配置。如果保留Spring Boot MVC特性，我们只需添加其他的MVC配置（拦截器，格式化处理器，视图控制器等）。我们可以添加自己的WebMvcConfigurerAdapter 类型的@Configuration类（配置类），而不需要注解@EnableWebMvc。如果希望使用自定义的RequestMappingHandlerMapping，RequestMappingHandlerAdapter，或ExceptionHandlerExceptionResolver，我们可以声明一个WebMvcRegistrationsAdapter实例提供这些组件。 &nbsp;&nbsp;&nbsp;&nbsp;但是如果想全面控制Spring MVC，我们可以添加自己的@Configuration类，并使用@EnableWebMvc注解。这样Spring Boot就不会对MVC进行配置了。然后我们就可以像刚开始使用Spring MVC那样对他进行配置。 &nbsp;&nbsp;Spring MVC自动配置原理细节&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot对Spring MVC的自动配置主要是通过WebMvcAutoConfiguration这个类实现的，接下来我们就结合这个类来简单分析一下自动配置的细节。 ContentNegotiatingViewResolver 和 BeanNameViewResolver &nbsp;&nbsp;&nbsp;&nbsp;这两个一听名字就知道是和视图解析器有关，也确实是这样的，他们自动配置了ViewReslover，然后由ViewReslover得到View对象，View对象调用他的render方法渲染页面等等。其中BeanNameViewResolver 就是SpringMVC中的一个视图解析器，他可以通过视图名来获得视图解析器，而ContentNegotiatingViewResolver的作用就是组合所有的视图解析器，下面他们的源码： 12345678910111213141516171819202122232425262728293031@Configuration@ConditionalOnWebApplication(type = Type.SERVLET)@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, ValidationAutoConfiguration.class &#125;)public class WebMvcAutoConfiguration &#123; @Bean @ConditionalOnBean(View.class) @ConditionalOnMissingBean //只会创建一个 public BeanNameViewResolver beanNameViewResolver() &#123; BeanNameViewResolver resolver = new BeanNameViewResolver(); //给这个视图解析器设置执行顺序order，他的级别是很低的 resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10); return resolver; &#125; @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = "viewResolver", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver uses all the other view resolvers to locate // a view so it should have a high precedence resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; &#125;&#125; 问题：ContentNegotiatingViewResolver是如何组合所有视图解析器的？ 1234567891011121314151617181920212223242526272829303132333435public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered, InitializingBean &#123; @Nullable private List&lt;ViewResolver&gt; viewResolvers; @Override protected void initServletContext(ServletContext servletContext) &#123; Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values(); if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size()); //遍历BeanFactoryutils中的视图解析器 for (ViewResolver viewResolver : matchingBeans) &#123; if (this != viewResolver) &#123; //如果没有这个视图解析器，那就把它加入 this.viewResolvers.add(viewResolver); &#125; &#125; &#125;else &#123; for (int i = 0; i &lt; this.viewResolvers.size(); i++) &#123; ViewResolver vr = this.viewResolvers.get(i); if (matchingBeans.contains(vr)) &#123; continue; &#125; String name = vr.getClass().getName() + i; obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name); &#125; &#125; AnnotationAwareOrderComparator.sort(this.viewResolvers); this.cnmFactoryBean.setServletContext(servletContext); &#125;&#125; 因此，我们可以实现自己的视图解析器，然后ContentNegotiatingViewResolver把它注册到容器中。定制自己的视图解析器我们可以在启动类中实现ViewResolver接口，编写我们自己的视图解析器，然使用@Bean标签配置给IOC容器。 123456789101112131415161718192021222324252627282930313233343536package com.xust.iot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;@SpringBootApplicationpublic class SpringBootWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebApplication.class, args); &#125; //直接在容器中添加我们的视图解析器 @Bean public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; /** * 实现ViewResolver */ public static class MyViewResolver implements ViewResolver&#123; @Override public View resolveViewName(String viewName, Locale locale) throws Exception &#123; //在这里面写我们自己的视图处理逻辑 return null; &#125; &#125;&#125; Converter，GenericConverter，Formatter 这些功能在Spring Boot中也有默认的自动配置，这里我们要了解的是如何扩展配置Converter和Formatter。源码： 1234567891011121314151617181920@Bean@ConditionalOnProperty(prefix = "spring.mvc", name = "date-format")//在文件中配置日期格式化的规则public Formatter&lt;Date&gt; dateFormatter() &#123; return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件&#125;//添加格式化组件@Overridepublic void addFormatters(FormatterRegistry registry) &#123; for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123; registry.addConverter(converter); &#125; for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123; registry.addConverter(converter); &#125; for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123; registry.addFormatter(formatter); &#125;&#125; 我们也可以定制自己的转换器 12345678910111213141516171819202122232425262728293031323334package com.xust.iot;import com.xust.iot.bean.User;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.core.convert.converter.Converter;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;@SpringBootApplicationpublic class SpringBootWebApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootWebApplication.class, args); &#125; @Bean public Converter&lt;?,?&gt; userToStringConverter()&#123; return new UserToStringConverter(); &#125; //把User对象转换成String public static class UserToStringConverter implements Converter&lt;User,String&gt;&#123; @Override public String convert(User source) &#123; //写我们自己的转换规则 return null; &#125; &#125;&#125; HttpMessageConverters &nbsp;&nbsp;&nbsp;&nbsp;Spring MVC 使用HttpMessageConverter 接口转换HTTP 请求和响应，合适的默认配置可以开箱即用，例如对象自动转换为JSON（使用Jackson库）或XML（如果Jackson XML扩展可用，否则使用JAXB），字符串默认使用UTF-8编码。可以使用Spring Boot 的HttpMessageConverters 类添加或自定义转换类： 123456789101112131415161718192021222324@Configurationpublic class FastJsonHttpMessageConvertersConfig extends WebMvcConfigurerAdapter &#123; @Bean public FastJsonConfig fastJsonConfig() &#123; FastJsonConfig fastJsonConfig = new FastJsonConfig(); SerializerFeature writeMapNullValue = SerializerFeature.WriteMapNullValue; SerializerFeature WriteNullStringAsEmpty = SerializerFeature.WriteNullStringAsEmpty; SerializerFeature WriteNullNumberAsZero = SerializerFeature.WriteNullNumberAsZero; SerializerFeature WriteNullListAsEmpty = SerializerFeature.WriteNullListAsEmpty; fastJsonConfig.setSerializerFeatures(writeMapNullValue, WriteNullStringAsEmpty, WriteNullNumberAsZero, WriteNullListAsEmpty); return fastJsonConfig; &#125; @Bean public HttpMessageConverters fastJsonHttpMessageConverters( @Qualifier("fastJsonConfig") FastJsonConfig fastJsonConfig) &#123; FastJsonHttpMessageConverter4 fastConverter = new FastJsonHttpMessageConverter4(); fastConverter.setFastJsonConfig(fastJsonConfig); HttpMessageConverter&lt;?&gt; converter = fastConverter; return new HttpMessageConverters(converter); &#125;&#125; &nbsp;&nbsp;扩展Spring Boot对Spring MVC的配置&nbsp;&nbsp;&nbsp;&nbsp;想要扩展Spring Boot的MVC功能，我们要WebMvcConfigurer接口，但是这样太麻烦了，因此Spring Boot提供了一个适配器类WebMvcConfigurerAdapter，它里面全部是一些空方法，我们可以继承WebMvcConfigurerAdapter类，然后我们只需要按照我们的需要重写里面的方法就好了。（注：Spring Boot 2.0以后官方废除了WebMvcConfigurerAdapter类，而是推荐我们直接实现WebMvcConfigurer接口。） 12345678910111213141516171819202122232425262728293031323334353637package com.xust.iot.configurer;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import java.util.List;@Configurationpublic class ApplicationMVCConfig extends WebMvcConfigurerAdapter &#123; //在这里可以配置拦截器，文件上传解析器，异常解析器....只要是在原本spring-mvc.xml文件中可以配置的在这里都可以配置 //视图映射 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //相当于&lt;mvc:view-controller path="/hello" view="success.html"/&gt; registry.addViewController("/hello").setViewName("success"); &#125; /** * 拦截器 拦截hello请求 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns("/hello"); &#125; //异常解析处理器 @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; exceptionResolvers) &#123; exceptionResolvers.add(new MyExceptionHandler()) ; &#125;&#125; &nbsp;&nbsp;全面接管Spring Boot对Spring MVC的自动配置&nbsp;&nbsp;&nbsp;&nbsp;官网中的一句话：”If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc.“意思就是我们可以配置类上加上EnableWebMvc来全面接管Spring MVC，这样一来Spring Boot就不会对Spring MVC进行配置了，一切都需要我们来配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.xust.iot.configurer;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.*;import org.springframework.web.servlet.view.InternalResourceViewResolver;@EnableWebMvc@Configurationpublic class ApplicationMVCConfig implements WebMvcConfigurer &#123; //在这里可以配置拦截器，文件上传解析器，异常解析器....只要是在原本spring-mvc.xml文件中可以配置的在这里都可以配置 //配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) &#123; InternalResourceViewResolver resourceViewResolver=new InternalResourceViewResolver(); resourceViewResolver.setPrefix("/**"); resourceViewResolver.setSuffix("/.html"); registry.viewResolver(resourceViewResolver); registry.order(10); &#125; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController("/hello").setViewName("success.html"); &#125; /** * 拦截器 拦截hello请求 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()).addPathPatterns("/hello"); &#125; &#125;]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot—Thymeleaf模板引擎]]></title>
    <url>%2F2019%2F08%2F28%2FSpring%20Boot%E2%80%94Thymeleaf%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; 引言&nbsp;&nbsp;&nbsp;&nbsp;在做WEB开发的时候，我们不可避免的要在前端页面之间进行跳转，中间进行数据的查询等等操作。我们在使用Spring Boot之前包括我在内其实大部分都是用的是JSP页面，可以说使用的已经很熟悉。但是我们在使用Spring Boot开发框架以后我们会发现一个致命的问题，就是SpringBoot对Jsp的支持可以说是惨不忍睹，因此官方推荐我们使用Thymeleaf模板引擎来解决问题。目前而言，当然模板引擎有很多，比如Velocity、Freemarker、等等，但是我这一直感觉thymeleaf相对于其他的来说好用的还是不少的。在这里我们就来了解一下thymeleaf这个模板引擎的用法！ &nbsp;&nbsp; 什么是模板引擎？&nbsp;&nbsp;&nbsp;&nbsp;模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档。用于网站的模板引擎（比如Thymeleaf模板引擎）就是将模板文件和数据通过模板引擎生成一个HTML代码。 简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。 &nbsp;&nbsp; Spring Boot中使用Thymeleaf模板引擎使用的方法很简单，首先在pom.xml文件中引入thymeleaf的starter 引入Thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 一般Spring Boot引入的都是依赖文件的最新的版本，如果发现不是最新的依赖版本或者你想更改依赖的版本，可以在&lt;properties&gt;标签中修改，比如修改thymeleaf的版本为3.0.10版本 123456&lt;properties&gt; &lt;!--切换thymeleaf版本--&gt; &lt;thymeleaf.version&gt;3.0.10.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 thymeleaf3主程序 layout2以上版本 --&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 使用Thymeleaf&nbsp;&nbsp;&nbsp;&nbsp;引入Thymeleaf的依赖后，我们就可以使用了。在学习Spring Boot时无论是啥新东西，我们都可以打开XxxxAutoConfigration和XxxxProperties，从中我们可以基本了解Spring Boot对这个东西的默认配置。好了我们来看看Thymeleaf的配置类 当然，我们也可以在Spring Boot的主配置文件中进行thymeleaf相关配置： 12345678#thymeleaf有关设置spring.thymeleaf.prefix=classpath:/templatesspring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTML5spring.thymeleaf.encoding=UTF-8spring.thymeleaf.servlet.content-type=text/html#关闭模板缓存，避免更新无效spring.thymeleaf.cache=false 尝试使用1.在控制层写一个跳转到hello.html页面的处理器方法 123456789101112131415161718package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Map;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String toHello(Model model)&#123; model.addAttribute("msg","Hello Thymeleaf!"); return "hello"; &#125;&#125; 2.在html页面中导入thymeleaf名称空间，名称空间的导入不是必须的，但是导入后可以有提示，提示还是挺好用的。 12&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; 3.然后在页面只用Thymeleaf语法获取服务器响应的数据hello.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--thymeleaf中的th:text 作用是将等号后面值写到标签体内，会覆盖原有的值--&gt;&lt;h1 th:text="$&#123;msg&#125;"&gt;这里显示欢迎信息&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp;&nbsp; Thymelaf模板引擎的基本语法常用th属性下面列举一些常用的th属性，全部的属性还请参考官方手册。th属性执行的优先级从1~8，数字越低优先级越高。 1、th:text：设置当前元素的文本内容，相同功能的还用th:utext,两者的区别是前者会转义特殊字符，后者不会。order=7 2、th:value：设置当前元素的value值，类似修改指定属性的还有th:src、th:herf,order=6 3、th:each：遍历循环元素，和th:value或th:value一起使用。order=2 4、th:if：条件判断，类似的还有th:unless 、th:switch、th:case 。order=3 5、th:insert：代码块引入，类似的还有th:replace、th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 6、th:fragment：定义代码块，方便被th:insert、th:replace、th:include引用。优先级最低：order=8 7、th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 8、th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5 Thymeleaf标准表达式语法 ${.....} 变量表达式（Variable Expressions） #{.....} 消息表达式（Message Expressions） @{.....} 链接表达式（Link URL Expressions） ~{.....} 代码块表达式（Fragment Expressions） *{.....} 选择变量表达式（Selection Variable Expressions） ${…}变量表达式Thymeleaf的变量表达式使用的其实是OGNL表达式，这使得变量表达式的功能非常丰富。 1、可以获取对象的属性、调用方法等(OGNL可以做的事他都可以做) 2、可以使用内置对象。官方手册上给的可以使用的内置对象如下： 12345678#ctx : the context object. 上下文对象#vars: the context variables. 上下文变量 #locale : the context locale. 本地区域信息//下面的内置对象下web环境下才有效果的#request : (only in Web Contexts) the HttpServletRequest object. request对象#response : (only in Web Contexts) the HttpServletResponse object. response对象 #session : (only in Web Contexts) the HttpSession object. session对象#servletContext : (only in Web Contexts)the ServletContext object. ServletContext对象 3、可以使用一些内置的工具对象(方法)。 123456789101112131415#execInfo : 正在处理的模板信息#messages : 获取外部信息的内部变量的一个实用方法，同时也可以用#&#123;...&#125;获取#uris : 针对URL或URI进行一些转码的方法#conversions : 根据配置执行一些转换方法#dates : java.util.Date 的对象#calendars : java.util.Calendar 的对象#numbers : 数值格式化方法#strings : 字符串格式化方法，常用的Java方法它都有#objects : java中Object类的一些方法#bools : 布尔方法，常用的方法有：isTrue，isFalse等#arrays : 数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等#lists ，#sets: 集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等#maps : map对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等#aggregates : 在数组或集合中创建聚合的一些实用方法.#ids : 用于处理可能重复的标识属性的使用方法，例如，作为迭代的变量。 *{…}选择表达式对于变量我们还可以使用*{...}来处理，它和${}在功能上是一样的。但是有一个重要的区别：*{}评估所选对象上的表达式而不是整个上下文。 也就是说，只要没有选定的对象，${}和*{}语法就会完全相同。下面是官网给的一个例子，可以说明这个问题： #{…}消息表达式用于处理国际化信息,下面是一个支持中英文的国际化登录页面 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="author" content=""&gt; &lt;title&gt;[[#&#123;login.topic&#125;]]&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link rel="shortcut icon" th:href="@&#123;/favicon.ico&#125;"/&gt; &lt;link rel="bookmark" th:href="@&#123;/favicon.ico&#125;"/&gt; &lt;link href="assert/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt; &lt;link th:href="@&#123;/webjars/jquery/3.3.1-1/jquery.js&#125;"&gt; &lt;link href="assert/css/signin.css" th:href="@&#123;/assert/css/signin.css&#125;" rel="stylesheet"&gt; &lt;/head&gt; &lt;body class="text-center"&gt; &lt;form class="form-signin" action="dashboard" th:action="@&#123;/checkLogin&#125;" method="post"&gt; &lt;img class="mb-4" th:src="@&#123;/assert/img/bootstrap-solid.svg&#125;" alt="" width="72" height="72"&gt; &lt;h1 class="h3 mb-3 font-weight-normal" th:text="#&#123;login.topic&#125;"&gt;Please sign in&lt;/h1&gt; &lt;p style="color: red" th:text="$&#123;msg&#125;" th:if="$&#123;not #strings.isEmpty(msg)&#125;"&gt;&lt;/p&gt; &lt;label class="sr-only" th:text="#&#123;login.username&#125;"&gt;Username&lt;/label&gt; &lt;input type="text" name="username" class="form-control" placeholder="Username" th:placeholder="#&#123;login.username&#125;" required="" autofocus=""&gt; &lt;label class="sr-only"&gt;Password&lt;/label&gt; &lt;input type="password" name="password" class="form-control" placeholder="Password" th:placeholder="#&#123;login.password&#125;" required=""&gt; &lt;div class="checkbox mb-3"&gt; &lt;label&gt; &lt;input type="checkbox" value="remember-me"/&gt; [[#&#123;login.remeberme&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#&#123;login.btn&#125;"&gt;Sign in&lt;/button&gt; &lt;p class="mt-5 mb-3 text-muted"&gt;© 2017-2018&lt;/p&gt; &lt;a class="btn btn-sm" th:href="@&#123;/index(locale=zh_CN)&#125;"&gt;中文&lt;/a&gt; &lt;a class="btn btn-sm" th:href="@&#123;/index(locale=en_US)&#125;"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 效果： @{…}链接表达式Thymeleaf中专门用于定义超链接的表达式。配合Thymeleaf中的th:href、th:src等凡是可以写链接、路径的标签一起使用(前缀th:)，下面是几个例子： 12345678910111213&lt;!--引入资源文件--&gt;&lt;link rel="shortcut icon" th:href="@&#123;/favicon.ico&#125;"/&gt;&lt;link rel="bookmark" th:href="@&#123;/favicon.ico&#125;"/&gt;&lt;link href="assert/css/bootstrap.min.css" th:href="@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;" rel="stylesheet"&gt;&lt;script type="text/javascript" src="assert/js/popper.min.js" th:src="@&#123;assert/js/popper.min.js&#125;"&gt;&lt;/script&gt;&lt;!--路径--&gt;&lt;a href="#" th:href="@&#123;/emp/&#125;+$&#123;emp.id&#125;" class="btn btn-sm btn-primary"&gt;编辑&lt;/a&gt;&lt;a href="/emp/del/" th:href="@&#123;/emp/del/&#125;+$&#123;emp.id&#125;" th:value="$&#123;emp.id&#125;" class="btn btn-sm btn-danger" &gt;删除&lt;/a&gt; &lt;!--表单--&gt;&lt;form action="/emp/save" th:action="@&#123;/emp/save&#125;" method="post" role="form"&gt; &lt;input type="hidden" name="id" th:value="$&#123;emp.getId()&#125;"/&gt; ~{…}代码块表达式Thymeleaf中专门用于引用代码片段的表达式。经常配合th:fragment和th:insert 、th:replace、th:include这四个属性使用（后三个属性中选一种，效果差不多，但是还是有细微的差别），例如： 12345678910&lt;!--使用th:fragement属性抽取公共页面：th:fragement="片段名"--&gt;&lt;nav class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0" th:fragment="topbar"&gt; &lt;a class="navbar-brand col-sm-3 col-md-2 mr-0 " style="align-content: center" href="#" th:href="@&#123;/main&#125;" &gt;[[$&#123;session.loggedUser&#125;]]&lt;/a&gt; &lt;input class="form-control form-control-dark w-100" type="text" placeholder="Search" th:placeholder="#&#123;main.search&#125;" aria-label="Search"&gt; &lt;ul class="navbar-nav px-3"&gt; &lt;li class="nav-item text-nowrap"&gt; &lt;a class="nav-link" href="#" th:href="@&#123;/signout&#125;" th:text="#&#123;main.logout&#125;"&gt;退出&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 在别的页面中就可以使用th:insert 、th:replace、th:include引入公共片段引入的就要用到~{} 表达式，具体的语法有两种： ~{templatename::selector}====&gt;模板名::选择器 ~{templatename::fragmentname}====&gt;模板名::片段名 其中模板名就是你引用的片段在templates/目录下的HTML文件名 12345678&lt;!--使用th:insert--&gt;&lt;div th:insert="~&#123;template :: topbar&#125;"&gt;&lt;/div&gt;&lt;!--使用th:replace--&gt;&lt;div th:replace="~&#123;template&#125; :: topbar"&gt;&lt;/div&gt;&lt;!--使用th:inclue--&gt;&lt;div th:include="~&#123;template :: topbar&#125;"&gt;&lt;/div&gt; 使用th:insert 、th:replace、th:include都可以引入公共的代码片段，但是他们有一点细微的差别th:insert：按上面的代码来说就是会在&lt;div&gt;&lt;/div&gt;内把整个公共片段插入，这样一来原有的片段就会被套在&lt;div&gt;&lt;/div&gt;内部th:replace：在声明使用的地方替换原有的标签为要引入的代码片段（就是把原生的代码片段发在要插入的地方）th:include：将被引入的片段的内容包含进这个标签中]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 对静态文件的默认映射规则]]></title>
    <url>%2F2019%2F08%2F28%2FSpringBoot%E6%98%A0%E5%B0%84%E6%98%A0%E5%B0%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[Webjars(官网：http://www.webjars.org/)​ webjars：以jar包的方式引入静态资源；Spring Boot中所有 /webjars/** ，都会去 classpath:/META-INF/resources/webjars/ 找资源。推荐使用Webjars的三大理由： 将静态资源版本化，更利于升级和维护。 剥离静态资源，提高编译速度和打包效率。 实现资源共享，有利于统一前端开发。 使用方法首先来看一下源码是如何以jar包的方式引入静态资源的： 1234567891011121314151617181920@Overridepublic void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler("/webjars/**") .addResourceLocations("classpath:/META-INF/resources/webjars/") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125;&#125; 原来是直接到jar包类路径/META-INF/resources/webjars/下来找静态资源的。使用方法很简单，只用引入Maven依赖就可以了。在Webjars官网找到需要的依赖，例如在pom.xml中引入jQuery和BootStrap 12345678910111213&lt;!--引入jquery--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-1&lt;/version&gt;&lt;/dependency&gt;&lt;!--引入BootStrap--&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;bootstrap&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; 引入之后我们可以尝试访问一下BootStrap里面的东西，在地址栏输入localhost/webjars/bootstrap/4.0.0/webjars-requirejs.js，如果能看到下面的页面那就没问题。 引入自己的静态资源文件自己的资源文件可以放在一下几个地方： 123456静态资源文件夹&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;, //系统默认生成的&quot;classpath:/public/&quot; &quot;/&quot;：当前项目的根路径下 WebMvcAutoConfiguration.java 123456789@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123; //设置欢迎页（首页）的构造方法中大有乾坤，我们可以点进去看看 WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors()); return welcomePageHandlerMapping;&#125; WelcomePageHandlerMapping.java 12345678910111213//WelcomePageHandlerMapping唯一的一个构造方法WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext, Optional&lt;Resource&gt; welcomePage, String staticPathPattern) &#123; if (welcomePage.isPresent() &amp;&amp; "/**".equals(staticPathPattern)) &#123; //检查发现欢迎页面存在兵并且在静态资源文件夹下，默认就会forward到index.html页面 logger.info("Adding welcome page: " + welcomePage.get()); setRootViewName("forward:index.html"); &#125;else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) &#123; //检查发现欢迎页面没有，那就设置欢迎页面的视图名是index logger.info("Adding welcome page template: index"); setRootViewName("index"); &#125;&#125; 简单分析源码可以知道，Spring Boot欢迎页面的处理机制是如果没有欢迎页面那就默认叫index.html，如果有并且在静态资源文件夹中，那就以forward的方式请求转发过去。根据上面的分析，设置首页就简单了，把首页起名为index.html，然后把它放在任何一个静态文件夹中就可以不被映射到，之后直接访问localhost:8080/就可以访问到首页把静态资源放在classpath:/public/ 来看看效果 给网页设置小图标先来看看源码是如何做的。 1234567@Beanpublic SimpleUrlHandlerMapping faviconHandlerMapping() &#123; SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping(); mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1); mapping.setUrlMap(Collections.singletonMap("**/favicon.ico", faviconRequestHandler())); return mapping;&#125; 从源码的倒数第二行可以看到，他会在映射到**/favicon.ico这个目录，那就简单了，我们只需要只需要将把我们的图标命名为favicon.ico，然后放在任一静态资源文件夹下即可。在classpath:/public/放一个我自己的图标 启动来看看效果： 很nice！我们的小图标被用上了。 使用spring.resources.static-locations改变静态资源文件夹在Spring Boot的主配置文件中，我们可以使用spring.resources.static-locations来指定静态资源文件的位置，可以指定多个，多个路径之间用”,”（逗号）隔开。需要注意的是，我们这么指定后，那些默认的资源文件夹就会失效。 123debug=trueserver.port=80spring.resources.static-locations=classpath:/webapps,classpath:/pages 在resources下新建webapps文件夹，把静态资源放在里面。 启动来看看效果：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot与日志]]></title>
    <url>%2F2019%2F08%2F27%2FSpringBoot%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; 日志框架分类目前，日志框架有很多，例如：JUL（java.util.logging）、JCL（Apache Jakarta Commons Logging）、Log4j、Log4j2、LogBack、SLF4J、jboss-logging等等。 日志门面日志实现 JCL（Apache Jakarta Commons Logging）SLF4J(Simple Logging Facade for Java)jboss-loggingLog4jJUL(java.util.logging)Log4j2Logback &nbsp;&nbsp;&nbsp;&nbsp;日志门面就是日志的抽象层，里面只是定义了日志的规范，日志实现就是来具体实现日志门面的。日志门面中这里重点来介绍一下SLF4J。 SLF4J&nbsp;&nbsp;&nbsp;&nbsp;slf4j是对所有日志框架制定的一种规范、标准、接口，并不是一个框架的具体的实现。因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）。 那么问题来了，我们有了日志的实现，为什么还需要日志门面（日志抽象层）？ &nbsp;&nbsp;&nbsp;&nbsp;我们都知道使用一个接口实际上使用的是这个接口的实现类，那好了，我只要在程序中使用接口中的API来操作日志，然后导入实现了这个日志接口的日志实现类，程序就可以正常的记录日志；下次我们导入了另一套基于这个接口实现的日志实现类，不用改我们在程序中写的任何日志代码程序还是可以正常的记录日志。原理很简单，日志实现类实现了日志接口的规范。因此这个问题的回答总结为一句话：使用日志框架接口更便于更换为其他的日志框架。 &nbsp;&nbsp;&nbsp;&nbsp;log4j、logback、log4j2都有SLF4J的具体实现，他们既可以单独使用，也可以结合SLF4J框架使用。 相关的Maven依赖写法： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Log4J&nbsp;&nbsp;&nbsp;&nbsp;log4j是apache实现的一个开源日志组件。通过使用log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。最令人感兴趣的就是，这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。然而log4j已经很多年没有更新过了，小项目可以使用，大项目还是算了吧。 相关的Maven依赖写法： 123456789101112&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; Logback&nbsp;&nbsp;&nbsp;&nbsp;logback同样是由log4j的作者设计完成的，拥有更好的特性，是用来取代log4j的一个日志框架，是slf4j的原生实现，所以logback与slf4j的结合最好。&nbsp;&nbsp;&nbsp;&nbsp;Logback，一个“可靠、通用、快速而又灵活的Java日志框架”。logback当前分成三个模块：logback-core，logback- classic和logback-access。logback-core是其它两个模块的基础模块。logback-classic是log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK Logging。logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。 因此在log4j和logback之间选择的话，我们应该选择更强大的logback。理由如下： 1. logback比log4j要快大约10倍，而且消耗更少的内存。 2. logback-classic模块直接实现了SLF4J的接口，所以我们迁移到logback几乎是零开销的。 3. logback不仅支持xml格式的配置文件，还支持groovy格式的配置文件。相比之下，Groovy风格的配置文件更加直观，简洁。 4. logback-classic能够检测到配置文件的更新，并且自动重新加载配置文件。 5. logback能够优雅的从I/O异常中恢复，从而我们不用重新启动应用程序来恢复logger。 6. logback能够根据配置文件中设置的上限值，自动删除旧的日志文件。 7. logback能够自动压缩日志文件。 8. logback能够在配置文件中加入条件判断（if-then-else)。可以避免不同的开发环境（dev、test、uat…）的配置文件的重复。 9. logback带来更多的filter。 10. logback的stack trace中会包含详细的包信息。 11. logback-access和Jetty、Tomcat集成提供了功能强大的HTTP-access日志。 相关的Maven依赖写法： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.1.11&lt;/version&gt;&lt;/dependency&gt; log4j2引用官网的一句话Apache Log4j 2 is an upgrade to Log4j that provides significant improvements over its predecessor, Log4j 1.x, and provides many of the improvements available in Logback while fixing some inherent problems in Logback’s architecture.翻译过来就是说：Apache Log4j 2是对Log4j的升级，它比其前身Log4j 1.x提供了重大改进，并提供了Logback中可用的许多改进，同时修复了Logback架构中的一些固有问题。Log4j2的特性： 1. 插件式结构。Log4j 2支持插件式结构。我们可以根据自己的需要自行扩展Log4j2. 我们可以实现自己的appender、logger、filter。 2. 配置文件优化。在配置文件中可以引用属性，还可以直接替代或传递到组件。而且支持json格式的配置文件。不像其他的日志框架，它在重新配置的时候不会丢失之前的日志文件。 3. Java 5的并发性。Log4j 2利用Java 5中的并发特性支持，尽可能地执行最低层次的加锁。解决了在log4j 1.x中存留的死锁的问题。 4. 异步logger。Log4j2是基于LMAX Disruptor库的。在多线程的场景下，和已有的日志框架相比，异步的logger拥有10倍左右的效率提升。 相关的Maven依赖写法： 123456789101112131415161718192021222324&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j2异步日志需要加载disruptor-3.0.0.jar或者更高的版本 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.lmax&lt;/groupId&gt; &lt;artifactId&gt;disruptor&lt;/artifactId&gt; &lt;version&gt;3.3.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--如果还要使用slf4j可以导入下面的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; &nbsp;&nbsp; 日志框架的使用SLF4J 什么时候使用SLF4J比较合适呢？ &nbsp;&nbsp;&nbsp;&nbsp;如果你开发的是类库或者嵌入式组件，那么就应该考虑采用SLF4J，因为不可能影响最终用户选择哪种日志系统。在另一方面，如果是一个简单或者独立的应用，确定只有一种日志系统，那么就没有使用SLF4J的必要。 如何在系统中使用SLF4J?(官网:https://www.slf4j.org/manual.html)下面是官网给的一个使用实例，以后如果要是用SLF4J,那就不要直接调用实现类的API，而是应该调用SLF4J里面的API，当然只是使用日志实现类另当别论！ 12345678910import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); //输出一个info级别的日志 logger.info("Hello World"); &#125;&#125; Log4J&nbsp;&nbsp;&nbsp;&nbsp;log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、数据库等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 &nbsp;&nbsp;&nbsp;&nbsp;Log4j有7种不同的log级别，按照等级从低到高依次为：TRACE、DEBUG、INFO、WARN、ERROR、FATAL、OFF。如果配置为OFF级别，表示关闭log。 Log4j支持两种格式的配置文件：properties和xml。包含三个主要的组件：Logger、appender、Layout。 一个简单的log4j配置文件 1234567891011121314151617181920212223242526272829303132333435### set log levels ### log4j.rootLogger = INFO , console , debug , error ### console ### log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n ### log file ### log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.File = xzy_mybatis.log log4j.appender.debug.Append = true log4j.appender.debug.Threshold = INFO log4j.appender.debug.layout = org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n ### exception ### log4j.appender.error = org.apache.log4j.DailyRollingFileAppender log4j.appender.error.File = xzy_mybatis.log log4j.appender.error.Append = true log4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayout log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n # LOG4J配置log4j.rootCategory=INFO,stdout,jdbc# 数据库输出log4j.appender.jdbc=org.apache.log4j.jdbc.JDBCAppenderlog4j.appender.jdbc.driver=com.mysql.jdbc.Driverlog4j.appender.jdbc.URL=jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=truelog4j.appender.jdbc.user=rootlog4j.appender.jdbc.password=rootlog4j.appender.jdbc.sql=insert into log_icecoldmonitor(level,category,thread,time,location,note) values('%p','%c','%t','%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;','%l','%m') 在Spring Boot中使用log4j&nbsp;&nbsp;&nbsp;&nbsp;首先创建一个Spring Boot工程，在创建Spring Boot工程时，我们引入了spring-boot-starter，其中包含了spring-boot-starter-logging，由于Spring Boot默认的日志框架是Logback，所以我们在引入log4j之前，需要先排除该包的依赖，再引入log4j的依赖。 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;&lt;/dependency&gt; 配置log4j-spring.properties &nbsp;&nbsp;&nbsp;&nbsp;配置文件的编写方法上面介绍的没有啥区别，但是配置文件的名字可以是log4j-spring.properties也可以是log4j.properties，但是Spring Boot官方推荐的命名方式是第一种方式。配置文件的内容参考上面。在Spring Boot主配置文件中指定日志文件的配置 1loggin.config=classpath:log4j-spring.properties Logback logblack的加载顺序SLF4J+Logback是Spring Boot默认的日志策略，logback支持xml和groovy形式的配置文件，而且还支持编程式地配置，它加载配置文件的顺序： 在 classpath 中寻找 logback-test.xml文件 如果找不到 logback-test.xml，则在 classpath 中寻找 logback.groovy 文件 如果找不到 logback.groovy，则在 classpath 中寻找 logback.xml文件 如果上述的文件都找不到，则 logback 会使用 JDK 的 SPI 机制查找 META-INF/services/ch.qos.logback.classic.spi.Configurator 中的 logback 配置实现类，这个实现类必须实现 Configuration 接口，使用它的实现来进行配置 如果上述操作都不成功，logback 就会使用它自带的 BasicConfigurator 来配置，并将日志输出到 console 在Spring Boot中使用LogBack(官网：https://logback.qos.ch/documentation.html)前面说过，logback是Spring Boot默认的日志系统，假如对日志没有特殊要求，可以完全零配置使用 SLF4J（Simple Logging Facade For Java）的logback来输出日志。LogBack的日志等级有ERROR、WARN、INFO、DEBUG、TRACE5级日志等级，等级由左至右等级又高到底。没有FATAL，他被分类到ERROR。 12345678910111213141516171819202122package com.jianeye.test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;SpringBootApplicationpublic class TestApplication &#123; private static Logger logger = LoggerFactory.getLogger(TestApplication.class); public static void main(String[] args) &#123; logger.warn("logback --------------------------------\n"); SpringApplication.run(TestApplication.class, args); logger.trace("trace log**********\n"); logger.info("default log**************\n"); logger.debug("dubug log***********\n"); logger.wran("warn log**********\n"); logger.error("error log*******\n"); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;上面这段程序，不经过任何配置，默认的日志系统是完全可以正常运行的。但是Spring Boot也支持我们修改默认配置，修改的方式有两种，一种是在src/main/resources下新建logback-spring.xml文件（logback.xml也可以，但官方推荐前面的写法）；第二种是直接在Spring Boot主配置文件中配置，下面是简单的配置示例：logbac-spring.xml 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;include resource="org/springframework/boot/logging/logback/base.xml" /&gt; &lt;logger name="org.springframework.web" level="INFO"/&gt; &lt;logger name="org.springboot.sample" level="TRACE" /&gt;&lt;/configuration&gt; application.properties 123456789101112131415161718192021222324252627debug=trueserver.port=80server.servlet.context-path=/book#指定配置文件的名字#logging.config.name=logback-spring.xml#配置文件的位置，#logging.config.location=classpath:logback-spring.xml#指定输出文件，当不指定路径时，默认将在当前项目路径下创建日志文件。#logging.file=logback-spring.log#也可以指定路径到硬盘的具体的某个路径，如果某及路径不存在就会创建logging.file=G://log/logback-spring.log#控制台输出的日期格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#日期输出格式logging.pattern.dateformat=HH:mm:ss.sss#指定输出到文件的日志格式logging.pattern.file=file-%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n#指定日志中日志级别输出的格式logging.pattern.level=custom-%5p#调整根目录级别的日志级别logging.level.root=WARN#调整特定文件的日志级别 logging.level.文件名=日志级别logging.level.com.xust=INFOlogging.level.org.springframework=DEBUG 扩展使用springProperty&nbsp;&nbsp;&nbsp;&nbsp;在logback-spring.xml中可以使用Spring Boot扩展的，使用它可以把在application.properties中定义的属性值映射为logback环境中的一个属性，从而可以在logback的上下文使用。 1234567891011&lt;springProfile name="staging"&gt; &lt;!-- configuration to be enabled when the "staging" profile is active --&gt; &lt;!--可以指定某段配置只在某个环境下生效--&gt;&lt;/springProfile&gt;&lt;springProfile name="dev | staging"&gt; &lt;!-- configuration to be enabled when the "dev" or "staging" profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name="!production"&gt; &lt;!-- configuration to be enabled when the "production" profile is not active --&gt;&lt;/springProfile&gt; 举个例子：&nbsp;&nbsp;&nbsp;&nbsp;下面的配置中定义了属性appName对应于Spring Boot的Environment中的app.name（由source属性指定），当未指定时默认使用defaultValue属性指定的TEST；属性name对应于Spring Boot的Environment中的logging.path，未指定时使用/logs/${appName}.log，其中的${appName}又对应于变量appName的值。定义好的变量可以在logback的配置文件中以${varName}的形式进行引用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748logback-spring.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;include resource="org/springframework/boot/logging/logback/base.xml" /&gt; &lt;logger name="org.springframework.web" level="INFO"/&gt; &lt;logger name="org.springboot.sample" level="TRACE" /&gt; &lt;springProfile name="dev"&gt; &lt;logger name="org.springboot.sample" level="DEBUG" /&gt; &lt;/springProfile&gt; &lt;springProfile name="staging"&gt; &lt;logger name="org.springboot.sample" level="INFO" /&gt; &lt;/springProfile&gt; &lt;!-- %d ：表示日期时间 %thread ：表示线程名 %-5level ：级别从左显示5个字符宽度，- 表示左对齐 %logger&#123;50&#125; ：表示 logger 名字最长为50个字符，否则按照句号分割 %msg ：表示日志消息 %n ：表示换行--&gt; &lt;springProfile&gt; &lt;appender name="stdOut" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;dev&#125;-%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="fileOut" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;file&gt;$&#123;logPath&#125;&lt;/file&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;logPath&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; -%msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--log root的日志级别--&gt; &lt;root level="info"&gt; &lt;appender-ref ref="stdOut" /&gt; &lt;appender-ref ref="fileOut" /&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; &nbsp;&nbsp; 多个不同的日志框架兼容SLF4J&nbsp;&nbsp;&nbsp;&nbsp;经常在实际的开发环境中，我们会使用到不同的框架，而且不同的框架默认的日志系统不同，那么如何在Spring Boot中设置一下，让这些不同框架的默认日志系统可以借助于Spring Boot的默认日志系统来工作？这是可以办到的,具体的步骤如下：1、在pom.xml文件中导入依赖的时候排除所使用框架对默认日志系统的依赖2、用SLF4J提供的中间包替换原有日志框架下图有详细的配置方法：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot自动配置原理（深入源码）]]></title>
    <url>%2F2019%2F08%2F26%2FSpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp; 引言&nbsp;&nbsp;&nbsp;&nbsp;不论在工作中，亦或是求职面试，Spring Boot已经成为我们必知必会的技能项。除了某些老旧的政府项目或金融项目持有观望态度外，如今的各行各业都在飞速的拥抱这个已经不是很新的Spring启动框架。 &nbsp;&nbsp;&nbsp;&nbsp;当然，作为Spring Boot的精髓，自动配置原理的工作过程往往只有在“面试”的时候才能用得上，但是如果在工作中你能够深入的理解Spring Boot的自动配置原理，将无往不利。 &nbsp;&nbsp;&nbsp;&nbsp;Spring Boot的出现，得益于“习惯优于配置”的理念，没有繁琐的配置、难以集成的内容（大多数流行第三方技术都被集成），这是基于Spring 4.x提供的按条件配置Bean的能力。 &nbsp;&nbsp; Spring Boot自动配置原理配置文件到底能写什么？怎么写？自动配置原理？&nbsp;&nbsp;&nbsp;&nbsp;我们一接触Spring Boot的时候就了解到：Spring Boot有一个全局配置文件application.properties或application.yml。我们的各种属性都可以在这个文件中进行配置，最常配置的比如：server.port、logging.level.* 等等，然而我们实际用到的往往只是很少的一部分，而且可以在主配置文件中配置的属性都可以在官方文档中查找到：https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#common-application-properties @EnableAutoConfiguration&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot在从启动类启动，启动类上有@SpringBootApplication注解，这个注解是Spring Boot的核心注解，那么自动配置原理一定和这个注解有着千丝万缕的联系！ 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; //省略&#125; &nbsp;&nbsp;&nbsp;&nbsp;点开@SpringBootApplication源码，这里面最重要的就是@SpringBootConfiguration和@EnableAutoConfiguration，前者是Spring Boot的配置注解，底层使用的是@Configuration这个注解，后者翻译他的名字就知道这是开启自动配置，它是Spring Boot自动配置的核心。于是，让我们点进去看看里面的乾坤。 12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; /** * Exclude specific auto-configuration classes such that they will never be applied. * @return the classes to exclude */ Class&lt;?&gt;[] exclude() default &#123;&#125;; /** * Exclude specific auto-configuration class names such that they will never be * applied. * @return the class names to exclude * @since 1.3.0 */ String[] excludeName() default &#123;&#125;;&#125; &nbsp;&nbsp;&nbsp;&nbsp;可以看到，EnableAutoConfiguration注解内部的代码那是非常的简单，但是@Import(AutoConfigurationImportSelector.class)这个注解引起了我的好奇，@Import这个注解我们都不陌生，他的作用无外乎这几种：@Configuration注解的配置类、声明@Bean注解的bean方法、导入ImportSelector的实现类或导入ImportBeanDefinitionRegistrar的实现类。按照他的写法，他是导入了ImportSelector的实现类AutoConfigurationImportSelector。它的核心方法就是 selectImports(..)，它表明哪些自动配置类是要加入到容器中，在Spring Boot 2.1.7.RELEASE版本中得源码如下： 1234567891011@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader); AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125; 继续追踪源码，可以看到getAutoConfigurationEntry（..)这个方法，其中configurations存放的数据就是加入容器的自动配置类的完整包路径 12345678910111213141516171819protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); //扫描具有META-INF/spring.factories文件的jar包 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //去掉重复的配置 configurations = removeDuplicates(configurations); //删除需要排除的类 Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125; 而从getCandidateConfigurations(..)中，我们发现他调用SpringFactoriesLoader.loadFactoryNames产生了一个List，返回的东西是啥呢？继续往下看 1234567protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct."); return configurations;&#125; 我们继续往下看，发现他确实最终在loadFactories方法中使用本类的一个私有静态方法loadSpringFactories加载了META-INF/spring.factories这个配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class SpringFactoriesLoader &#123; /** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */ public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"; public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList()); &#125; private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap&lt;String, String&gt; result = cache.get(classLoader); if (result != null) &#123; return result; &#125; try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); result = new LinkedMultiValueMap&lt;&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryClassName = ((String) entry.getKey()).trim(); for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123; result.add(factoryClassName, factoryName.trim()); &#125; &#125; &#125; cache.put(classLoader, result); return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException("Unable to load factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex); &#125; &#125;&#125; 查看spring-boot-autoconfigure包下META-INF/spring.factories： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384......# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration...... 看到的非常多的xxxxAutoConfiguration类，这些类都是容器中的一个组件，加入到容器中，用他们做自动配置。 总结—Spring Boot自动配置的精髓&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot启动的时候会加载大量的自动配置类xxxxAutoConfiguration（就如在spring.factories那些类），当我们需要的功能在Spring Boot中恰好有默认的自动配置类，那么这个自动配置类在Spring Boot中一定有一个对应的XxxPropertoes类（相当于对应自动配置类的配置文件），这个类中有很多的属性，我们可以使用人家Spring Boot默认的属性值，但是当这些默认值无法满足我们的需求的时候，我们也可以在主配置文件中来使用XxxPropertoes类中的属性来配置我们需求的值。 &nbsp;&nbsp; @Conditional派生注解然而，虽然Spring Boot在启动的时候加载了全部的自动配置类，但是不是所用的这些类都是可以使用的，只有符合条件的自动配置类才可以使用，用于判断的就是这些@ConditionalXxx注解 @Conditional扩展注解作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication当前是web环境 @ConditionalOnNotWebApplication当前不是web环境 @ConditionalOnJndiJNDI存在指定项 问：如何知道哪些自动配置类生效了，哪些配置类没有生效？我们可以通过在主配置文件中配置 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效。如下：]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot配置文件详解]]></title>
    <url>%2F2019%2F08%2F25%2FSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Spring Boot配置文件&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot支持两种形式的配置文件，分别是.properties、和.yml，而且配置文件的名字是固定不可变的： application.properties application.yml &nbsp;&nbsp;&nbsp;&nbsp;配置文件的作用是修改Spring Boot自动配置的默认值。相对于properties文件而言，yml文件更年轻。当application.properties文件和application.yml同时存在的时候，application.properties会优先加载，application.yml则后加载，而且在applicatin.properties中已经加载的属性如果在application.yml中再次出现会被忽略，如果是application.yml中的独有的属性则会加载。这里面有很多的坑。下面我们就来一起学习一下吧。 YAML/YML文件简介什么是YAML/YML文件？&nbsp;&nbsp;&nbsp;&nbsp;YAML是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递回缩写。YAML 是一个可读性高，用来表达资料序列的编程语言。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YAML以数据为中心，比json、xml等更适合做配置文件。 YAML/YML的基本语法 基本语法：key: value，key: 和value中间要有一个空格,而且key: value的形式可以写无限层。还有一下规则：1.大小写敏感2.使用缩进表示层级关系3.缩进时不允许使用Tab键，只允许使用空格。4.缩进的空格数目不重要，只要相同层级的元素左侧对齐即可5.只有一种注释方式，使用# YAML/YML支持的数据结构YML支持3中类型的数据结构类型 1.字面量2.对象（属性和值），Map（键值对）3.数组（List、Set） 1、字面量具体包括：字符串、布尔值、整数、浮点数、Null、时间、日期字面量可以直接使用，但是特别注意字符串的字面量在写的时候是不需要引号的（无论单引号还是双引号）。单/双引号在yml语法中有特殊的含义：​ “”：双引号；会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思​ name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi ​ ”：单引号；不会转义特殊字符，特殊字符最终只是一个普通的字符串数据name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 2.对象（属性和值），Map（键值对）基本的语法还是key：value，以一个例子来说明： 123friends: lastName: zhangsan age: 20 对应的行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 3.数组（List、Set）用- 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 举个栗子：配置一个Person的信息 123456789101112131415161718192021222324package com.xust.iot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import java.util.List;import java.util.Map;/** * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * 但是要特别注意:只有这个组件是容器中的组件，容器才能提供@ConfigurationProperties的功能； */@Component@ConfigurationProperties(prefix="person")public class Person &#123; private String name; private Integer age; private Address address; private Map&lt;String,Object&gt; map; private List&lt;String&gt; list; //省略getter setter和toStrig方法 123456789101112package com.xust.iot.bean;public class Address &#123; private String province; private String city; private String county; private String street; //省略getter setter和toStrig方法&#125; 我们可以导入配置文件处理器，编写配置的时候就有提示了 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 在application.yml配置文件中配置preson信息： 12345678910111213141516#写yml配置的时候要特别注意key和value之间要有一个空格，同级属性左对齐person: name: 李四 age: 20 map: key1: value1 key2: value2 list: - hello - hi - bye address: province: 陕西 city: 西安 county: xx street: xx 在SpringBoot测试类中测试IOC是否可以拿到在配置文件中配置的信息 12345678910111213141516171819202122package com.xust.iot;import com.xust.iot.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootConfigApplicationTests &#123; @Autowired Person person; @Test public void contextLoads() &#123; System.out.println(person); &#125;&#125; 测试结果： properties文件简介&nbsp;&nbsp;&nbsp;&nbsp;properties文件大家经常用，这里就简单介绍一下。其语法结构形如：key=value。注意中文乱码问题，需要转码成ASCII。在IDEA中可以设置自动转换把uft-8格式自动转成ASCII，设置方式是：依次点击【File】=&gt;【Other Settings】=&gt;【settigs for new projects】，搜索File Encodings，然后做如下配置： 上面Person信息的properties配置如下： 123456789person.name=小明person.age=20person.address.province=陕西person.address.city=西安person.address.county=xxperson.address.street=xxperson.map.key1=value1person.map.key2=value2person.list=hello,hi,bye 配置文件值注入@Value获取值和@ConfigurationProperties获取值比较&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot通过ConfigurationProperties注解从配置文件中获取属性。从上面的例子可以看出ConfigurationProperties注解可以通过设置prefix指定需要批量导入的数据。支持获取字面值，集合，Map，对象等复杂数据。ConfigurationProperties注解还有其他特么呢？它和Spring的Value注解又有什么区别呢？带着这些问题，我们继续往下看。 比较@ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 何时使用@Value何时使用@ConfigrationProperties？ 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value。 如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties。 配置文件注入值数据校验使用@Vaildatad可以给配置的属性数据校验功能。可以用在类、方法、参数上。可以加的验证注解如下： 12345678910111213141516@Null //限制只能为null@NotNull //限制必须不为null@AssertFalse //限制必须为false@AssertTrue //限制必须为true@DecimalMax(value) //限制必须为一个不大于指定值的数字@DecimalMin(value) //限制必须为一个不小于指定值的数字@Digits(integer,fraction) //限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction@Future //限制必须是一个将来的日期@Max(value) //限制必须为一个不大于指定值的数字@Min(value) //限制必须为一个不小于指定值的数字@Past //验证注解的元素值（日期类型）比当前时间早@Pattern(value) //限制必须符合指定的正则表达式@Size(max,min) //限制字符长度必须在min到max之间@NotEmpty //验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）@NotBlank //验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank //只应用于字符串且在比较时会去除字符串的空格@Email //验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式 下面举个例子： 1234567891011121314151617181920212223242526272829@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @NotEmpty @Size(max = 5, min = 2) private String name; @Max(70) @Min(10) private Integer age; @Past private Date birth; @NotEmpty private Address address; @NotEmpty private Map&lt;String, Object&gt; map; @NotEmpty private List&lt;String&gt; list; //省略getter setter和toStrig方法 &#125; @PropertySource&amp;@ImportResource&amp;@Bean @PropertySource：加载指定的配置文件； person.properties 12345678910person.name=小明person.age=20person.address.province=陕西person.address.city=西安person.address.county=xxperson.address.street=xxperson.map.key1=value1person.map.key2=value2person.list=hello,hi,byeperson.birth=2019/04/5 123456789101112131415161718192021222324252627282930313233343536373839404142package com.xust.iot.bean;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.stereotype.Component;import org.springframework.validation.annotation.Validated;import javax.validation.constraints.*;import java.util.Date;import java.util.List;import java.util.Map;//使用PropertySource注解指定配置文件的路径，SpringBoot就会在启动的时候加载，然后把配置中的值赋给这个配置类的对应属性。@PropertySource(value = &#123;"classpath:personInfo.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123; @NotEmpty @Size(max = 5, min = 2) private String name; @Max(70) @Min(10) private Integer age; @Past private Date birth; private Address address; @NotEmpty private Map&lt;String, Object&gt; map; @NotEmpty private List&lt;String&gt; list; //省略getter setter和toStrig方法&#125; @ImportResource：导入Spring的配置文件，让配置文件里面的内容生效； 在src/main/resources下新建一个Spring配置文件applicationContext.xml 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="address" class="com.xust.iot.bean.Address"&gt; &lt;property name="province" value="陕西"/&gt; &lt;property name="city" value="汉中"/&gt; &lt;property name="county" value="xxx"/&gt; &lt;property name="street" value="xxx"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在Spring Boot的主程序类中使用@ImportResource引入配置这个配置文件 然后在测试类中自动注入ApplicationContext来拿这个组件 1234567891011121314151617181920212223242526package com.xust.iot;import com.xust.iot.bean.Person;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.context.ApplicationContext;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootConfigApplicationTests &#123; @Autowired ApplicationContext ioc; @Test public void contextLoads() &#123; System.out.println(ioc.containsBean("address")); System.out.println(ioc.getBean("address").toString()); &#125;&#125; 测试结果： 虽然这种方式可以用，但是一般我们不这么用，而且Spring Boot也不推荐这么使用，Spring Boot推荐使用全注解的方式来添加配置文件。 1、配置类@Configuration——&gt;Spring配置文件 2、使用@Bean给容器中添加组件 接下类，我们在com.xust.iot基包下新建配置类ApplicationConfig.java 123456789101112131415161718192021222324package com.xust.iot;import com.xust.iot.bean.Address;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;//使用@Configuration告诉Spring这是配置@Configurationpublic class ApplicationConfig &#123; //@Bean注解相当于&lt;bean&gt;&lt;/bean&gt;标签,特别注意：方法名就是bean的id @Bean public Address address()&#123; System.out.println("在配置类中使用@Bean注解添加了组件"); Address address=new Address(); address.setProvince("陕西省"); address.setCity("西安"); address.setCounty("xxx"); address.setStreet("xxx"); return address; &#125;&#125; 运行后得到的效果一样： 配置文件占位符在application.properties和application.yml文件可以使用${random}来设置随机值 常用随机设值如下1234567$&#123;random.value&#125; //随机生成一个32位的字符串，如：b21d56d2f10d74f84608dfff01b25552$&#123;random.int&#125; //随机生成一个int范围的随机数$&#123;random.long&#125; //随机生成一个int范围的随机数$&#123;random.int(10)&#125; //随机生一个[0,10]之间的随机数$&#123;random.int[1024,65536]&#125; //随机生成一个[1024,65536]之间的随机数$&#123;对象.属性&#125; //使用某个已配置的属性的值$&#123;对象.属性:默认值&#125; //使用某个已配置的属性的值，如果没有就是用默认值 在application.yml文件中写如下配置： 12345678910111213141516person: name: 李四$&#123;random.uuid&#125; age: $&#123;random.int(45,70)&#125; birth: 2019/08/24 map: key1: 232424@qq.com key2: dad323@163.com list: - hello - hi - bye address: province: 陕西 city: 西安 county: $&#123;person.name&#125; street: $&#123;person.address.province&#125;-$&#123;person.address.city&#125; 在测试类中打印person的信息，结果如下： Spring Boot profile&nbsp;&nbsp;&nbsp;&nbsp;Spring支持对不同环境，提供不同配置，可以通过激活、指定参数等方式快速的切换环境 。环境profile可以是开发环境（develop）、测试环境（fuy）、生产环境（production）等 配置多个profile在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 下面分别编写application-develop.properties和application-production.propertiesapplication-develop.properties 123debug=trueserver.port=8081server.servlet.acontext-path=/book application-production.properties 123debug=falseserver.port=80server.servlet.context-path=/book 目录结构： 在主配置文件application.properties中，使用spring.profiles.active=[profile]来激活不同的环境，如下激活develop环境： 启动Spring Boot观察Tomcat启动的端口 激活生产环境：spring.profiles.active=production 可以看到，配置的不同环境被激活后都起作用了。这在以后的开发中无疑是个十分强大而且方便的功能。 YML配置多个profile然而使用properties文件配置不同环境还是太麻烦了，YML对多profile的支持更加简单粗暴，配置示例： 123456789101112131415161718192021222324server: port: 8083spring: profiles: active: production #激活生产环境---#开发环境server: port: 8083 servlet: context-path: /bootdebug: truespring: profiles: develop #使用spring.profiles来指定这个环境名--- #使用连续的三个横线分隔不同的profile(文档区)#生产环境server: port: 80 servlet: context-path: /bootdebug: truespring: profiles: production 注意：Spring Boot启动的时候会优先加载.properties的文件，然后才来加载.yml文件，如果要想使applicaton.yml中配置的信息可以使用，那么.properties中不能有和.yml相同的配置。 总结激活指定profile的不同方式1、在配置文件中指定 spring.profiles.active=dev，上面的配置方式就是这种。 ​ 2、命令行：可以在IDEA中配置 –spring.profiles.active=develop 来启动开发环境，操作如下： 也可以在命令行中使用java -jar spring_boot_config-0.0.1-SNAPSHOT.jar --spring.profiles.active=develop来启动开发环境 3、虚拟机参数： 可以在IDEA中做如下配置：-Dspring.profiles.active=dev，示例如下： 配置文件的加载位置springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 这些位置的配置文件加载的优先级由高到底，而且高优先级的配置如果在低优先即中出现，那么低优先优先级中重复配置不会生效。但是低优先级中独有的配置还是会生效。也就是说SpringBoot会从这四个位置全部加载主配置文件；并且会互补配置； ==我们还可以通过spring.config.location来改变默认的配置文件位置== 比如：项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；首先在硬盘的另一个地方(我这里在E://)创建application.properties。添加如下配置： 123debug=falseserver.port=8087server.servlet.context-path=/book 然后可以在命令行输入java -jar spring_boot_config-0.0.1-SNAPSHOT.jar --spring.config.location=E://application.properties 外部配置加载顺序SpringBoot也可以从以下位置加载配置，加载顺序的优先级从高到低；高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置。 1.命令行参数 所有的配置都可以在命令行上进行指定 java -jar spring_boot_config-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开；--配置项=值 2.来自java:comp/env的JNDI属性 3.Java系统属性（System.getProperties()） 4.操作系统环境变量 5.RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 优先加载带profile的配置文件 6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 再来加载不带profile的配置文件 8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件 9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件 10.@Configuration注解类上的@PropertySource 11.通过SpringApplication.setDefaultProperties指定的默认属性 所有支持的配置加载来源参考官方文档。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot快速入门]]></title>
    <url>%2F2019%2F08%2F24%2FSpringBoot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[SpringBoot 2.x 中文文档 入门环境准备&nbsp;&nbsp;&nbsp;&nbsp;在本地安装3.3版本以上的Maven，以及JDK1.7以上的java环境，然后在IDEA【settings】=&gt;【File | Settings | Build, Execution, Deployment】=&gt;【Maven】，设置如下内容： 创建SpringBoot HelloWord&nbsp;&nbsp;&nbsp;&nbsp;第一个程序我们先创建一个Maven工程。&nbsp;&nbsp;&nbsp;&nbsp;创建好Maven项目后，首先导入Spring Boot的依赖包，依赖可以在Spring Boot的官网：https://docs.spring.io/spring-boot/docs/1.5.22.RELEASE/reference/html/getting-started-installing-spring-boot.html#getting-started-maven-installation找到。 123456789101112131415161718192021222324&lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.22.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!--这个插件可以把我们的应用打包成一个可以运行的jar包，后面有详细的说明--&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 注意：&nbsp;&nbsp;&nbsp;&nbsp;1.spring-boot-starter-parent的父项目是spring-boot-dependencies（Spring Boot的版本仲裁中心），他的作用是用来管理Spring Boot应用里面的所有依赖版本&nbsp;&nbsp;&nbsp;&nbsp;2.spring-boot-starter-web：spring-boot-starter我们称作spring-boot场景启动器，Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来（要用什么功能就导入什么场景的启动器）。spring-boot-starter-web的作用是帮我们导入了web模块正常运行所依赖的组件； 完成上面的操作后，在src/main/java下新建一个主程序类Application.java类 1234567891011121314package com.xust.iot;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 使用@SpringBootApplication 来标注主程序 */@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 注意：&nbsp;&nbsp;&nbsp;&nbsp;1、主程序类必须位于项目基包的根目录（具体原因下面会说），而且要使用@SpringBootApplication来告诉Spring Boot这是一个主程序类（配置类），这么标注后Spring Boot就会从这个类的main方法启动并加载配置。&nbsp;&nbsp;&nbsp;&nbsp;2、@SpringBootApplication是基于Spring Boot基本注解的一个复合注解，源码片段如下： 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;...... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1、@SpringBootConfiguration：标注在某个类上，表示这是一个Spring Boot的配置类；底层实际还是使用的是Spring的底层注解@Configuration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2、@ComponnetScan：标注在类上，就是我们熟悉的包扫描&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3、@EnableAutoConfiguration：开启自动配置功能；以前我们需要配置的文件，在类上写上这个注解，Spring Boot帮我们自动配置。@EnableAutoConfiguration的源码片段如下： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1、@AutoConfigurationPackage：自动配置包&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2、@Import(AutoConfigurationImportSelector.class)：借助AutoConfigurationImportSelector这个类@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们； 然后在src/main/java包下新建controller包，在这个包下新建HelloWordController.java 123456789101112131415package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWordController &#123; @ResponseBody @RequestMapping("/hello") public String hello()&#123; return "Hello word,hello Spring Boot!"; &#125;&#125; 这样一个简单的SpringBoot程序就写好了，在主程序类中点击运行按钮启动它。下面是运行后的结果： 运行结果说明：启动后我们访问http://localhost:8080，回车后就会出现Whitelable Error Page提示，这是Spring Boot默认的错误页面，由于我们没有指定初始页面，出错很正常，之后在地址栏中请求hello，就可以看到我们写的Hello word,hello Spring Boot! 部署应用&nbsp;&nbsp;&nbsp;&nbsp;部署应用需要spring-boot-maven-plugin这个插件（在上面有），在POM文件中导入后，我们在IDEA有侧边栏点击【Maven】=&gt;【项目名】=&gt;【Lifecycle】=&gt;【package】，双击package就会运行插件就可以我们的应用打包成一个可运行的jar包。打包后我们在target目录下可以找到他，然后复制在里一个目录中在命令行中cd到这个目录，执行java -jar jar包名这个命令可以执行打包后的应用。下面是执行后命令行的打印： 使用Spring Initializer快速创建Spring Boot项目在IDEA依次点击【New】=&gt;【Project】然后选择Spring Initializr 填写Group和Arifact,在填写Arifact时要注意不要出现大写字母 选择需要的模块 生成的Spring Boot项目 在默认生成的Spring Boot项目中 主程序类已经生成好了，我们只需要我们实现业务逻辑 resources文件夹中目录结构 static：保存所有的静态资源，如： js css images； templates：保存所有的模板页面，Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置。这个文件也支持YML(YML)格式的文件，用YAML(YML)格式配置的文件结构更加简洁，清晰。]]></content>
      <categories>
        <category>Spring Boot框架</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架整合（Spring+Spring MVC +MyBatis）]]></title>
    <url>%2F2019%2F08%2F22%2FSSM%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Spring是一个非常流行的轻量级框架，他是为了解决企业应用开发的复杂性而创建的，现在已经被广泛应用在各个领域。MyBatis的前身iBatis也是一个非常流行的ORM框架，因此在在iBatis时期，Spring官方便提供了对iBatis的支持。但是在MyBatis时期，Spring 3.0在MyBatis 3.0官方发布前就已经结束了，因为Spring开发团队不想发布一个基于非发布版MyBatis的整合支持，因此MyBatis不得不继续等待Spring官方的支持。&nbsp;&nbsp;&nbsp;&nbsp;因此现在我们要整合他们要获得MyBatis的一个子项目MyBatis-Spring来支持，MyBatis-Spring可以帮我们将MyBatis代码无缝整合到Spring中。使用这个类库的类，Spring将会加载必要的MyBatis工厂类和Session类。这个类库也提供了一个简单的方式将MyBatis数据映射器和SqlSession注入到业务层的bean中，而且还可以处理事务、翻译MyBatis的异常到Spring的DataAccessException数据访问异常中。&nbsp;&nbsp;&nbsp;&nbsp;MyBatis-Spring项目的地址：https://github.com//mybatis/spring。&nbsp;&nbsp;&nbsp;&nbsp;接下来我们来一步步把他们整合在一起。 创建基本的Maven Web项目在IDEA中创建一个基本的Maven项目。具体过程不是这里的重点，如有有不清楚，请自行百度或Google~。创建好项目后，在pom.xml文件中配置依赖（导包） 在pom.xml文件中添加依赖详细的依赖配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.1.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Spring Start：也不全是Spring的依赖，还包括Spirng能够正常运行的一些支持性的包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring上下文核心依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--上下文支持包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring面向切面编程--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime外部依赖包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--字节码增强--&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring JDBC--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring事物管理--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 对象关系映射--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring web模块核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring MVC模块--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Servlet原生API--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!--支持JSP--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--JSTL用于在控制器中将模型绑定到JSP中--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;!--文件上传，依赖commons-io--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!--增强版的java IO--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--json数据绑定--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--json注解--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt;&lt;!--json核心--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring End=--&gt;&lt;!--MyBatis Start--&gt;&lt;!--mybatis核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis与Spring整合的核心包：配置这个包的时候一定要注意你的MyBatis版本和Spring版本和这个包是否兼容--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--Jdbc数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--Druid数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!--MyBatis通用分页插件pageHelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页插件依赖的包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!--======MyBatis End=======--&gt;&lt;!--日志记录--&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; &nbsp;&nbsp;&nbsp;&nbsp;配置的时候要特别注意mybatis-spring这个包的版本和你使用的MyBatis以及Spring版本是否兼容，特别适当发生java.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()错误的时候，还就更要怀疑是这个问题了： 12345678910111213141516171819202122232425262728293021-Aug-2019 23:47:32.939 涓ラ噸 [http-nio-80-exec-5] org.apache.catalina.core.StandardWrapperValve.invoke Servlet.service() for servlet [DispatcherServlet] in context with path [/ssm_merge_war_exploded] threw exception [Handler dispatch failed; nested exception is java.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()Ljava/lang/Integer;] with root causejava.lang.AbstractMethodError: org.mybatis.spring.transaction.SpringManagedTransaction.getTimeout()Ljava/lang/Integer; at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:86) at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:49) at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117) at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:76) at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:197) at org.apache.ibatis.session.defaults.DefaultSqlSession.insert(DefaultSqlSession.java:184) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:408) at com.sun.proxy.$Proxy17.insert(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.insert(SqlSessionTemplate.java:254) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:62) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:57) at com.sun.proxy.$Proxy18.addAccount(Unknown Source) at com.xust.iot.service.AccountService.addAccount(AccountService.java:20) at com.xust.iot.service.AccountService$$FastClassBySpringCGLIB$$b6e17b84.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:294) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.xust.iot.service.AccountService$$EnhancerBySpringCGLIB$$a5f30121.addAccount(&lt;generated&gt;) 适配的环境：mybatis-spring对JDK、mybatis、spring都有要求 配置环境&nbsp;&nbsp;&nbsp;&nbsp;配置文件的编写是SSM整合的关键，需要配置的东西主要有web.xml、Sprng配置文件applicationContext.xml、Spring MVC配置文件applicationContext-mvc.xml、MyBatis全局配置文件MyBatis-config.xml以及后面的Mapper映射文件的编写。 1.配置web.xml文件web.xml文件的基本配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;index&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--启动Spring容器--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLoaction&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--用于在Web容器启动的时候根据contextConfigLoaction配置的路径读取Spring配置文件，然后启动Spring--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:Spring/applicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--配置字符编码过滤器,注意：字符编码过滤器应该配置在所有过滤器之前--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置Restful过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 2.配置MyBatis-config.xml全局配置文件&nbsp;&nbsp;&nbsp;&nbsp;在MyBatis的全局配置文件中配置一些基本对settings,环境就不要在这里配置了，交给Spring管理就好了（本身MyBatis这个配置文件都是可有可无的，但是用它来写一个settings配置可以使结构清晰，方便修改）。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--一些有关于mybatis运行时行为的设置--&gt; &lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--开启懒加载--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!--aggressvieLazyLoading当这个参数为true的时候，对任意延迟属性都会完全的加载，当为false时会按需加载--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;!--开启自动映射--&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;!--开启驼峰--&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name="com.xust.iot.bean"/&gt; &lt;/typeAliases&gt; &lt;!--配置分页插件--&gt; &lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt;&lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 3.配置applicationContext-mvc.xml文件123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package="com.xust.iot" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt; &lt;/context:component-scan&gt; &lt;!--开启扫描静态--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--开启扫动态--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!--配置文件上传解析器--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSizePerFile" value="#&#123;1024*1024*5&#125;"/&gt; &lt;property name="maxUploadSize" value="#&#123;1024*1024*100&#125;"/&gt; &lt;property name="defaultEncoding" value="utf-8"/&gt; &lt;/bean&gt;&lt;/beans&gt; 4.配置applicationContext.xml文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--注解扫描--&gt; &lt;context:component-scan base-package="com.xust.iot"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt; &lt;/context:component-scan&gt; &lt;!--引入外部配置文件--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!--配置数据源--&gt; &lt;bean id="DruidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;"/&gt; &lt;property name="minIdle" value="$&#123;jdbc.minIdle&#125;"/&gt; &lt;property name="maxActive" value="$&#123;jdbc.maxActive&#125;"/&gt; &lt;property name="maxWait" value="$&#123;jdbc.maxWait&#125;"/&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;"/&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;jdbc.minEvictableIdleTimeMillis&#125;"/&gt; &lt;property name="validationQuery" value="$&#123;jdbc.validationQuery&#125;"/&gt; &lt;property name="testWhileIdle" value="$&#123;jdbc.testWhileIdle&#125;"/&gt; &lt;property name="testOnBorrow" value="$&#123;jdbc.testOnBorrow&#125;"/&gt; &lt;property name="testOnReturn" value="$&#123;jdbc.testOnReturn&#125;"/&gt; &lt;property name="poolPreparedStatements" value="$&#123;jdbc.poolPreparedStatements&#125;"/&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;"/&gt; &lt;property name="filters" value="$&#123;jdbc.filters&#125;"/&gt; &lt;/bean&gt; &lt;!--配置MyBatis--&gt; &lt;bean id="SqlSessionFactoryBean" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" value="#&#123;DruidDataSource&#125;"/&gt; &lt;!--全局文件的位置--&gt; &lt;property name="configLocation" value="classpath:mybatis/mybatis-config.xml"/&gt; &lt;!--指定xml映射文件的位置--&gt; &lt;property name="mapperLocations" value="classpath:mybatis/mapper/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 扫描DAO持久层接口 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.xust.iot.mapper"/&gt; &lt;/bean&gt; &lt;!--配置事物管理器：MyBatis使用的是原生的jdbc,所以使用DataSourceTransactionManager来管理事物--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!--两种配置数据源的方式--&gt; &lt;!-- &lt;property name="dataSource" value="#&#123;DruidDataSource&#125;"/&gt;--&gt; &lt;constructor-arg name="dataSource" value="#&#123;DruidDataSource&#125;"/&gt; &lt;/bean&gt; &lt;!--配置事物策略--&gt; &lt;tx:advice id="tx"&gt; &lt;tx:attributes&gt; &lt;tx:method name="*"/&gt; &lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED"/&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id="myPointCut" expression="execution(* com.xust.iot.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="tx" pointcut-ref="myPointCut"/&gt; &lt;/aop:config&gt; &lt;!--开启自动代理--&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;&lt;/beans&gt; jdbc.properties资源文件 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/tx?useSSL=falsejdbc.username=rootjdbc.password=95162437jdbc.initialSize=10jdbc.minIdle=10jdbc.maxActive=50jdbc.maxWait=60000jdbc.timeBetweenEvictionRunsMillis=60000jdbc.minEvictableIdleTimeMillis=300000jdbc.validationQuery=SELECT 'x' FROM DUALjdbc.testWhileIdle=truejdbc.testOnBorrow=falsejdbc.testOnReturn=falsejdbc.poolPreparedStatements=truejdbc.maxPoolPreparedStatementPerConnectionSize=20jdbc.filters=wall,stat 对于SSM的配置基本上完成了，下面将使用这个搭建好的框架对对book表进行简单的CRUD操作。 一个简单CRUD1.基本准备创建数据库和表：新建tx数据库，并在tx数据库中新建book表。具体的数据库脚本如下： 1234567891011121314151617181920212223242526272829303132/*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`tx` /*!40100 DEFAULT CHARACTER SET gb2312 */;USE `tx`;/*Table structure for table `book` */DROP TABLE IF EXISTS `book`;CREATE TABLE `book` ( `isbn` varchar(50) NOT NULL, `book_name` varchar(100) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=utf-8;/*Data for the table `book` */insert into `book`(`isbn`,`book_name`,`price`) values ('ISBN-001','book01',100),('ISBN-002','book02',200),('ISBN-003','book03',300),('ISBN-004','book04',400),('ISBN-005','book05',500);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 2.开发Mapper层（DAO层）在src/main/resources目录下新建mapper目录，在mapper目录下新建BookMapper.xml文件。并在源码包的mappr包下新建对应的BookMapper.java接口。 BookMapper.xml文件 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xust.iot.mapper.BookMapper"&gt;&lt;/mapper&gt; Mapper接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xust.iot.mapper;import com.xust.iot.bean.Book;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface BookMapper &#123; /** * 根据图书的ISBN(主键)获得图书信息 * @param isbn * @return */ public Book getBookByISBN(@Param("isbn") String isbn); /** * 得到所有的书 * @return */ public List&lt;Book&gt; getAllBook(); /** * 添加一本书 * @param book * @return */ public void addBook(Book book); /** * 根据isbn更新书 * @param book */ public void updateBookByISBN(Book book); /** * 根据isbn删除一本书 * @param isbn */ public void deleteBookByISBN(@Param("isbn") String isbn);&#125; 这4个接口方法对应的XML代码如下。 1234567891011121314151617181920212223242526272829303132&lt;!--开启二级缓存，当然这里以后可以替换为第三方缓存，例如Enache、Redis...--&gt;&lt;cache&gt;&lt;/cache&gt;&lt;select id="getBookByISBN" resultType="com.xust.iot.bean.Book"&gt; select * from book &lt;where&gt; isbn=#&#123;isbn&#125; &lt;/where&gt;&lt;/select&gt; &lt;select id="getAllBook" resultType="com.xust.iot.bean.Book"&gt; select * from book&lt;/select&gt;&lt;insert id="addBook" parameterType="com.xust.iot.bean.Book"&gt; insert into book(isbn,book_name,price) values(#&#123;isbn&#125;,#&#123;bookName&#125;,#&#123;price&#125;)&lt;/insert&gt;&lt;update id="updateBookByISBN" parameterType="com.xust.iot.bean.Book"&gt; update book &lt;set&gt; book_name=#&#123;bookName&#125;, price=#&#123;price&#125; &lt;/set&gt; &lt;where&gt; isbn=#&#123;isbn&#125; &lt;/where&gt;&lt;/update&gt;&lt;delete id="deleteBookByISBN" parameterType="string"&gt; delete from book where isbn=#&#123;isbn&#125;&lt;/delete&gt; 3.开发业务层（Service层）虽然面向接口编程对于小项目来说并不重要，但是这里为了形式上的需要仍然需要提供Service接口。在src/main/java中新建com.xust.iot.sevice包，然后新建SeviceBase接口。 123456789101112131415package com.xust.iot.service;public interface ServiceBase&lt;T&gt; &#123; public T getById(Object param); public void deleteById(Object param); public void updateAndSave(T t); public void addAndSave(T t); public List&lt;T&gt; getAll();&#125; 在com.xust.iot.service包下新建impl包，然后新建BookService接口的实现类BookServiceImpl。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.xust.iot.service.impl;import com.xust.iot.bean.Book;import com.xust.iot.mapper.BookMapper;import com.xust.iot.service.ServiceBase;import org.springframework.beans.factory.annotation.Autowired;@Servicepublic class BookServiceimpl implements ServiceBase&lt;Book&gt; &#123; @Autowired private BookMapper bookMapper; @Override public Book getById(Object param) &#123; Book book=bookMapper.getBookByISBN(param.toString()); return book; &#125; @Override public void deleteById(Object param) &#123; bookMapper.deleteBookByISBN((String)param); &#125; @Override public void updateAndSave(Book book) &#123; bookMapper.updateBookByISBN(book); &#125; @Override public void addAndSave(Book book) &#123; bookMapper.addBook(book); &#125; @Override public List&lt;Book&gt; getAll() &#123; List&lt;Book&gt; lists=bookMapper.getAllBook(); return lists; &#125;&#125; 4.开发控制层（Controller层）在com.xust.iot.controller包下新建BookController类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.xust.iot.controller;import com.xust.iot.bean.Book;import com.xust.iot.service.impl.BookServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import java.util.List;@Controllerpublic class BookController &#123; @Autowired private BookServiceImpl bookService; private static boolean isNew = false; @RequestMapping(value = "/save", method = RequestMethod.POST) public String save(@ModelAttribute("book") Book book, Model model) &#123; System.out.println(book); if (isNew) &#123; bookService.addAndSave(book); model.addAttribute("msg", "添加成功！"); &#125; else &#123; bookService.updateAndSave(book); model.addAttribute("msg", "更新成功！"); &#125; return "forward:showAll"; &#125; @RequestMapping("/toUpdatePage") public String toUpdatePage(@ModelAttribute("book") Book book, Model model) &#123; model.addAttribute("book",book); return "edit"; &#125; @RequestMapping("/delete") public String delete(@RequestParam("isbn") String isbn, @RequestParam("pageNo")Integer pageNo, Model model) &#123; bookService.deleteById(isbn); model.addAttribute("msg", "删除成功！"); return "forward:showAll"; &#125; @RequestMapping("/showAll") public String showAllBook(@RequestParam("pageNo")Integer pageNo,Model model) &#123; //分页插件：从pageNo开始显示20条数据，这个语句一定要紧跟着查数据的那条语句，否者分页无效 PageHelper.startPage(pageNo,20); List&lt;Book&gt; lists = bookService.getAll(); //进一步封装数据，PageInfo的两个参数：（数据集合，连续显示的分页个数）,使用这个封装的数据可以拿到首页、末页、上/下一页....信息，非常强大的一个类 PageInfo info=new PageInfo(lists,10); model.addAttribute("info", info); return "bookInfo"; &#125; @ModelAttribute public void check(@RequestParam(value = "isbn", defaultValue = "") String isbn, @RequestParam(value = "bookName", defaultValue = "") String bookName, @RequestParam(value = "price", defaultValue = "") Integer price, Model model) &#123; System.out.println(isbn); Book book = bookService.getById(isbn); //数据库中没有这本书，那就添加一本书 if (null == book) &#123; Book book1 = new Book(); book1.setBookName(bookName); book1.setIsbn(isbn); book1.setPrice(price); model.addAttribute("book", book1); isNew = true; &#125; else &#123; //数据库中有这本书,那就直接拿出来更新信息 isNew = false; model.addAttribute("book", book); &#125; &#125;&#125; 5.开发视图层（View层）index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;添加账户&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;a href="toAdd"&gt;添加图书&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href="showAll"&gt;所有图书&lt;/a&gt;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 添加图书的页面：add.jsp 12345678910111213141516171819&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;添加图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="save" method="post"&gt; ISBN： &lt;input type="text" name="isbn"/&gt;&lt;br/&gt; 书名：&lt;input type="text" name="bookName"/&gt;&lt;br/&gt; 价格：&lt;select name="price"&gt; &lt;c:forEach begin="10" end="100" var="price" step="1"&gt; &lt;option &gt;$&#123;price&#125;&lt;/option&gt;元 &lt;/c:forEach&gt; &lt;/select&gt; &lt;button type="submit"&gt;保存&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 展示所有图书信息的页面：bookInfo.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;图书信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;button &gt;&lt;a href="toAdd"&gt;添加图书&lt;/a&gt;&lt;/button&gt;&lt;table border="1px" cellspacing="0" cellpadding="0" align="center" width="50%"&gt; &lt;tr&gt; &lt;th&gt;图书ISBN编号&lt;/th&gt; &lt;th&gt;书名&lt;/th&gt; &lt;th&gt;价格&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items="$&#123;info.list&#125;" var="book" varStatus="i"&gt; &lt;tr&gt; &lt;td&gt;$&#123;book.isbn&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.bookName&#125;&lt;/td&gt; &lt;td&gt;$&#123;book.price&#125;&lt;/td&gt; &lt;td&gt;&lt;button&gt;&lt;a href="delete?isbn=$&#123;book.isbn&#125;"&gt;删除&lt;/a&gt;&lt;/button&gt;&lt;button&gt;&lt;a href="toUpdatePage?isbn=$&#123;book.isbn&#125;"&gt;修改&lt;/a&gt;&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr style="align: center"&gt; &lt;td colspan="4" &gt; &lt;button&gt;&lt;a href="showAll?pageNo=1"&gt;首页&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="showAll?pageNo=$&#123;info.getPrePage()&#125;"&gt;上一页&lt;/a&gt;&lt;/button&gt; &lt;span&gt; &lt;c:forEach items="$&#123;info.navigatepageNums&#125;" var="nav"&gt; &lt;c:if test="$&#123;nav==info.pageNum&#125;"&gt; &lt;span style="background-color: greenyellow;border-radius: 5px;width: 30px"&gt;&amp;nbsp;&amp;nbsp;$&#123;nav&#125;&amp;nbsp;&amp;nbsp;&lt;/span&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;nav!=info.pageNum&#125;"&gt; &lt;a style="text-decoration: none" color="black" href="showAll?pageNo=$&#123;nav&#125;"&gt;$&#123;nav&#125;&lt;/a&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;/span&gt; &lt;button&gt;&lt;a href="showAll?pageNo=$&#123;info.getNextPage()&#125;"&gt;下一页&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="showAll?pageNo=$&#123;info.getPages()&#125;"&gt;末页&lt;/a&gt;&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;span&gt;$&#123;msg&#125;&lt;br/&gt;&lt;/span&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 修改图书信息的页面：edit.jsp 12345678910111213141516171819202122232425262728&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;修改图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="save" method="post"&gt; ISBN： $&#123;book.isbn&#125;&lt;br/&gt;&lt;input type="hidden" name="isbn" value="$&#123;book.isbn&#125;"/&gt; 书名：&lt;input type="text" name="bookName" value="$&#123;book.bookName&#125;"/&gt;&lt;br/&gt; 价格：&lt;select name="price"&gt;&lt;br/&gt; &lt;c:forEach begin="10" end="100" var="price" step="1"&gt; &lt;c:choose&gt; &lt;c:when test="$&#123;price==book.price&#125;"&gt; &lt;option selected&gt;$&#123;price&#125;&lt;/option&gt; &lt;/c:when&gt; &lt;c:when test="$&#123;price!=book.price&#125;"&gt; &lt;option&gt;$&#123;price&#125;&lt;/option&gt; &lt;/c:when&gt; &lt;/c:choose&gt; &lt;/c:forEach&gt;&lt;/select&gt; 元&lt;br/&gt;&lt;button type="submit"&gt;保存&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 最终的测试结果： 总结：经过几个小时的斗争，SSM三大框架的简单整合算是完成了，期间也遇到了这样那样的问题，但都一一解决了，从测试结果来看还是比较成功的。然而代码没有写几行，配置文件写了一大堆，我只想说SpringBoot真香！！！]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring声明式事物控制]]></title>
    <url>%2F2019%2F08%2F20%2FSpring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E7%89%A9%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Spring支持编程式事务管理和声明式事务管理两种方式。 &nbsp;&nbsp;&nbsp;&nbsp;编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，Spring推荐使用TransactionTemplate。 &nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。 &nbsp;&nbsp;&nbsp;&nbsp;显然声明式事务管理要优于编程式事务管理，这正是Spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。 &nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 搭建实验环境首先新建一个Maven项目，导入需要的依赖： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;dependency&gt; &lt;!--单元测试--&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; &lt;!--数据库驱动的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring面向切面编程--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring jdbc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 事物--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring 映射--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 创建数据库和表：新建tx数据库，并在tx数据库中新建三张表account、book、book_stock。具体的数据库脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*!40101 SET NAMES utf8 */;/*!40101 SET SQL_MODE=''*/;/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;CREATE DATABASE /*!32312 IF NOT EXISTS*/`tx` /*!40100 DEFAULT CHARACTER SET gb2312 */;USE `tx`;/*Table structure for table `account` */DROP TABLE IF EXISTS `account`;CREATE TABLE `account` ( `username` varchar(50) NOT NULL, `balance` int(11) DEFAULT NULL, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `account` */insert into `account`(`username`,`balance`) values ('Jerry',800),('Tom',100000);/*Table structure for table `book` */DROP TABLE IF EXISTS `book`;CREATE TABLE `book` ( `isbn` varchar(50) NOT NULL, `book_name` varchar(100) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `book` */insert into `book`(`isbn`,`book_name`,`price`) values ('ISBN-001','book01',100),('ISBN-002','book02',200),('ISBN-003','book03',300),('ISBN-004','book04',400),('ISBN-005','book05',500);/*Table structure for table `book_stock` */DROP TABLE IF EXISTS `book_stock`;CREATE TABLE `book_stock` ( `isbn` varchar(50) NOT NULL, `stock` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=gb2312;/*Data for the table `book_stock` */insert into `book_stock`(`isbn`,`stock`) values ('ISBN-001',1000),('ISBN-002',2000),('ISBN-003',3000),('ISBN-004',4000),('ISBN-005',5000);/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; 导入后应该是这样的三张表： 基于Annotation的事物管理首先配置数据源，这里使用的阿里的Druid数据连接池 12345678910111213141516171819202122232425262728293031&lt;!--引入外部文件--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!--配置数据连接池--&gt;&lt;bean id="DruidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;"/&gt; &lt;property name="minIdle" value="$&#123;jdbc.minIdle&#125;"/&gt; &lt;property name="maxActive" value="$&#123;jdbc.maxActive&#125;"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;jdbc.maxWait&#125;"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;jdbc.minEvictableIdleTimeMillis&#125;" /&gt; &lt;property name="validationQuery" value="$&#123;jdbc.validationQuery&#125;" /&gt; &lt;property name="testWhileIdle" value="$&#123;jdbc.testWhileIdle&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;jdbc.testOnBorrow&#125;" /&gt; &lt;property name="testOnReturn" value="$&#123;jdbc.testOnReturn&#125;" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。--&gt; &lt;property name="poolPreparedStatements" value="$&#123;jdbc.poolPreparedStatements&#125;" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="$&#123;jdbc.filters&#125;" /&gt;&lt;/bean&gt; 数据库配置jdbc.properties如下： 1234567891011121314151617jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/tx?useSSL=falsejdbc.username=rootjdbc.password=95162437jdbc.initialSize=10jdbc.minIdle=10jdbc.maxActive=50jdbc.maxWait=60000jdbc.timeBetweenEvictionRunsMillis=60000jdbc.minEvictableIdleTimeMillis=300000jdbc.validationQuery=SELECT 'x' FROM DUALjdbc.testWhileIdle=truejdbc.testOnBorrow=falsejdbc.testOnReturn=falsejdbc.poolPreparedStatements=truejdbc.maxPoolPreparedStatementPerConnectionSize=20jdbc.filters=wall,stat 配置JdbcTemplate，这里出于学习的目的先使用JdbcTemplate。 1234&lt;!--配置JdbcTemplate--&gt;&lt;bean id="JdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;constructor-arg name="dataSource" value="#&#123;DruidDataSource&#125;"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 配置事物管理器 1234&lt;!--DataSourceTransactionManager适用于使用JDBC来操作数据库的场景--&gt;&lt;bean id="TransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" value="#&#123;DruidDataSource&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 配置开启注解事物管理 12&lt;!--开启注解事物管理--&gt;&lt;tx:annotation-driven transaction-manager="TransactionManager"/&gt; 完整的ApplicationContext.xml配置文件如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;context:component-scan base-package="com.xust.iot"/&gt;&lt;!--引入外部文件--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!--配置数据连接池--&gt;&lt;bean id="DruidDataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name="initialSize" value="$&#123;jdbc.initialSize&#125;"/&gt; &lt;property name="minIdle" value="$&#123;jdbc.minIdle&#125;"/&gt; &lt;property name="maxActive" value="$&#123;jdbc.maxActive&#125;"/&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;jdbc.maxWait&#125;"/&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;jdbc.timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;jdbc.minEvictableIdleTimeMillis&#125;" /&gt; &lt;property name="validationQuery" value="$&#123;jdbc.validationQuery&#125;" /&gt; &lt;property name="testWhileIdle" value="$&#123;jdbc.testWhileIdle&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;jdbc.testOnBorrow&#125;" /&gt; &lt;property name="testOnReturn" value="$&#123;jdbc.testOnReturn&#125;" /&gt; &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 如果用Oracle，则把poolPreparedStatements配置为true，mysql可以配置为false。--&gt; &lt;property name="poolPreparedStatements" value="$&#123;jdbc.poolPreparedStatements&#125;" /&gt; &lt;property name="maxPoolPreparedStatementPerConnectionSize" value="$&#123;jdbc.maxPoolPreparedStatementPerConnectionSize&#125;" /&gt; &lt;!-- 配置监控统计拦截的filters --&gt; &lt;property name="filters" value="$&#123;jdbc.filters&#125;" /&gt;&lt;/bean&gt;&lt;!--配置JdbcTemplate--&gt;&lt;bean id="JdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;constructor-arg name="dataSource" value="#&#123;DruidDataSource&#125;"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--Spring事务控制--&gt;&lt;!--1.配置事务管理器,本身事物管理器是需要我们写一个切面类通过AOP编程的方式来实现，但是Spring提供了我们就直接使用Spring提供的事物管理器--&gt;&lt;bean id="TransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" value="#&#123;DruidDataSource&#125;"/&gt;&lt;/bean&gt;&lt;!--2.开启基于注解的事物管理--&gt;&lt;!--属性transaction-manager就是事物管理器--&gt;&lt;tx:annotation-driven transaction-manager="TransactionManager"&gt;&lt;/tx:annotation-driven&gt;&lt;!--3.在需要事物的地方用@Transactional来告诉Spring这个地方需要进行事物管理--&gt;&lt;/beans&gt; &nbsp;&nbsp;&nbsp;&nbsp;完成上面的操作后，我们就可以在需要事物管理的地方使用@Transactional注解标注在类或方法上，以此告诉Spring这里需要事物管理。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。@Transactional注解的属性 属性 需要的参数的类型 描述 value String 指定使用的事务管理器(必须) propagation enum:Propagation 事务传播行为设置(可选) isolation enum: Isolation 事务隔离级别设置(可选) readOnly boolean 读写或只读事务，默认（false）读写 timeout int 事务超时时间设置,单位：秒 rollbackFor Class[]，必须继承自Throwable 指定发生异常后哪些异常要回滚 rollbackForClassName String[]，必须继承自Throwable 指定发生异常后哪些异常要回滚的异常类名字数组 noRollbackFor Class[]，必须继承自Throwable 指定发生异常后哪些异常不回滚 noRollbackForClassName String[]，必须继承自Throwable指定发生异常后哪些异常不回滚的异常类名字数组 DAO层，直接使用JdbcTemplate操作数据库，写3个方法分别用于：更新用户余额、更新图书库存、以及查询价格，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.dao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Repository;@Repositorypublic class BookDaoimp &#123; @Autowired JdbcTemplate jdbcTemplate; /** * 减库存 */ public void updateBookStock(Integer books,String isbn)&#123; String sql="update book_stock set stock=stock-? where isbn=?"; jdbcTemplate.update(sql,books,isbn); &#125; /** * 减用户对余额 */ public void updateUserBalance(Integer payment,String username)&#123; String sql="updatess account set balance=balance-? where username=?"; jdbcTemplate.update(sql,payment,username); &#125; /** * 查询图书的价格 * @param isbn * @return */ public Integer getBookPrice(String isbn)&#123; String sql="select price from book where isbn=?"; return jdbcTemplate.queryForObject(sql,Integer.class,isbn); &#125;&#125; 业务层，写一个结账的方法，使用@Transactional告诉Spring要帮我们控制事务 123456789101112131415161718192021222324252627282930313233package com.xust.iot.service;import com.xust.iot.dao.BookDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;@Servicepublic class BookService &#123; @Autowired BookDao bookDao; /** * 模拟结账 * @param username 用户姓名 * @param isbn 图书编号 * @param books 用户买了几本书 */ @Transactional public void cheockout(String username,String isbn,Integer books)&#123; //减库存 bookDao.updateBookStock(books,isbn); Integer price=bookDao.getBookPrice(isbn); Integer payment=price*books; //减账户余额 bookDao.updateUserBalance(payment,username); &#125;&#125; 基于XML的事物管理其他的步骤和使用注解一样，不同的核心操作在下面： 123456789101112131415161718&lt;!--基于XML的事物管理--&gt;&lt;!--1.配置事务管理器：这个和使用注解时一样--&gt;&lt;bean id="TransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" value="#&#123;DruidDataSource&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--2.配置事物属性：使用&lt;tx:advice&gt;标签声明事物通知 --&gt;&lt;tx:advice id="myTransaction" transaction-manager="TransactionManager"&gt; &lt;!--事物属性--&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" propagation="REQUIRED" read-only="true"/&gt; &lt;tx:method name="cheockout" propagation="REQUIRED" isolation="REPEATABLE_READ"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--3.配置事物切入点，把事物切入点和事物属性关联起来--&gt;&lt;aop:config&gt; &lt;aop:pointcut id="pointCut" expression="execution(* com.xust.iot.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="myTransaction" pointcut-ref="pointCut"/&gt;&lt;/aop:config&gt; 测试在src/main/test包下新建测试类TxTest.java测试 12345678910111213141516171819202122232425262728package test;import com.alibaba.druid.pool.DruidDataSource;import com.xust.iot.service.BookService;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.jdbc.core.JdbcTemplate;import java.sql.Connection;import java.sql.SQLException;import java.util.Date;public class TxTest &#123; ApplicationContext ioc=new ClassPathXmlApplicationContext("ApplicationContext.xml"); private JdbcTemplate jdbcTemplate=ioc.getBean(JdbcTemplate.class); @Test public void txTest()&#123; BookService bookService=ioc.getBean(BookService.class); bookService.cheockout("Tom","ISBN-005",3); System.out.println("结账成功！"); &#125;&#125;]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring和SpringMVC整合]]></title>
    <url>%2F2019%2F08%2F17%2FSpring%E5%92%8CSpringMVC%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[看到这个标题有些同学有点奇怪，SpringMVC是基于Spring的框架，没有必要整合，关于Spring的IOC和bean在springmvc的配置文件里配置就可以了。如果真的这样，那我们的配置文件就面临着难以维护的致命缺点。 正常来说，我们应该将Spring的容器和SpringMVCc的配置文件分开来，在Spring的容器配置IOC和AOP的相关组件，让他只负责各个bean之间的依赖和横切逻辑，而在SpringMVC的配置文件中只负责handler的配置就完全可以了。 因此所谓的整合，实质上是让Spring和SpringMVC明确分工，各司其职。分工的目的总结来说就是： Spring配置文件：配置和业务有关的（事务控制、数据源.....） SpringMVC配置文件：配置和网站转发逻辑和网站功能有关的（视图解析、文件上传、支持ajax.....） 好了，废话不多说，下面直接来看看如何把他两有机的整合在一起。 导包首先，导入jar包这里使用Maven来管理项目，所需的Maven依赖写法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;properties&gt; &lt;spring.version&gt;5.1.2.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt;&lt;!--单元测试--&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!--Spring start--&gt;&lt;!--Core：spring-core、spring-beans、spring-content、spring-expression--&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--AOP：spring-aop、spring-aspectj、spring-instrument、spring-instrument-tomcat--&gt;&lt;!--spring aop：外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Data Access--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Web--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--spring-mvc--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring End--&gt;&lt;!--Servlet API--&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt; 写配置web.xml的配置web.xml应该是整个项目最重要的配置文件了，不过servlet3.0中已经支持注解配置方式了。在servlet3.0以前每个servlet必须要在web.xml中配置servlet及其映射关系。但是在spring框架中就不用了，因为Spring中是依赖注入（Dependency Injection）的也叫控制反转（Inversion of Control）。但是也要配置一个重要的servlet，就是前端控制器（DispatcherServlet）。配置方式与普通的servlet基本相似。 配置内容如下： 123456789101112131415&lt;!--配置前段控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--web容器启动的时候就加载SpringMVC--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc-config.xml是SpringMVC的配置文件，稍后讨论他的配置。在web.xml中配置Spring容器： 12345&lt;!--加载Spring容器--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 配置监听器： 1234&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 注意：如果你的项目里面不使用 WebApplicationContext 就可以不配置listener节点。但是正常情况下，都会配置ContentLoaderListener，具体参考这位老哥的博客：https://blog.csdn.net/qq_15037231/article/details/78743765。 配置字符编码过滤器： 1234567891011121314151617&lt;!--配置字符编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 完整的web.xml配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;&lt;!--配置前段控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--web容器启动的时候就加载SpringMVC--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!--加载Spring容器--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--配置监听器--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--配置字符编码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc-config.xml的配置配置自动扫描：只扫描Controller和ControllerAdvice 12345&lt;!--配置SpringMVC扫描的范围--&gt;&lt;context:component-scan base-package="com.xust.iot" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;&lt;/context:component-scan&gt; 注意：当使用&lt; context:component-scan /&gt;后，就可以将 &lt; context:annotation-config/&gt;移除。 配置视图解析器： 12345&lt;!--配置视图解析器--&gt;&lt;bean name="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; 配置全局异常处理器：自己先写一个异常处理的类，然后用@ControllerAdvice标注，有啥异常后面开发的时候再写 12&lt;!--配置全局的异常处理器--&gt;&lt;bean id="exceptionHandler" class="com.xust.iot.exception.EntireExceptionHandler"/&gt; 如果项目中有上传文件的需求，那么还需要配置文件上传解析器，一般使用commons-fileupload来上传文件，需要导入的Maven依赖写法如下： 1234567891011121314&lt;!--文件上传--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;!--comons-fileupload依赖commons-io,commons-io可以把它看成java IO的加强版--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 文件上传的配置如下： 12345&lt;!--文件上传解析器--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="#&#123;1024*1024*20&#125;"&gt;&lt;/property&gt; &lt;property name="maxUploadSizePerFile" value="#&#123;1024*1024*5&#125;"&gt;&lt;/property&gt;&lt;/bean&gt; 注意：在使用CommonsMultipartResolver时一定要导入commons-fileupload的jar包，否者服务器一启动就会报错。 在上面web.xml中配置的前端控制器拦截了所有的请求，不做特殊处理就会导致部分静态资源无法使用。如果是这种情况就可以使用下面的配置来访问静态资源文件： 12&lt;!--配置默认对静态文件的处理--&gt;&lt;mvc:default-servlet-handler/&gt; 当然，也可以使用下面的配置方式来处理静态资源： 1234&lt;mvc:resources mapping="/images/**" location="/images/" /&gt;&lt;mvc:resources mapping="/css/**" location="/css/" /&gt; &lt;mvc:resources mapping="/js/**" location="/js/" /&gt;&lt;mvc:resources mapping="/imgdata/**" location="/imgdata/" /&gt; 对于静态资源处理如果问题，可以参照这位老哥的博客：https://www.cnblogs.com/dflmg/p/6393416.html。 完整的springmvc-config.xml文件的配置如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;!--配置SpringMVC扫描的范围--&gt;&lt;context:component-scan base-package="com.xust.iot" use-default-filters="false"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;&lt;/context:component-scan&gt;&lt;!--配置默认对静态文件的处理--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- mvc的注解驱动 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!--配置视图解析器--&gt;&lt;bean name="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt;&amp;lt;!&amp;ndash;文件上传解析器&amp;ndash;&amp;gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="#&#123;1024*1024*20&#125;"&gt;&lt;/property&gt; &lt;property name="maxUploadSizePerFile" value="#&#123;1024*1024*5&#125;"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置全局的异常处理器--&gt;&lt;bean id="exceptionHandler" class="com.xust.iot.exception.EntireExceptionHandler"/&gt;&lt;/beans&gt; applicationContext.xml的配置配置自动扫描：Spring要扫描的是SpringMVC不扫描的，就是他两扫描的范围互补，因此这里只需要排除SpringMVC扫秒的范围即可。配置如下： 123456&lt;!--配置Spring自动扫描的范围--&gt;&lt;context:component-scan base-package="com.xust.iot"&gt; &lt;!--排除掉SpringMVC扫秒的外，Spring都取扫描--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;&lt;/context:component-scan&gt; 完整的applicationContext.xml包的配置如下： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!--配置Spring自动扫描的范围--&gt;&lt;context:component-scan base-package="com.xust.iot"&gt; &lt;!--排除掉SpringMVC扫秒的外，Spring都取扫描--&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 测试最后写代码来测试一下Service层 12345678910111213141516package com.xust.iot.sevice;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123; public UserService() &#123; System.out.println("初始化UserService......"); &#125; public String hello()&#123; return "Hello,Spring和SpringMVC整合成功！"; &#125;&#125; Controller层 123456789101112131415161718192021222324252627package com.xust.iot.controller;import com.xust.iot.sevice.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @Autowired private UserService userService; public UserController() &#123; System.out.println("初始化UerController....."); &#125; @RequestMapping("/hello") public String hello(Model model)&#123; model.addAttribute("msg",userService.hello()); return "success"; &#125;&#125; 测试结果： 与此同时，控制台的打印的信息如下： 可以看到，两个类都被注册进了各自应该去的容器中。而且都只初始化了一遍。达到了最初的目的。 Spring与SpringMVC父子容器的关系&nbsp;&nbsp;&nbsp;&nbsp;最后，简单的说一下Spring与SpringMVC父子容器的关系&nbsp;&nbsp;&nbsp;&nbsp;Spring源码中默认规定，当Spring和SpringMVC两个容器共存的时候：1. Spring和SpringMVC的容器具有父子关系，Spring容器为父容器，SpringMVC为子容器，子容器可以引用父容器中的Bean，而父容器不可以引用子容器中的Bean;2. Spring容器导入的properties配置文件，只能在Spring容器中用而在SpringMVC容器中不能读取到。 需要在SpringMVC 的配置文件中重新进行导入properties文件，并且同样在父容器Spring中不能被使用，导入后使用@Value(“${key}”)在java类中进行读取。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC异常处理]]></title>
    <url>%2F2019%2F08%2F15%2FSpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[重要的接口和类HandlerExceptionResolver&nbsp; &nbsp; &nbsp; &nbsp;他是SpringMVC“九大组件”之一,SpringMVC异常处理核心接口。该接口定义了1个解析异常的方法： ExceptionHandlerExceptionResolver &nbsp; &nbsp; &nbsp; &nbsp;继承自AbstractHandlerMethodExceptionResolver，该类主要处理Controller中用@ExceptionHandler注解定义的方法。该类是&lt;annotation-driven/&gt;配置中定义的HandlerExceptionResolver实现类之一，大多数异常处理都是由该类操作。 在Controller中使用@ExceptionHandler 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;@Controllerpublic class ExceptionHandlerTest &#123;@RequestMapping("/handler1")public String handler1(Model model,@RequestParam(value = "value",required = false) int value)&#123; int i=10/value; model.addAttribute("msg","你好呀！"); model.addAttribute("msg1","10/"+value+"="); model.addAttribute("res",i); return "success";&#125;/** * 使用@ExceptionHandler注解可以告诉SpringMVC这是一个专门处理异常的方法 * 一个方法可处理多个异常，可以有多个处理异常的类 * @param e * @return */@ExceptionHandler(ArithmeticException.class)public ModelAndView exceptionHandler1(Exception e, HttpServletResponse response)&#123; System.out.println("在"+this.getClass().getName()+"中的异常处理方法"); ModelAndView mv=new ModelAndView("error"); mv.addObject("e",e); mv.addObject("statusCode",response.getStatus()); return mv;&#125;&#125; 异常后的页面： 12345678910&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;出错啦&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;出错啦！响应代码：$&#123;status&#125;，错误信息:$&#123;e&#125;&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： &nbsp; &nbsp; &nbsp; &nbsp;像这样在Controller中借助@ExceptionHandler这个注解定义的异常处理方法只能在定义的那个Controller中使用，当Controller类十分多的时候，那么写异常处理方法就是个体力活了，因此SpringMVC就提供了@ControllerAdvice这个注解,它只能用在类上，而这个类中的异常处理方法都是全局范围，如下定义一个类专门集中处理异常： 1234567891011121314151617181920212223242526272829303132333435package com.xust.iot.handleException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletResponse;@ControllerAdvicepublic class MyExceptionHandler &#123;@ExceptionHandler(ArithmeticException.class)public ModelAndView handleArithmeticException(Exception e,HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView("error"); mv.addObject("status", response.getStatus()); mv.addObject("e",e); return mv;&#125;@ExceptionHandler(NullPointerException.class)public ModelAndView handlerNulPointlException(Exception e,HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView("error"); mv.addObject("status", response.getStatus()); mv.addObject("e",e); return mv;&#125;@ExceptionHandler(Exception.class)public ModelAndView handlerException(Exception e, HttpServletResponse response)&#123; ModelAndView mv=new ModelAndView("error"); mv.addObject("status", response.getStatus()); mv.addObject("e",e); return mv;&#125;&#125; 一个好的异常处理机制应该是这样的，有一个集中的处理点负责所有的异常处理，在真正的业务逻辑的处理过程中，我只会关心正常的业务流程，一旦遇到异常，我只管抛出对应的异常和相关的信息就行了。 DefaultHandlerExceptionResovler&nbsp; &nbsp; &nbsp; &nbsp;HandlerExceptionResolver接口的默认实现之一 ，基本上是Spring MVC内部使用，用来处理Spring定义的各种标准异常，将其转化为相对应的HTTP Status Code。其处理的异常类型有： 123456789101112handleNoSuchRequestHandlingMethodhandleHttpRequestMethodNotSupportedhandleHttpMediaTypeNotSupportedhandleMissingServletRequestParameterhandleServletRequestBindingExceptionhandleTypeMismatchhandleHttpMessageNotReadablehandleHttpMessageNotWritablehandleMethodArgumentNotValidExceptionhandleMissingServletRequestParameterhandleMissingServletRequestPartExceptionhandleBindException ResponseStatusExceptionResovler&nbsp; &nbsp; &nbsp; &nbsp;用来支持@ResponseStatus的使用，处理使用了ResponseStatus注解的异常，根据注解的内容，返回相应的HTTP Status Code和异常页面给客户端。如果Web应用程序中配置了ResponseStatusExceptionResolver，那么我们就可以使用ResponseStatus注解来注解我们自己编写的异常类，并在Controller中抛出该异常类，之后ResponseStatusExceptionResolver就会自动帮我们处理剩下的工作。&lt;annotation-driven/&gt;配置中定义的HandlerExceptionResolver实现类之一。 自定义一个异常 123456789package com.xust.iot.handleException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason = "用户不存在",value = HttpStatus.NOT_FOUND)public class UserNotFoundException extends RuntimeException &#123; //......&#125; 另一个自定义异常 12345678package com.xust.iot.handleException;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason = "输入的登录参数不合法",value = HttpStatus.BAD_REQUEST)public class ParamterIllegalException extends RuntimeException &#123;&#125; 在Controller中主动抛出这个异常看看效果： 12345678910111213141516171819202122232425262728293031323334353637383940package com.xust.iot.controller;import com.xust.iot.beans.User;import com.xust.iot.handleException.ParamterIllegalException;import com.xust.iot.handleException.UserNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;@Controllerpublic class UserController &#123;@RequestMapping("/toLogin")public String checkLogIn(@RequestParam(value ="username",defaultValue = "")String username,Model model) throws Throwable &#123; if("".equals(username))&#123; System.out.println("用户登录失败"); throw new ParamaterIllegalException(); &#125;else if(!"admin".equals(username))&#123; System.out.println("用户登录失败"); throw new UserNotFoundException(); &#125; model.addAttribute("msg","欢迎你"+username+",现在是北京时间："+new SimpleDateFormat("hh:mm:ss").format(new Date())); System.out.println("用户登录成功"); return "success";&#125;&#125; 测试结果： ExceptionHandlerExceptionResolver、DefaultHandlerExceptionResolver和ResponseStatusExceptionResolver这三个类是&lt;mvc:annotation-driver&gt;配置后默认的3个实现类，他们的优先级是按书写的顺序由高到底。 SimpleMappingExceptionResovler提供了将异常映射为视图的能力，高度可定制化。其提供的能力有： 根据异常的类型，将异常映射到视图； 可以为不符合处理条件没有被处理的异常，指定一个默认的错误返回； 处理异常时，记录log信息； 指定需要添加到Modle中的Exception属性，从而在视图中展示该属性。在Springmvc配置文件中配置SimpleMappingExceptionResovler12345678910111213&lt;bean class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"&gt;&lt;property name="exceptionMappings"&gt; &lt;!--在props标签中配置所有异常后对应的页面,其中: key表示异常，应该写异常的全类名 &lt;prop&gt;标签体写该异常映射的视图名，只写视图名即可，SpringMVC的视图处理器会自动拼串 --&gt; &lt;props&gt; &lt;prop key="java.lang.NullPointerException" &gt;error&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--指定取出错误信息的key--&gt;&lt;property name="exceptionAttribute" value="ex"/&gt; 这样，我们把SimpleMappingExceptionResolver配置好了，这个类在配置的时候还有很多的属性可以配置，如下:]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC 资源国际化]]></title>
    <url>%2F2019%2F08%2F15%2FSpringMVC%E8%B5%84%E6%BA%90%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[国际化开发概述软件的国际化：软件开发时，要使它能同时应对世界不同地区和国家的访问，并针对不同地区和国家的访问，提供相应的、符合来访者阅读习惯的页面或数据。国际化(internationalization)又称为 i18n(读法为i 18 n，据说是因为internationalization(国际化)这个单词从i到n之间有18个英文字母，i18n的名字由此而来) 国际化的基本规则国际化信息”也称为“本地化信息”，一般需要两个条件才可以确定一个特定类型的本地化信息，它们分别是“语言类型”和“国家/地区的类型”。如中文本地化信息既有中国大陆地区的中文，又有中国台湾、中国香港地区的中文，还有新加坡地区的中文。Java通过java.util.Locale类表示一个本地化对象，它允许通过语言参数和国家/地区参数创建一个确定的本地化对象。 语言参数使用ISO标准语言代码表示，这些代码是由ISO-639标准定义的，每一种语言由两个小写字母表示。在许多网站上都可以找到这些代码的完整列表，下面的网址是提供了标准语言代码的信息：http://www.loc.gov/standards/iso639-2/php/English_list.php。 国家/地区参数也由标准的ISO国家/地区代码表示，这些代码是由ISO-3166标准定义的，每个国家/地区由两个大写字母表示。用户可以从以下网址查看ISO-3166的标准代码：http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html。下面是常用的国家/地区语言参数： 实现一个简单的国际化编写国际化资源文件国际化资源文件就是用一种key-value的形式把要显示的信息的不同语言的翻译版本写到properties资源文件中：针对美式英文的资源文件： 1234567login_en_US.properties:welcomeInfo=Welcome to my personal blog LoveITerusername=USERNAMEpassword=PASSWORDloginbtn=LOGINplaceholder_username=please input usernameplaceholder_password=please input password 针对简体中文的资源文件： 1234567login_zh_CN.propertieswelcomeInfo=欢迎访问我的个人博客LoveITerusername=用户名password=密码loginbtn=登录placeholder_username=请输入用户名placeholder_password=请输入密码 注意：一般情况下我们用._zh_CN.properties表示中文资源文件，.properties表示默认的资源文件。 在springmvc配置文件中简单的配置一下，把我们的资源文件交给SpringMVC管理 1234 &lt;!--配置国际化资源文件--&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basename" value="login"/&gt;&lt;/bean&gt; 编写一个用户登录表单 12345678910111213141516171819&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;fmt:message key="welcomeInfo"/&gt;&lt;/h3&gt;&lt;form action="checkLogin" method="post" &gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key="username"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" placeholder="&lt;fmt:message key='placeholder_username'/&gt;"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key="password"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="password" placeholder="&lt;fmt:message key='placeholder_password'/&gt;"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;input type="submit" value="&lt;fmt:message key="loginbtn"/&gt;"/&gt;&lt;/th&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码中用到了JSTL中的fmt标签&lt;fmt:message&gt;,因此需要导入对应的jar包。 测试结果：我的浏览器默认就是中文，因此显示的就是中文的欢迎信息： 在火狐浏览器中手动更改语言为英文 英文环境下就显示的是英文信息： 资源文件的编码问题一般我们采用properties文件来保存资源文件。properties文件是以key-value的形式来保存文件的。login_zh_CN.properties中保存的是经过utf-8编码字后的ASCII字符，Unicode字符中不允许出现中文、日文等其他字符的文字。但是Unicode编码后的文字阅读起来比较困难，在IDEA中，可以在File-&gt;Settings-&gt;Editor-&gt;File Encodings设置中勾选Transparent native-to-ascii conversion,如下图，设置好后点击Apply,然后回到刚才编写的中文资源文件发现中文字符全部乱码了，这时可以在编辑器中直接重新输入中文。虽然我们输入的是中文，但是IDEA已经帮我们做了中文转码。 在程序中获取国际化信息在程序中我们可以通过ResourceBundleMessageSource来获取资源文件的信息： 1234567891011121314151617181920212223242526272829303132package com.xust.iot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Locale;@Controllerpublic class UserController &#123;@Autowiredprivate MessageSource messageSource;/** * SpringMVC会自动把locale信息注入 * @param locale * @return */@RequestMapping("/toLogin")public String logIn(Locale locale) &#123; System.out.println(locale); String welcomeInfo=messageSource.getMessage("welcomeInfo",null,locale); String userName=messageSource.getMessage("username",null,locale); String password=messageSource.getMessage("password",null,locale); System.out.println(welcomeInfo+"----"+userName+"----"+password); return "login";&#125;&#125; 执行结果：可以看到在不同对语言环境下使用了不同的资源文件。 自定义区域信息解析器3个步骤：1、写一个类实现LocaleResolver接口或他的子接口或继承他的实现类，最主要是要实现它的resolveLocale方法2、在springmvc的配置文件中把我们写的区域信息解析器注册给SpringMVC3、启动测试写一个类实现LocalResolver接口 1234567891011121314151617181920212223242526272829303132333435package com.xust.iot.LocaleResolver;import net.sf.cglib.core.Local;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123;/** * 解析locale信息 * @param request * @return */@Overridepublic Locale resolveLocale(HttpServletRequest request) &#123; Locale locale=null; //通过请求解析请求参数中的locale来让用户可以根据自己的习惯选择语言 String localeStr=null!=request.getParameter("locale")?request.getParameter("locale"):""; if(!"".equals(localeStr))&#123; locale=new Locale(localeStr.split("_")[0],localeStr.split("_")[1]); &#125;else&#123; locale=request.getLocale(); &#125; return locale;&#125;@Overridepublic void setLocale(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Locale locale) &#123;&#125;&#125; 配置自定义的解析器 12&lt;!--自定义区域信息解析器--&gt;&lt;bean id="localeResolver" class="com.xust.iot.LocaleResolver.MyLocaleResolver"/&gt; 注意：解析器的id必须是localeResolver，如果写错了就没有效果了。至于为啥非要这么写请参考SpringMVC源码中的DispatcherServlet这个类。 在页面中加入可以切换语言的链接： 1234567891011121314151617181920&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;&lt;fmt:message key="welcomeInfo"/&gt;&lt;/h3&gt;&lt;form action="checkLogin" method="post" &gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key="username"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" placeholder="&lt;fmt:message key='placeholder_username'/&gt;"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;fmt:message key="password"/&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="password" placeholder="&lt;fmt:message key='placeholder_password'/&gt;"/&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;&lt;input type="submit" value="&lt;fmt:message key="loginbtn"/&gt;"/&gt;&lt;/th&gt;&lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;a href="toLogin?locale=zh_CN"&gt;&lt;fmt:message key="Chinese"/&gt;&lt;/a&gt;|&lt;a href="toLogin?locale=en_US"&gt;&lt;fmt:message key="English"/&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： SessionLocaleResolver 从SpringMVC的区域信息的继承图中我么看到了几个特别的区域信息解析器： 1、AcceptHeaderLocaleResolver：它是SpringMVC默认装配的区域信息解析器，他会默认从 accept-language请求头信息进行解析处理，通常这个头信息包含客户端操作信息的本地标示。它不支持通过链接的方式改变locale信息。 2、FixedLocaleResolver：从字面意思就可以知道，这也是一个不支持通过链接的方式改变locale信息的一个解析器，它默认会从操作系统拿locale信息。 3、SessionocaleResolver：从session中拿locale信息，允许设置区域信息。 4、CookieLocaleResolver：从Cookie中拿locale信息，允许设置区域信息。 下面我们借助SessionLocaleResolver来实现我们上面自定义区域信息解析器的功能： 123456789101112131415161718192021222324252627282930313233343536373839package com.xust.iot.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.util.Locale;@Controllerpublic class UserController &#123;@Autowiredprivate MessageSource messageSource;@RequestMapping("/toLogin")public String logIn( @RequestParam(value = "locale",defaultValue = "zh_CN") String localeStr, Model model, Locale locale, HttpSession session) &#123; Locale l=null; if(null!=localeStr&amp;&amp;!"".equals(localeStr))&#123; l=new Locale(localeStr.split("_")[0],localeStr.split("_")[1]); &#125;else&#123; l=locale; &#125; session.setAttribute(SessionLocaleResolver.class.getName() + ".LOCALE",l); return "login";&#125;&#125; 测试结果： 使用LocaleChangeInterceptor通过配置LocaleChangeInterceptor，我们可以动态改变本地语言。从他的名字就可以知道他是一个可改变Locale信息的拦截器，熟悉Spring MVC拦截器的同学都知道，如果配置了拦截器，Spring MVC会在处理请求之前调用拦截器的preHandle方法，而LocaleChangeInterceptor就是在真正开启处理请求之前先调用LoacleResolver的方法setLocal()设置了本地化信息。 既然是拦截器，要使用他就需要在springmvc配置文件中配置它，配置也很简单： 123&lt;mvc:interceptors&gt; &lt;bean id="localeChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;&lt;/mvc:interceptors&gt; 然后在配合SessionLocaleResovler，实现动态的改变本地信息 1234567&lt;!--SessionLocaleResolver--&gt;&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/&gt;&lt;!--资源国际化拦截器--&gt;&lt;mvc:interceptors&gt; &lt;bean id="localeChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;&lt;/mvc:interceptors&gt; 控制器层的代码瞬间变得极其简练，就一个跳转页面对返回语句 12345678910@Controllerpublic class UserController &#123;@RequestMapping("/toLogin")public String logIn() &#123; return "login";&#125;&#125; 测试结果：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC拦截器]]></title>
    <url>%2F2019%2F08%2F14%2FSpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8(Interceptor)%2F</url>
    <content type="text"><![CDATA[拦截器概述什么是拦截器？Spring MVC中的拦截器（Interceptor）类似于Servlet中的过滤器（Filter），但是比过滤器的功能更加强大，它主要用于拦截用户请求并作相应的处理。例如通过拦截器可以进行权限验证、记录请求信息的日志、判断用户是否登录等。要使用Spring MVC中的拦截器，就需要对拦截器类进行定义和配置。通常拦截器类可以通过两种方式来定义：1.通过实现HandlerInterceptor接口，或继承HandlerInterceptor接口的实现类（如HandlerInterceptorAdapter）来定义。 2.通过实现WebRequestInterceptor接口，或继承WebRequestInterceptor接口的实现类来定义。 #### 实现第一个拦截器 以实现HandlerInterceptor接口方式为例，自定义拦截器类的代码如下： 123456789101112131415161718192021222324252627282930package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("1.执行目标方法之前......"); //返回true表示放行，可以去执行目标方法，否者表示不允许执行目标方法 return true;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("3.执行目标方法之后......");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("5.来到页面之后......");&#125;&#125; 上述代码中，自定义拦截器实现了HandlerInterceptor接口，并实现了接口中的三个方法： preHandle()：在目标方法执行之前回执行，有个boolean类型的返回值，当返回true表示放行，即允许执行目标方法;当返回false，表示不放行，即不运行执行目标方法，此时会中断以后的所有过程 postHandle()：在目标方法执行结束后会执行，且解析视图之前执行 afterCompletion()：在请求到达页面，即视图渲染完成后执行 开发拦截器就像开发servlet或者filter一样，都需要在配置文件进行配置，配置代码如下： 12345&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id="myInterceptor" class="com.xust.iot.interceptor.MyFirstInterceptor"/&gt;&lt;/mvc:interceptors&gt; 上面的代码中，&lt;mvc:interceptors&gt;元素用于配置一组拦截器，子元素&lt;bean&gt;中定义的是全局拦截器，它会拦截所有的请求；而也可以使用&lt;mvc:interceptor&gt;元素中定义指定路径的拦截器，它会对指定路径下的请求生效。&lt;mvc:interceptor&gt;元素的子元素&lt;mvc:mapping&gt;用于配置拦截器作用的路径，该路径在其属性path 中定义。如果在请求路径中包含不需要拦截的内容，还可以通过&lt;mvc:exclude-mapping&gt;元素进行配置。注意：&lt;mvc:interceptor&gt;中的子元素必须按照上述代码中的配置顺序进行编写，即&lt;mvc:mapping&gt; &lt;mvc:exclude-mapping&gt; &lt;bean&gt;，否则文件会报错。 下面写一个控制器来测试一下正常情况下单个拦截器的工作流程： 123456789101112131415161718package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IntercrtorTestController &#123;@RequestMapping(value = "/test01")public String handler01(Model model)&#123; System.out.println("2.执行了目标方法......"); model.addAttribute("msg","你好啊！！!"); return "success";&#125;&#125; 目标页面success.jsp 1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println("4.来到了success.jsp页面");%&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 测试结果 单个拦截器正常情况下的工作流程： 1. 拦截器preHandle方法执行，返回true继续以后的过程 2. 控制器目标方法执行 3. 拦截器postHandle方法执行 4. 页面渲染完成来到页面 5. 拦截器afterCompletion方法执行 单个拦截器非正常情况下的工作流程：单个拦截器的非正常情况分为两种情况：&nbsp;&nbsp;&nbsp;&nbsp;1、拦截器中的preHandler方法返回false;&nbsp;&nbsp;&nbsp;&nbsp;2、虽然preHandler方法返回了true，但是其中有一个过程“炸了”，比如发生了异常没有处理接下来通过代码来测试： 第一种情况：preHandler返回false123456789101112131415161718192021222324252627282930package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("1.执行目标方法之前......"); //返回true表示放行，可以去执行目标方法，否者表示不允许执行目标方法 return false;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("3.执行目标方法之后......");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("5.来到页面之后......");&#125;&#125; 测试结果：可以看到，后面的过程直接无法执行 第二种情况：preHandle方法放行了，但是有一个过程“炸了”,比如我们在控制器目标方法中制造一个异常：12345678910111213141516171819package com.xust.iot.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class IntercrtorTestController &#123;@RequestMapping(value = "/test01")public String handler01(Model model)&#123; int i=30/0; System.out.println("2.执行了目标方法......"); model.addAttribute("msg","你好啊！！!"); return "success";&#125;&#125; 测试结果： 可以看到，只要拦截器的prehandle方法放行了，拦截器的afterCompletion方法总会执行/font> 多个拦截器正常情况下的工作流程：第二个拦截器： 1234567891011121314151617181920212223242526package com.xust.iot.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MySecondInterceptor implements HandlerInterceptor &#123;@Overridepublic boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("1.执行目标方法之前......MySecondInterceptor"); return true;&#125;@Overridepublic void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("3.执行目标方法之后......MySecondInterceptor");&#125;@Overridepublic void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("5.来到页面之后......MySecondInterceptor");&#125;&#125; 配置第二个拦截器 12345678910111213&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--拦截器1--&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id="myInterceptor" class="com.xust.iot.interceptor.MyFirstInterceptor"/&gt; &lt;!--拦截器2--&gt; &lt;!--使用&lt;mvc:interceptor&gt;可以具体配置拦截器拦截那些请求&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/test01"/&gt; &lt;bean class="com.xust.iot.interceptor.MySecondInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 执行结果： 交换拦截器在springmvc配置文件中的定义顺序： 12345678910111213&lt;!--拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--拦截器2--&gt; &lt;!--使用&lt;mvc:interceptor&gt;可以具体配置拦截器拦截那些请求&gt;--&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/test01"/&gt; &lt;bean class="com.xust.iot.interceptor.MySecondInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;!--拦截器1--&gt; &lt;!--这样配置的拦截器默认拦截所有请求--&gt; &lt;bean id="myInterceptor" class="com.xust.iot.interceptor.MyFirstInterceptor"/&gt;&lt;/mvc:interceptors&gt; 执行结果： 测试结果表明： 多个拦截器是有执行的先后顺序的，这个顺序就是定义的先后顺序 拦截器的preHandle方法：按照定义顺序顺序执行的 拦截器的postHandle方法：按照定义顺序逆序执行的 拦截器的preHandle方法：按照定义顺序顺逆序执行的 多个拦截器非正常情况下的工作流程：1、一个拦截器的preHandle方法返回false的情况： 2、所有拦截器的preHandle方法都返回true,但是中间有过程发生了异常： 小结单拦截器的执行顺序 正常情况下会按照：preHandle--->目标方法--->postHnadle--->页面渲染--->afterCompetion执行 当preHandle返回false,就没有以后流程的事儿了 当preHandler返回了true,但是中间过程发生异常，会直接结束以后的流程但是afterCompetion总会执行 多个拦截器的执行顺序正常情况 会按照配置中定义的顺序顺序执行所有拦截器的preHandle方法，然后执行控制器中目标方法，之后按照定义顺序的逆序执行postHandle方法，然后渲染页面，最后按照定义的顺序的逆序执行afterComprtion方法 有拦截器返回false 在多个拦截器中只要有一个拦截器的preHandle方法返回了false,那么以后的流程都没有了，会直接回按照这些拦截器配置的定义顺序的逆序执行afterCompetion方法]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC文件下载和上传]]></title>
    <url>%2F2019%2F08%2F13%2FSpringMVC%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[文件下载文件下载的最重要的一点是设置响应头的Content-disposition为attachmen;filename=要下载的文件的名字,然后得到文件的输入流写入本地即可1. 常规方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 第一种文件下载的方法：使用原生的Servlet API * * @param filename 下载的文件名，SpringMVC会根据请求参数自动注入 * @param request * @param response * @throws UnsupportedEncodingException */@RequestMapping(value="/download1",method=RequestMethod.GET)public void download(@ResuestParam("filename")String fileName, HttpServletRequest request, HttpServletResponse response) throws UnsupportedEncodingException &#123; response.setContentType("text/html;charset=utf-8"); //解析文件在服务器中的真实路径 String filePath = request.getServletContext().getRealPath("/download/" + fileName); //System.out.println(filePath); BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //设置响应头告诉客户端浏览器，这个请求是要下载文件 long fileLength = new File(filePath).length(); response.setContentType("application/x-msdownload;"); response.setHeader("Content-disposition", "attachment;filename=" + fileName); response.setHeader("Content-Length", String.valueOf(fileLength)); //向客户端浏览器写文件数据 bis = new BufferedInputStream(new FileInputStream(filePath)); bos = new BufferedOutputStream(response.getOutputStream()); byte[] buff = new byte[1024]; int len; while (-1 != (len = bis.read(buff, 0, buff.length))) &#123; bos.write(buff, 0, len); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != bis) &#123; try &#123; bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (null != bos) &#123; try &#123; bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 2. 使用SpringMVC提供的 ResponseEntity&lt;T&gt;类型，使用它可以很方便地定义返回的HttpHeaders和HttpStatus。 123456789101112131415161718192021222324252627282930313233343536/** *第二种文件下载的方式：使用SpringMVC提供的esponseEntity类型 * @param filename 下载的文件的名字，通过前端页面的请求参数带过来后SpringMVC会自动注入 * @param request * @return * @throws IOException */@RequestMapping(value = "/download2",method = RequestMethod.GET)public ResponseEntity&lt;byte[]&gt; download(String filename, HttpServletRequest request) throws IOException &#123; System.out.println(filename); //得到文件在服务器上的真实物理路径 String filePath = request.getServletContext().getRealPath("/download/" + filename); /** * 两个把下载文件转成byte[]的办法：一种是把要下载的文件封装成一个File对象，把这个对象交给FileCopyUtils.copyToByteArray(file) */ File file = new File(filePath); /** * 另一种方法是：自己写一个转换的方法，如下 */ /*FileInputStream fis = new FileInputStream(filePath); byte[] file = new byte[fis.available()]; fis.read(); fis.close();*/ String downFileName = new String(filename.getBytes("utf-8"), "iso-8859-1"); HttpHeaders headers = new HttpHeaders(); //这是文件下载关键:设置contentDisposition为attachment headers.setContentDispositionFormData("attachment", downFileName); headers.setContentType(MediaType.APPLICATION_OCTET_STREAM); return new ResponseEntity&lt;byte[]&gt;(FileCopyUtils.copyToByteArray(file), headers, HttpStatus.OK);&#125; 下载页面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%pageContext.setAttribute("ctp",request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;下载高清图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;高清壁纸下载&lt;/h2&gt;&lt;table&gt;&lt;tr&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/18.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=18.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=18.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/13.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=13.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=13.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/14.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=14.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=14.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/15.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=15.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=15.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/16.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=16.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=16.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt; &lt;th&gt; &lt;img src="../..$&#123;ctp&#125;/download/17.jpg" width="420px" height="320px"&gt;&lt;br/&gt; &lt;button&gt;&lt;a href="download1?filename=17.jpg"&gt;使用Servlet API下载&lt;/a&gt;&lt;/button&gt; &lt;button&gt;&lt;a href="download2?filename=17.jpg"&gt;使用SpringMVC框架下载&lt;/a&gt;&lt;/button&gt; &lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 测试结果 文件上传文件上传这里使用的是commons-fileupload-1.4,他需要依赖commons-io,他们的Maven依赖如下： 12345678910111213&lt;!--文件上传--&gt;&lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 1. 单文件上传上传表单页面文件上传需要将表单的提交方法设置为post，将enctype的值设置为”multipart/form-data”。 1234567&lt;!--单文件上传--&gt;&lt;h3&gt;单文件上传&lt;/h3&gt;&lt;form action="$&#123;ctp&#125;/uploadImg" method="post" enctype="multipart/form-data"&gt; 头像： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt; 控制器在Controller的处理方法中，使用MultipartFile对象作为参数接收前端上传过来的文件 12345678910111213141516171819202122232425262728293031323334353637383940//单个文件上传@RequestMapping("/uploadImg")public String ImgUpload( @RequestParam("username") String userName, @RequestParam("headerImg") MultipartFile file, HttpServletRequest request, Model model) &#123; String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date()); try &#123; //得到服务器上传文件的文件夹物理路径 String realPath = request.getServletContext().getRealPath("/upload/"); File dir=new File(realPath+date+"//"); if(!dir.exists())&#123; boolean res=dir.mkdir(); if(!res)&#123; model.addAttribute("msg", "文件上传失败！请重试！"); return null; &#125; &#125; //解析文件后缀名 String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf("."), fileName.length()); if(".jpg".equals(suffix)||".png".equals(suffix)||".gif".equals(suffix)||".jpeg".equals(suffix)||"bmp".equals(suffix)) &#123; //给上传的文件重新命名 File newFileName = new File(dir.toString() + "//" + System.currentTimeMillis() + suffix); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute("msg", "文件上传成功！"); &#125;else&#123; model.addAttribute("msg","文件上传失败！只支持jpeg, jpg, png, gif, bmp 格式的图片文件"); &#125; &#125; catch (Exception e) &#123; model.addAttribute("msg", "文件上传失败！"); &#125; return "fileUpLoad";&#125; 在springmvc配置文件中注册文件上传组件使用MultipartFile对象接收前端上传过来的文件，还需要在springmvc的配置文件中进行如下配置： 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;!--文件上传解析器的id是固定的，必须是multipartResolver--&gt;&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!--上传的文件总大小50M--&gt; &lt;property name="maxUploadSize" value="#&#123;1024*1024*50&#125;"/&gt; &lt;!--单个文件最大5M--&gt; &lt;property name="maxUploadSizePerFile" value="#&#123;1024*1024*5&#125;"/&gt; &lt;!--默认的字符编码：utf-8--&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt;&lt;/bean&gt;&lt;/beans&gt; 多文件上传其实多文件上传也很简单，单文件上传是在Controller的处理方法中使用MultipartFile对象作为参数接收前端上传过来的文件，而多文件上传则使用MultipartFile对象数组来接收。 页面该页面中有几个name值一样的file类型的input标签，其他跟单文件上传的页面没区别。 123456789&lt;h3&gt;一次选一个文件，一次提交上传多个文件&lt;/h3&gt;&lt;form action="$&#123;ctp&#125;/upload2" method="post" enctype="multipart/form-data"&gt; 头像： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; 图片： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; 资料： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; 文件： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt; 控制器 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Controllerpublic class FileUpLoadController &#123;@RequestMapping("/upload2")public String upload(@RequestParam("username") String userName, @RequestParam("headerImg") MultipartFile[] files, HttpServletRequest request, Model model) &#123; String realPath = request.getServletContext().getRealPath("/upload/"); File dir = new File(realPath + date +"//"+userName+"//"); if (!dir.exists()) &#123; boolean res = dir.mkdirs(); if (!res) &#123; model.addAttribute("msg", "文件上传失败！请重试！"); return null; &#125; &#125; for (MultipartFile file : files) &#123; uploadFile(dir.toString(), file, model); &#125; return "fileUpLoad";&#125;public void uploadFile(String path, MultipartFile file, Model model) &#123; try &#123; if (!file.isEmpty()) &#123; String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf("."), fileName.length()); //给上传的文件重新命名 File newFileName = new File(path + "//" + System.currentTimeMillis() + suffix); System.out.println(newFileName); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute("msg", "文件上传成功！"); &#125; &#125; catch (Exception e) &#123; model.addAttribute("msg", "文件上传失败！" + e); &#125;&#125;&#125; 同样的，使用MultipartFile数组接收前端上传过来的多个文件，也需要在springmvc的配置文件进行配置，具体配置与上述单文件上传的springmvc.xml配置没差别。这样，就可以进行多文件上传了。 多种文件上传情景综合当然，项目开发中，场景可能并不是这么简单，上述的多文件上传是一个个文件选择后一起上传（即多个name相同的input标签），那要是我项目中只要一个input标签就可以一次性多个文件呢？又或者一个页面中既要一个个选择的多文件上传，又要一次性选择的多文件上传，还要有单文件上传呢？没问题，MultipartFile[]通吃，代码也很easy，下面直接上代码。 页面 1234567891011121314151617181920212223242526&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% pageContext.setAttribute("ctp",request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;ctp&#125;/upload3" method="post" enctype="multipart/form-data"&gt; &lt;!--一次选择一个文件的多文件上传--&gt; 头像： &lt;input type="file" name="headerImg"/&gt;&lt;br/&gt; &lt;!--一次选择一个文件的多文件上传 --&gt; &lt;input type="file" name="img"/&gt;&lt;br/&gt; &lt;input type="file" name="img"/&gt;&lt;br/&gt; &lt;input type="file" name="img"/&gt;&lt;br/&gt; &lt;!--一次选多个文件的多文件上传 --&gt; 图片：&lt;input type="file" name="pic" multiple/&gt;&lt;br/&gt; 用户名：&lt;input type="text" name="username"/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;br/&gt;&lt;/form&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 控制器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RequestMapping("/upload3")public String upload(@RequestParam("username") String userName, @RequestParam("headerImg") MultipartFile[] files1, @RequestParam("img") MultipartFile[] files2, @RequestParam("pic") MultipartFile[] files3, HttpServletRequest request, Model model) &#123; String realPath = request.getServletContext().getRealPath("/upload/"); File dir = new File(realPath + date +"//"+userName+"//"); if (!dir.exists()) &#123; boolean res = dir.mkdirs(); if (!res) &#123; model.addAttribute("msg", "文件上传失败！请重试！"); return null; &#125; &#125; for (MultipartFile file : files1) &#123; uploadFile(dir.toString(), file, model); &#125; for (MultipartFile file : files2) &#123; uploadFile(dir.toString(), file, model); &#125; for (MultipartFile file : files3) &#123; uploadFile(dir.toString(), file, model); &#125; return "fileUpLoad";&#125;public void uploadFile(String path, MultipartFile file, Model model) &#123; try &#123; if (!file.isEmpty()) &#123; String fileName = file.getOriginalFilename(); String suffix = fileName.substring(fileName.lastIndexOf("."), fileName.length()); //给上传的文件重新命名 File newFileName = new File(path + "//" + System.currentTimeMillis() + suffix); System.out.println(newFileName); //保存文件到服务器 file.transferTo(newFileName); model.addAttribute("msg", "文件上传成功！"); &#125; &#125; catch (Exception e) &#123; model.addAttribute("msg", "文件上传失败！" + e); &#125;&#125; 测试结果 MultipartFile[]就是如此强大，不管单个多个，逻辑处理一样，所以建议在项目开发中使用MultipartFile[]作为文件的接收参数。 拓展1、MutipartFile类的一些常用方法： String getContentType() //获取文件MIME类型 InputStream getInputStream() //获取文件流 String getName() //获取表单中文件组件的名字 String getOriginalFilename() //获取上传文件的原名 long getSize() //获取文件的字节大小，单位byte boolean isEmpty() //是否为空 void transferTo(File dest) //保存文件到服务器指定路径 2、CommonsMultipartResolver的属性解析 defaultEncoding：表示用来解析request请求的默认编码格式，当没有指定的时候根据Servlet规范会使用默认值ISO-8859-1。当request自己指明了它的编码格式的时候就会忽略这里指定的defaultEncoding。 uploadTempDir：设置上传文件时的临时目录，默认是Servlet容器的临时目录。 maxUploadSize：设置允许上传的总的最大文件大小，以字节为单位计算。当设为-1时表示无限制，默认是-1。 maxUploadSizePerFile：跟maxUploadSize差不多，不过maxUploadSizePerFile是限制每个上传文件的大小，而maxUploadSize是限制总的上传文件大小。 maxInMemorySize：设置在文件上传时允许写到内存中的最大值，以字节为单位计算，默认是10240。 resolveLazily：为true时，启用推迟文件解析，以便在UploadAction中捕获文件大小异常。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC对Ajax异步请求的支持]]></title>
    <url>%2F2019%2F08%2F11%2FSpringMVC%E5%AF%B9Ajax%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E7%9A%84%E6%94%AF%E6%8C%81%2F</url>
    <content type="text"><![CDATA[Ajax异步请求概念AJAX: Ansyc Javascript And Xml (异步请求).异步是指基于Ajax的应用与服务器通信的方法。对于传统的Web应用，每次用户发送请求或向服务器请求获得新数据时，浏览器都会完全丢弃当前页面，而等待重新加载的页面。在服务器完全响应之前，用户浏览器将是一片空白，用户的动作必须中断。异步是指用户发送请求后，完全无须等待，请求在后台发送，不会阻塞用户的当前活动，用户无须等待第一次请求得到完全响应，就可以立即发送第二次请求。简单的说,异步请求不会刷新当前html页面。异步指的是服务器端响应数据的获取方式。 同步： 异步： 异步&amp;同步的区别1.同步请求： 请求的过程：浏览器(当前的html页面会丢弃) —&gt; http协议 —&gt; Web服务器(tomcat) 响应的过程：Web服务器(tomcat) —&gt; http协议 –&gt; 返回一个新html页面. 2.异步请求： 请求的过程：浏览器(当前的html页面不会丢弃) —&gt; Ajax引擎(http协议) —&gt; Web服务器(tomcat) 响应的过程：Web服务器(tomcat) —&gt; 准备部分数据 –&gt; Ajax引擎(http协议) –&gt; DOM编程. 总而言之，异步请求只是局部刷新页面，同步请求会全部刷新当前的页面 jQuery框架的异步请求和处理1.$.ajax([settings]) —jQuery核心处理异步请求的方法：语法： $.ajax([settings]) 最简单的情况下，$.ajax() 可以不带任何参数直接使用。具体语法格式都有哪些参数请参照：https://www.w3school.com.cn/jquery/ajax_ajax.asp 2.$.post() $.post() 方法通过 HTTP POST 请求从服务器上请求数据。语法： $.post(url, data, function(data, status){// status(状态码): success 、error// data : 响应数据}, dataType); 必需的 URL 参数规定您希望请求的 URL。可选的 data 参数规定连同请求发送的数据。可选的 function 参数是请求成功后所执行的函数名,其中data是响应的数据，status是状态码可选的dataType参数是服务器响应返回的数据 3.$.get() $.get() 方法通过 HTTP GET 请求从服务器上请求数据。 $.get(url, data, function(data, status){// status(状态码): success 、error// data : 响应数据}, dataType); 必需的 URL 参数规定您希望请求的 URL。可选的 data 参数规定连同请求发送的数据。可选的 function 参数是请求成功后所执行的函数名,其中data是响应的数据，status是状态码可选的dataType参数是服务器响应返回的数据 springMVC支持ajax异步请求和处理返回json数据数据绑定@RequestBody/@ResponseBody&lt;/font size=4&gt;@RequestBody&nbsp;&nbsp;&nbsp;&nbsp;功能 ：用于将HttpServletRequest的getInputStream()的内容绑定到方法入参例如： @RequestMapping(value = “/hello”) public String handleRequest(@RequestBody String body){ //body参数就被请求参数自动绑定} &lt;/font size=4&gt;@ResponseBody&nbsp;&nbsp;&nbsp;&nbsp;功能：被ResponseBody修饰的方法的返回值会被作为响应体 @RequestMapping(value = “/hello”)@ResponseBody public User handleRequest(Ueser user){ return User; //返回值会被作为响应体，而且如果返回值是对象时SpringMVC会自动转换成JSON给页面} 使用@RequestBody/@ResponseBody来支持Ajax可以使用@RequestBody来自动获取Ajax上传的数据，同时也可以使用@ResponseBody，把要返回的对象自动拼成JSON的格式返回。当然，需要加入几个jackson的包，这里加入了：jackson-core-2.9.3.jar、jackson-annotations-2.9.3.jar、jackson-databind-2.9.3.jar，Maven依赖如下： 12345678910111213141516171819 &lt;!--jackson的三个依赖包--&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt; Controller 123456789101112131415161718192021222324252627282930313233343536373839 /** * ResponseBody:用于将ResponseBody方法的返回值作为响应体 * RequestBody:用于将HttpServletRequest的getInputStream()内容绑定到入参 * * @param users * @return */@ResponseBody@RequestMapping(value = "/getAllUserByAJAX", produces = "application/json;charset=UTF-8")public List&lt;User&gt; getAllUserByAJAX(@ModelAttribute("users") List&lt;User&gt; users) &#123; return users;&#125;/** * RequestBody：将请求体的数据绑定到入参 * * @param user * @return */@ResponseBody@RequestMapping("/testRequestBody")public User testRequestBody(@RequestBody User user, Model model) &#123; System.out.println("请求的数据："+user); model.addAttribute("requestInfo", user); return user;&#125;/** * 提前把全部信息查询好放在隐含模型中 * @param model */@ModelAttribute("users")public void getAll(Model model) &#123; IUserService userService = new IUserServiceImpl(); List&lt;User&gt; lists = userService.getUser(null, null, null); model.addAttribute("users", lists);&#125; 1. 通过AJAX获得服务器数据的页面： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page import="java.util.Date" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% pageContext.setAttribute("ctp", request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;ajax&lt;/title&gt;&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $().ready(function () &#123; $("#first").click(function () &#123; alert("adacd"); $.ajax(&#123; url: "$&#123;ctp&#125;/getAllUserByAJAX", type: "GET", success: function (data) &#123; //console.log(data) $.each(data, function () &#123; var userInfo = this.name + "---" + this.age + "---" + this.email; $("#user").append(userInfo + "&lt;br/&gt;"); &#125;) &#125; &#125;); return false; &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;%=new Date()%&gt;&lt;div id="user"&gt;&lt;/div&gt;&lt;a id="first" href="$&#123;ctp&#125;/getAllUserByAJAX"&gt;获取全部用户信息&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 测试结果 2. 通过AJAX向服务器发JSON数据，服务器返回JSON数据 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% pageContext.setAttribute("ctp", request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;script src="https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;$().ready(function () &#123; $("#first").click(function () &#123; //点击发送JSON数据给服务器 $.ajax(&#123; url: "$&#123;ctp&#125;/testRequestBody", type: "POST", contentType:"application/json", //请求的文本格式：json data: JSON.stringify(&#123;name: $("#username").val(), age: $("#userage").val(), email: $("#userEmail").val()&#125;), //给服务器提交的数据 dataType: "json", //服务器返回的数据类型 success: function (data) &#123; var userInfo = data.name + "---" + data.age + "---" + data.email; $("#users").append(userInfo + "&lt;br/&gt;"); &#125; &#125;); return false; &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="$&#123;ctp&#125;/testRequestBody" method="post"&gt;&lt;input id="username" name="username" type="text"/&gt;&lt;input id="userage" name="age" type="text"/&gt;&lt;input id="userEmail" name="enail" type="email"/&gt;&lt;/form&gt;&lt;button type="button"&gt;&lt;a id="first" href="$&#123;ctp&#125;/testRequestBody"&gt;AJAX发送JSON数据给服务器&lt;/a&gt;&lt;/button&gt;&lt;div id="users"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 测试结果]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 数据绑定、数据格式化、数据校验]]></title>
    <url>%2F2019%2F08%2F09%2FSpringMVC%20%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E3%80%81%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[数据绑定流程 Spring MVC将ServletRequest对象及目标方法的入参实例传给WebDataBinderFactory实例，创建出DataBinder(数据绑定的核心部件) DataBinder调用转配在SpringMVC上下文中的ConversionService组件进行数据类型转换、数据格式化。并将servlet中的请求信息填充到入参对象中 调用Validator组件对已经绑定好的请求消息的入参进行数据合法性校验，并最终生成数据绑定结果BindingResult对象 Spring MVC抽取BindingResult中的入参对象和检验错误对象，将他们赋给处理方法的响应入参 Spring MVC通过反射机制对目标方法进行解析，将请求消息绑定到处理方法的入参中。 数据转换2.1 ConversionService Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作。 Spring3.0 添加了一个通用的类型转换模块，位于 org.springframework.core.convert 包中 ConversionService 接口是类型转换的核心接口 Modifier and Type Method and Description boolean canConvert(Class sourceType, Class targetType)判断是否可以将一个 java 类转换为另一个 java 类 boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) 需转换的类将以成员变量的方式出现在宿主类中，TypeDescriptor 不但描述了需转换类的信息，还描述了从宿主类的上下文信息，如成员变量 上的注解，成员是否是数组、集合或 Map 的方式呈现等 &lt;T&gt;&nbsp;T convert(Object source, Class&lt;T&gt; targetType) 将原类型对象转换为目标类型对象. Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) 将对象从原类型对象转换为目标类型对象，此时往往会用到所在宿主类的上下文信息 2.2 自定义类型转换器Spring 在 org.springframework.core.convert.converter 包中定义了 3 种类型转换器接口，实现任意一个转换器接口都可以作为自定义转换器注册到 ConversionServiceFactroyBean 中： Converter&lt;S,T&gt;：将S类型对象转换为T类型对象 ConverterFactory：将相同系列多个Converter封装在一起.如果希望将一种类型的对象转换为另一种类型及其子类的对象（例如将 String 转换为 Number 及Number 子类（Integer、Long、Double 等）对象）可使用该转换器工厂类 GenericConverter：会根据源类对象及目标类对象所在的宿主类找那个的上下文信息进行类型转换 ConverstionServiceFactoryBean 的 converters 属性可以接受 Converter、ConverterFactory、GenericConverter 或 ConditionalGenericConverter 接口的实现类，并把这些转换器的转换逻辑统一封装到一个 ConverstionService 实例对象中(GenericConversionService),Spring 在 Bean属性配置及 Spring MVC 请求消息绑定时将利用这个 ConversionService 实例完成类型转换工作。 实际应用中常用的是Converter&lt;S,T&gt;，下面通过他实现一个自定义的类型转换器：关键步骤： 实现Converter接口，他有两个泛型，S:是转换前的了类型，T:是转换后的类型 ，实现Converter接口的conver方法，在方法中定制对S类型如何转换换成T类型的规则 在springmvc配置文件中将自定义的Converter配置在ConversionService中 告诉SpringMVC使用我们自定义的类型转换器 假设处理方法有一个 User 类型的入参，我们希望将一个格式化的请求字符串直接转为 User对象，该字符串格式如（小明:男:软件工程:软工3306班:1134556） 编写自定义类型转换器 1234567891011121314151617181920212223package com.xzy.converter;import com.xzy.bean.Student;import org.springframework.core.convert.converter.Converter;public class StringToStudentConverter implements Converter&lt;String, Student&gt; &#123; //在这个方法中定义转换的规则 @Override public Student convert(String param) &#123; Student student = new Student(); //param==&gt;小明:男:软件工程:软工3306班:17033309 if (null != param &amp;&amp; !"".equals(param)) &#123; String[] pa=param.split(":"); student.setName(pa[0]); student.setGender(pa[1]); student.setSclass(pa[2]); student.setMajor(pa[3]); student.setSid(pa[4]); &#125; return student; &#125;&#125; 在SpringMVC配置文件中将自定义的Converter方在IOC容器中交给Spring管理 1234567891011&lt;!--该 标 签 会 创 建 并 注 册 一 个 默 认 的 DefaultAnnotationHandlerMapping 和一个ReqeustMappingHandlerAdpter实现，除此之外&lt;mvc:annotaion-driven/&gt;标签还会注册一个默认的ConversionService（FormattingConversionServiceFactoryBean）以满足大多数类型转换 的需求 ，当用到自定义类型转换器时，需要用&lt;mvc:annotation-driven conversion-service=”xxx”/&gt;覆盖默认--&gt;&lt;!--配置自定义的类型转换器--&gt;&lt;bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="com.xzy.converter.StringToStudentConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 用&lt;mvc:annotation-driven conversion-service=”xxx”/&gt;覆盖默认的类型转换器 12&lt;!--在&lt;mvc:annotation-driver中配置conversion-service覆盖默认的转换器&gt;--&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt; 控制器： 123456789101112131415161718package com.xzy.contorller;import com.xzy.bean.Student;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class StudentController &#123; @RequestMapping("/addStudent") public String addStudent(@RequestParam("stuInfo") Student student, Model model) &#123; System.out.println("封装的" + student); model.addAttribute("stuinfo",student); return "success"; &#125;&#125; 测试结果： 数据格式化Spring 使用转换器进行源类型对象到目标类型对象的转换，Spring 的转换不提供输入及输出信息格式化工作，像日期、时间、数字、货币等数据都具有一定格式的，在不同的本地化环境中，同一类型的数还会相应地呈现不同的显示格式。如何从格式化的数据中获取真正的数据以完成数据绑定，并将处理完成的数据输出为格式化的数据，是 spring 格式化框架要解决的问题，Spring 引入了一个新的格式化框架，这个框架位于 org.springframework.format 类包中，其中最重要的一个接口 FormatterSpring 的 org.springframework.format.datetime 包中提供了一个用于时间对象格式化的DateFormatter 实现类，而 org.springframework.format.number 包中提供了 3 个用于数字对象格式化的实现类。 NumberFormatter:用于数字类型对象的格式化 CurrencyFormatter:用于货币类型对象的格式化 PercentFormatter: 用于百分数数字类型对象的格式化 示例：有一个员工类employee.java 1234567891011121314151617181920212223242526272829303132package com.xzy.bean;import org.springframework.format.annotation.DateTimeFormat;import org.springframework.format.annotation.NumberFormat;import java.math.BigDecimal;import java.util.Date;public class employee &#123; private String mame; @DateTimeFormat(pattern = "yyyy-MM-dd") private Date birth; //生日 //表示3位一个逗号，保留两位小数 @NumberFormat(pattern = "#,###.##") private Double salary; //薪水 //省略getter、setter @Override public String toString() &#123; return "employee&#123;" + "mame='" + mame + '\'' + ", birth=" + birth + ", salary=" + salary + '&#125;'; &#125;&#125; 要使注解可以发挥作用还需要在注解中配置如下信息： 12345678&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;bean class="com.xzy.converter.StringToStudentConverter"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; &nbsp;&nbsp;&nbsp;&nbsp;对属性对象的输入/输出进行格式化，从其本质上讲依然属于 “类型转换” 的范畴。Spring 在格式化模块中定义了一个实现 ConversionService 接口的FormattingConversionService 实现类，该实现类扩展了GenericConversionService，因此它既具有类型转换的功能，又具有格式化的功能。&nbsp;&nbsp;&nbsp;&nbsp;FormattingConversionService 拥有FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者FormattingConversionServiceFactroyBean 内部已经注册了 :NumberFormatAnnotationFormatterFactroy：支持对数字类型的属性使用 @NumberFormat 注解JodaDateTimeFormatAnnotationFormatterFactroy：支持对日期类型的属性使用 @DateTimeFormat 注解装配了 FormattingConversionServiceFactroyBean 后，就可 以在 Spring MVC 入参绑定及模型数据输出时使用注解驱动了。&lt;mvc:annotation-driven/&gt;默认创建的ConversionService 实例即为 FormattingConversionServiceFactroyBean. 数据校验应用程序在执行业务逻辑前，必须通过数据校验保证接收到的输入数据是正确合法的，如代表生日的日期应该是一个过去的时间、工资的数值必须是一个整数等。一般情况下，应用程序的开发时分层的，不同层的代码由不同的开发人员负责。很多时候，同样的数据验证会出现在不同的层中，这样就会导致代码冗余，违反了DRY原则。为了避免这样的情况，最好将验证逻辑和响应的域模型进行绑定，将代码验证的逻辑集中起来管理。 JSR-303 JSR-303是Java为Bean数据合法校验锁提供的标准框架，它已经包含在JavaEE 6.0中。JSR-303通过在Bean属性上标注类似于@NotNull、@Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。可以通过http://jcp.org/en/jsr/detail?id=303了解更多详细内容。JSR-303定义了一套可标注在成员变量、属性方法上的校验注解： JSR-303 支持 XML 风格的和注解风格的验证，接下来我们首先看一下如何和 Spring 集成。 1. 导入jar包,此处使用 Hibernate-validator 实现（版本：hibernate-validator-6.0.17.Final-dist.zip），他的Maven依赖如下： 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.17.Final&lt;/version&gt;&lt;/dependency&gt; 在Spring配置中添加JSR-303验证框架支持 1234&lt;!--配置对JSR-303的支持--&gt;&lt;bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt; &lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator"/&gt;&lt;/bean&gt; 通过 ConfigurableWebBindingInitializer 注册 validator 12345&lt;!--注册validator--&gt;&lt;bean id="webBinding" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt; &lt;property name="conversionService" ref="conversionService"/&gt; &lt;property name="validator" ref="validator"/&gt;&lt;/bean&gt; 使用 JSR-303 验证框架注解为模型对象指定验证信息 123456789101112131415161718192021222324252627282930313233343536 package com.xzy.bean;import javax.validation.constraints.*;public class Student &#123;@NotEmptyprivate String name;@Size(min = 7,max=10)private String sid; //学号@Pattern(regexp = "/^(0|86|17951)?(13[0-9]|15[012356789]|166|17[3678]|18[0-9]|14[57])[0-9]&#123;8&#125;$/")private String phone; //手机号码@NotBlankprivate String sclass;@NotEmptyprivate String major; //省略getter、setter @Overridepublic String toString() &#123; return "Student&#123;" + "姓名：'" + name + '\'' + ", 学号：'" + sid + '\'' + ", 手机：'" +phone + '\'' + ", 班级：'" + sclass + '\'' + ", 专业：'" + major + '\'' + '&#125;'; &#125;&#125; 控制器 123456789101112131415161718192021222324252627//@Vaild就是告诉SpringMVC 把数据绑定好后要根据Bean里面的校验规则校验@RequestMapping(value = "/addStudent", method = RequestMethod.POST)public String addStudent2( @Valid @ModelAttribute Student student, Errors error, Model model) &#123; logger.info(student); model.addAttribute("student", student); if (error.hasErrors()) &#123; System.out.println(error); logger.error(error); return "add"; //如果有错误，就返回填写页面重新填写 &#125; return "success";&#125;@RequestMapping(value="/&#123;formName&#125;")public String loginForm( @PathVariable String formName, Model model)&#123; System.out.println(formName); Student student= new Student(); model.addAttribute("student",student); // 动态跳转页面 return formName;&#125; 通过在命令对象上注解@Valid 来告诉 Spring MVC 此命令对象在绑定完毕后需要进行 JSR-303验证，如果验证失败会将错误信息添加到 Errors 错误对象中。 验证失败后回到填写表单的页面（/WEB-INF/jsp/pages/add.jsp）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %&gt;&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form modelAttribute="student" method="post" action="addStudent.htm"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;&lt;form:input path="name"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path="name" cssStyle="color:red"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;学号:&lt;/td&gt; &lt;td&gt;&lt;form:input path="sid"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path="sid" cssStyle="color:red"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;手机:&lt;/td&gt; &lt;td&gt;&lt;form:input path="phone"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path="phone" cssStyle="color:red"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;班级:&lt;/td&gt; &lt;td&gt;&lt;form:input path="sclass"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path="sclass" cssStyle="color:red"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;专业:&lt;/td&gt; &lt;td&gt;&lt;form:input path="major"/&gt;&lt;/td&gt; &lt;td&gt;&lt;form:errors path="major" cssStyle="color:red"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="submit" value="提交"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： 自定义国际化错误消息提示在上面的程序中有一个不好的地方，错误消息不是 我们自定义的，而且都是英文的，下面我们来看看如何在通过国际化配置文件实现自定义国际化错误消息提示。使用 System.out.println(&quot;错误码：&quot;+fieldError.getCodes());可以得到错误的错误码，每种错误都定义了4中错误码，如下： 他们从上到下所包含的范围由小到大，我们在写国际化配置文件的时候，每条配置的key必须是4个code中的一个code。 error_en_US.properties 12345NotBlank.student.name=name must not be emptySize.student.sid=the length must between &#123;2&#125; and &#123;1&#125;Pattern.student.phone=please write a right phone numberNotBlank.student.sclass=class must not be emptyNotEmpty.student.major=major must not be empty error_zh_CN.properties 12345NotBlank.student.name=姓名不能为空!Size.student.sid=长度应该在&#123;2&#125;和&#123;1&#125;之间!Pattern.student.phone=请填写正确的手机号码!NotBlank.student.sclass=班级不能为空!NotEmpty.student.major=专业不能为空! 在springmvc.xml文件中配置国际化资源： 123456789101112131415161718&lt;!--配置国际化资源--&gt; &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt; &lt;property name="basenames" value="error"/&gt; &lt;!-- &lt;property name="basenames" value="message"/&gt;--&gt; &lt;property name="useCodeAsDefaultMessage" value="false"/&gt; &lt;property name="cacheSeconds" value="0"/&gt; &lt;!--配置字符编码为UTF-8：注意properties的编码格式也应该是UTF-8的，否者即使你设置了字符编码过滤器也会乱码--&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;/bean&gt; &lt;!-- 主要用于获取请求中的locale信息，将其转为Locale对像，获取LocaleResolver对象--&gt; &lt;mvc:interceptors&gt; &lt;bean id="localeChangeInterceptor" class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt; &lt;/mvc:interceptors&gt; &lt;!-- 配置SessionLocaleResolver用于将Locale对象存储于Session中供后续使用 --&gt; &lt;bean id="SessionLocaleResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/&gt; 测试结果：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC自定义视图和视图解析器]]></title>
    <url>%2F2019%2F08%2F08%2FSpringMVC%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[自定义视图解析器：123456789101112131415161718192021222324252627282930313233343536package com.xzy.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;/** * 自定义视图解析器 */public class MyViewResolver implements ViewResolver, Ordered &#123; private int order = 0; @Overridepublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; if (viewName.startsWith("my:")) &#123; //返回自定义的视图对象 return new MyView(); &#125; else &#123; //不能处理就不要强行处理了，返回null让别的视图处理器来处理 return null; &#125; &#125;@Overridepublic int getOrder() &#123; return order;&#125;public void setOrder(int order) &#123; this.order = order; &#125;&#125; 自定义视图：1234567891011121314151617181920212223242526272829303132333435363738package com.xzy.view;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.PrintWriter;import java.util.List;import java.util.Map;/** * 自定义视图 */public class MyView implements View &#123; //返回的文本类型：text/html @Override public String getContentType() &#123; return "text/html"; &#125; // 渲染视图:在这个方法中写你对这个视图的渲染效果 @Override public void render(Map&lt;String, ?&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println("方法中保存的数据：" + map); httpServletResponse.setContentType("text/html"); PrintWriter out = httpServletResponse.getWriter(); out.write("&lt;h3&gt;精彩内容即将呈现...Loading&lt;/h3&gt;"); List&lt;Object&gt; lists= (List&lt;Object&gt;) map.get("video"); out.write("&lt;ul&gt;"); for(Object object:lists)&#123; out.write("&lt;li&gt;&lt;a href='download'&gt;"+object+"&lt;/a&gt;&lt;/li&gt;"); &#125; out.write("&lt;/ul&gt;"); &#125;&#125; 好了，现在视图处理和视图都定义好，这样我们的视图解析器就可以工作了吗？非也！虽然我们实现了ViewRelover接口.但是对于SpringMVC来说他就是一个普通的java类，SpringMVC如何知道去哪里调用我们的视图解析器呢?解决的方法是：在springmvc配置文件中配置我们的视图解析器，交给Spring IOC容器管理。 1234567&lt;!--配置自定义的视图解析器: springmvc中视图解析器得到视图时优先级高的会先去尝试解析，order的数值越小，优先级越高 自定义的视图解析器需要实现Orderd接口，默认的视图解析器InternalResourceViewResolver的优先级最低 --&gt; &lt;bean class="com.xzy.view.MyViewResolver"&gt; &lt;property name="order" value="0"/&gt; &lt;/bean&gt; 注意：自定义的视图解析器必须要实现ordered接口，以给我们自定义的视图解析器指定优先级，优先级的规则是值越小，优先级高；SpringMVC默认的视图解析器InternalResourceViewResolver的优先级是最低的。 编写控制器123456789101112131415161718192021222324package com.xzy.contorller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import java.util.ArrayList;import java.util.List;@Controllerpublic class MyViewController &#123; @RequestMapping("/viewhandler") public String myViewTest(Model model)&#123; List&lt;String&gt; vnames=new ArrayList&lt;String&gt;(); vnames.add("java疯狂讲义300集"); vnames.add("java从入门到如入土！！！"); vnames.add("Spring,SpringMVC从入门到放弃！！！"); vnames.add("MySql从删库到跑路！！！"); model.addAttribute("video",vnames); return "my:/hello"; &#125;&#125; 测试结果：总结自定义视图处理器和视图的步骤： 编写视图处理器（实现ViewReslover接口的resolveViewName方法）和视图（实现View接口的两个方法：getContentType()、render()） 视图解析器必须放在IOC容器中 视图处理器除了要实现ViewReslover接口，还应该实现ordered接口，已给我们定义的视图解析器指定优先级，这个很关键.]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC视图解析]]></title>
    <url>%2F2019%2F08%2F07%2FSpringMVC%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[SpringMVC视图解析 &nbsp; &nbsp; &nbsp;对于控制器的目标方法，无论其返回值是String、View、ModelMap或是ModelAndView，SpringMVC都会在内部将它们封装为一个ModelAndView对象进行返回。 &nbsp; &nbsp; &nbsp; Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是JSP也可是Excell、 JFreeChart等各种表现形式的视图。 视图（View） 视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户。 为了实现视图模型和具体实现技术的解耦，Spring在org.springframework.web.servlet包中定义了一个高度抽象的View接口。 视图对象由视图解析器负责实例化。由于视图是无状态的，所以他们不会有线程安全的问题。所谓视图是无状态的，是指对于每一个请求，都会创建一个View对象。 JSP是最常见的视图技术。 视图解析器（ViewResolver）和视图（View） springMVC用于处理视图最重要的两个接口是ViewResolver和View。 所以视图解析器的作用就是通过视图名（处理方法的返回值）生成View对象，所有的视图解析器都必须实现ViewResolver接口。 SpringMVC为逻辑视图名的解析提供了不同的策略，可以在Spring WEB上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。程序员可以选择一种视图解析器或混用多种视图解析器。可以通过order属性指定解析器的优先顺序，order越小优先级越高，SpringMVC会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则抛出ServletException异常。在项目中可以配置InternalResourceViewResolver作为视图解析器,在springmvc.xml中可以做如下配置： 12345&lt;!--配置视图解析器--&gt;&lt;bean id="viewHandler" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; forward: 和redirect:一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理，会经过视图解析器拼串，但如果返回的字符串中带forward:或redirect:前缀时，SpringMVC会对它们进行特殊处理：将forward: 和redirect: 当成指示符，其后的字符串作为URL 来处理。示例如下：index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href="handler1"&gt;handler1&lt;/a&gt;&lt;br/&gt; &lt;a href="handler2"&gt;handler2&lt;/a&gt;&lt;br/&gt; &lt;a href="handler3"&gt;handler3&lt;/a&gt;&lt;br/&gt; &lt;a href="handler4"&gt;handler4&lt;/a&gt;&lt;br/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; hello.jsp，在当前项目的根路径下，和index.html同级 1234567891011&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h1&gt;这是hello.jsp&lt;/h1&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; ViewTestController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xzy.Contorller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ViewTestController &#123; /** * handler1把请求转发到hello.jsp页面 * @return */ @RequestMapping("/handler1") public String handler1()&#123; System.out.println("handler1"); return "forward:/hello.jsp"; &#125; /** * handler把请求转发给handler1 * @return */ @RequestMapping("/handler2") public String handler2()&#123; System.out.println("handler2"); return "forward:handler1"; &#125; /** * 重定向到hello.jsp * @return */ @RequestMapping("/handler3") public String handler3()&#123; System.out.println("handler3"); return "redirect:/hello.jsp"; &#125; /** * 重定向到handler3 * @return */ @RequestMapping("/handler4") public String handler4()&#123; System.out.println("handler4"); return "redirect:handler3"; &#125;&#125; 测试结果: 按F12打开开发者工具，可以看到确实两次重定向 SpringMVC视图的解析流程(结合源码分析) 源码中把任何返回返回值封装为ModelAndView的实现：123456789101112131415161718192021222324 protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception &#123; this.checkRequest(request); ModelAndView mav; if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized(mutex) &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; mav = this.invokeHandlerMethod(request, response, handlerMethod); &#125; if(!response.containsHeader("Cache-Control")) &#123;if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; this.applyCacheSeconds(response,this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; this.prepareResponse(response); &#125; &#125; return mav; &#125; 这里以发出了一个GET请求为例：首先FrameworkServlet类会来处理这个GET请求doGet 123protected final void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.processRequest(request, response); &#125; processRequest 123456789101112131415protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //省略..... try &#123; //它本类中的这个方法是个抽象方法，实现这个方法的类是DispatcherServlet this.doService(request, response); &#125; catch (IOException | ServletException var16) &#123; failureCause = var16; throw var16; &#125; catch (Throwable var17) &#123; //省略.....var17); &#125; finally &#123; //省略..... &#125; &#125; DispatcherServlet 类doService方法 12345678910111213protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略..... //给request域中设置了一些东西 try &#123; //调用doDispatch方法处理 this.doDispatch(request, response); &#125; finally &#123; ...... &#125; &#125; doDispatch方法 12345protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... this.processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); //省略...... &#125; processDispatchResult方法,这个方法就是最终将数据交给页面的方法 12345678910111213141516171819202122232425 private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; //如果这里出现了异常就处理异常 if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123;this.logger.debug("ModelAndViewDefiningException encountered", exception); mv = ((ModelAndViewDefiningException)exception).getModelAndView(); &#125; else &#123; Object handler = mappedHandler != null ? mappedHandler.getHandler() : null; //如果自己配置了自定义的HandlerExceptionResolver将会在这个方法里处理 mv = this.processHandlerException(request, response, handler, exception); errorView = mv != null; &#125; &#125; if (mv != null &amp;&amp; !mv.wasCleared()) &#123; //调用render方法进行视图渲染 this.render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else if (this.logger.isTraceEnabled()) &#123; this.logger.trace("No view rendering, null ModelAndView returned."); &#125; //省略...... &#125; DispatcherServlet 类 的render方法并没有继承View接口的render,和View接口的render不是一回事，这个render仅仅是为了命名统一而起的一个名字 123456789101112131415161718192021222324252627protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; //省略...... //从ModelView中拿到视图名 String viewName = mv.getViewName(); View view; if (viewName != null) &#123; //这一步就是得到一个View对象，resolveViewName的实现看下边 view = this.resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + this.getServletName() + "'"); &#125; &#125; else &#123; view = mv.getView(); if (view == null) &#123; throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a View object in servlet with name '" + this.getServletName() + "'"); &#125; &#125; //省略...... try &#123; //省略...... //调用了View接口的render方法，这里实际上调用的是视图在渲染时会把Model传入 view.render(mv.getModelInternal(), request, response); &#125; catch (Exception var8) &#123; //省略...... &#125;&#125; resolveViewName方法，循环遍历你配置的视图解析器，viewResolvers是进过order排序的，这一步就是ViewResolvers是如何通过视图名产生View对象的关键 1234567891011protected View resolveViewName(String viewName,Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; //遍历我们配置的视图解析器 for (ViewResolver viewResolver : this.viewResolvers) &#123; //ViewResolver根据方法的返回值，得到一个View对象，这块又有一个resolveViewName，具体的实现请往下看 View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; return null;&#125; InternalResourceViewResolver继承了AbstractCachingViewResolver，resolveViewName方法首先会判断有没有缓存，要是有缓存，它会先去缓存中通过viewName查找是否有View对象的存在，要是没有，它会通过viewName创建一个新的View对象，并将View对象存入缓存中，这样再次遇到同样的视图名的时候就可以直接在缓存中取出View对象了 12345678910111213141516171819202122232425262728293031@Overridepublic View resolveViewName(String viewName, Locale locale) throws Exception &#123; //判断有缓存中有没有view对象，有就直接拿来用 if (!isCache()) &#123; return createView(viewName, locale); &#125; else &#123; Object cacheKey = getCacheKey(viewName, locale); View view = this.viewAccessCache.get(cacheKey); if (view == null) &#123; synchronized (this.viewCreationCache) &#123; view = this.viewCreationCache.get(cacheKey); if (view == null) &#123; //根据方法的返回值创建出View对象 view = createView(viewName, locale); if (view == null &amp;&amp; this.cacheUnresolved) &#123; view = UNRESOLVED_VIEW; &#125; if (view != null) &#123; this.viewAccessCache.put(cacheKey, view); this.viewCreationCache.put(cacheKey, view); if (logger.isTraceEnabled()) &#123; logger.trace("Cached view [" + cacheKey + "]"); &#125; &#125; &#125; &#125; &#125; return (view != UNRESOLVED_VIEW ? view : null); &#125;&#125; createView的实现细节： 12345678910111213141516171819202122232425protected View createView(String viewName, Locale locale) throws Exception &#123; if (!this.canHandle(viewName, locale)) &#123; return null; &#125; else &#123; String forwardUrl; //如果方法得到返回值是以redirect：开始的 if (viewName.startsWith("redirect:")) &#123; forwardUrl = viewName.substring("redirect:".length()); RedirectView view = new RedirectView(forwardUrl, this.isRedirectContextRelative(), this.isRedirectHttp10Compatible()); String[] hosts = this.getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return this.applyLifecycleMethods("redirect:", view); //如果方法的返回值是以forward:开始的 &#125; else if (viewName.startsWith("forward:")) &#123; forwardUrl = viewName.substring("forward:".length()); InternalResourceView view = new InternalResourceView(forwardUrl); return this.applyLifecycleMethods("forward:", view); &#125; else &#123; //其他情况的处理,这里又有一个createView，它调用了父类的createView创建了一个默认的View对象 return super.createView(viewName, locale); &#125; &#125;&#125; 以下都是解析视图名的实现细节，感兴趣的可以看一下。 父类AbstractCachingViewResolver类的createView实现细节： 123protected View createView(String viewName, Locale locale) throws Exception &#123; return loadView(viewName, locale);&#125; InternalResourceViewResolver继承了UrlBasedViewResolverUrlBasedViewResolver类中loadView方法的实现： 12345protected View loadView(String viewName, Locale locale) throws Exception &#123; AbstractUrlBasedView view = buildView(viewName); View result = applyLifecycleMethods(viewName, view); return (view.checkResource(locale) ? result : null); &#125; UrlBasedViewResolver的buildView方法会获取一个View对象，这个对象会将视图以什么格式呈现给用户，例如如果是jsp显示呈现给用户的话，那这个view对象就是JstlView，默认的是JstlView。在这个方法中我们看到了getPrefix() + viewName + getSuffix()这样一段代码，这就是对视图路径的一个拼接了，getPrefix()方法获取前缀，也就是我们在配置文件中配置的&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/PAGE/&quot;/&gt;的value中的值了,getSuffix()方法就是获取后缀值了，也就是我们在配置文件中配置的&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;的value中的值。这样就将将视图的物理路径找到了，并赋值到View的URL属性中去。 123456789101112131415161718192021222324252627protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; Class&lt;?&gt; viewClass = this.getViewClass(); Assert.state(viewClass != null, "No view class"); AbstractUrlBasedView view = (AbstractUrlBasedView)BeanUtils.instantiateClass(viewClass); view.setUrl(this.getPrefix() + viewName + this.getSuffix()); String contentType = this.getContentType(); if (contentType != null) &#123; view.setContentType(contentType); &#125; view.setRequestContextAttribute(this.getRequestContextAttribute()); view.setAttributesMap(this.getAttributesMap()); Boolean exposePathVariables = this.getExposePathVariables(); if (exposePathVariables != null) &#123; view.setExposePathVariables(exposePathVariables); &#125; Boolean exposeContextBeansAsAttributes = this.getExposeContextBeansAsAttributes(); if (exposeContextBeansAsAttributes != null) &#123; view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes); &#125; String[] exposedContextBeanNames = this.getExposedContextBeanNames(); if (exposedContextBeanNames != null) &#123; view.setExposedContextBeanNames(exposedContextBeanNames); &#125; return view;&#125; 就这样我们得到了一个View对象，这个视图的name就是逻辑视图名，因为当将View对象放在缓存的时候，我们可以通过逻辑视图名在缓存中找出View对象。我们在获取到View对象的时候，我们还要将View进行渲染，并呈现给用户。 View是个接口,AbstractView实现了render方法: 1234567891011public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug("View " + this.formatViewName() + ", model " + (model != null ? model : Collections.emptyMap()) + (this.staticAttributes.isEmpty() ? "" : ", static attributes " + this.staticAttributes)); &#125; //主要是将一些属性填充到Map中 Map&lt;String, Object&gt; mergedModel = this.createMergedOutputModel(model, request, response); //对response头进行了一些属性设置 this.prepareResponse(request, response); //渲染给页面输出的所有model数据 this.renderMergedOutputModel(mergedModel, this.getRequestToExpose(request), response);&#125; 最后一行的renderMergedOutputModel方法由AbstractView的孙子类InternalResourceView实现InternalResourceView的renderMergedOutputModel方法帮我们获取到视图的物理路径，然后将这段路径传给RequestDispatcher对象，再调用RequestDispatcher的forward方法将页面呈现给用户，这样就走完了视图的解析了。 12345678910111213141516171819202122232425262728293031@Overrideprotected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException("Could not get RequestDispatcher for [" + getUrl() + "]: Check that the corresponding file exists within your web application archive!"); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug("Including resource [" + getUrl() + "] in InternalResourceView '" + getBeanName() + "'"); &#125; rd.include(request, response); &#125;else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug("Forwarding to resource [" + getUrl() + "] in InternalResourceView '" + getBeanName() + "'"); &#125; //对请求进行转发，至此结束了视图解析解析过程 rd.forward(request, response); &#125;&#125; 最后一句话总结：视图解析器只是为了得到视图对象；视图对象才是真正的转发（将模型数据发在request域中数据）或重定向到页面（视图对象才是真正的渲染视图）。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC处理模型参数]]></title>
    <url>%2F2019%2F08%2F07%2FSpringMVC-%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[SpringMVC 提供了以下几种途径输出模型数据: ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据 Map、Model以及ModelMap:入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 Java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中。 @SessionAttributes: 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性 @ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中。 当然，除了上面这些SpringMVC提供的几种方法，SpringMVC支持直接使用Servlet几个原生API来给页面传值: HttpServletRequest request、HttpservletResponse response、HttpSession session、InputStream/Reader 对应request.getInputStream()、OutputStream/Writer 对应response.getOutputStram() servlet原生API给页面传值123456789101112131415/** * 使用servlet原生API给页面输出数据 * @param request * @param session * @return */ @RequestMapping("handler01") public String handler01(HttpServletRequest request, HttpSession session) throws IOException &#123; request.setAttribute("msg","你好，这是HelloController"); session.setAttribute("msg","json123"); return "success"; &#125; 页面测试代码:success.jsp 1234567891011121314151617181920212223242526272829303132&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;table border="1px" width="70%" &gt; &lt;tr&gt; &lt;th&gt;域&lt;/th&gt; &lt;th&gt;值&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;requestScope&lt;/th&gt; &lt;td&gt;$&#123;requestScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;applicationScope&lt;/th&gt; &lt;td&gt;$&#123;applicationScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;pageScope&lt;/th&gt; &lt;td&gt;$&#123;pageScope.msg&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 测试结果： Model、Map、ModelMap首先通过通过源码看看他们三者的关系：ModelMap类 Model接口 ExtendModelMap类 BindingAwareModelMap类 通过打开源码，我们不难总结出如下继承关系 ： 接下来看看他们的用法：示例代码 123456789101112131415161718192021222324252627282930313233343536373839/** * 使用Model * @param model * @return */ @RequestMapping("/handler02") public String handler02(Model model)&#123; System.out.println("Model"+model.getClass()); model.addAttribute("msg","大家好！这是handler02"); model.addAttribute("id",18); return "success"; &#125; /** * 使用Map * @param map * @return */ @RequestMapping("/handler03") public String handler03(Map&lt;String,String&gt; map)&#123; System.out.println("Map:"+map.getClass()); map.put("msg","handler03"); map.put("logged","admin"); return "success"; &#125; /** * 使用ModelMap * @param modelMap * @return */ @RequestMapping("/handler04") public String handler04(ModelMap modelMap)&#123; System.out.println("ModelMap:"+modelMap.getClass()); modelMap.addAttribute("msg","handler04"); return "success"; &#125; 页面代码和上面样 测试结果：页面的显示： 控制台打印的信息: 从测试结果可以总结出：Model(SpringMVC接口)其中一个实现类是ExtendedModelMapModelMap是Map(JDK的接口)Map的一个实现类,并且ModelMap被ExtendedModelMapExtendedModelMap被BindingAwareModelMap继承Model、Map、ModelMap不论用哪个，最终工作的都是BindingAwareModelMap,而且从测试结果可以看到通过这三个设置的值，SpringMVC都把他们放在了request域中。 ModelAndView 目标方法的返回值可以是ModelAndView类型，从名字上就可以看到，这是一个既包括模型(Model)又有视图(View)的一个类， 然而事实也确实如此，他的model就可以理解为送给页面的数据，他的View可以理解为目标页面地址。但我们在他的model中放入值后，SpringMVC会把ModelAndView的model中数据放在request域对象中。 示例代码 123456789101112 /** * 方法的返回值可以是 ModelAndView类型，这样我们可以把值设置在model中 * 然后springmvc会把ModelAndView的model中数据放在request域对象中 * @return */@RequestMapping("/handler05")public ModelAndView handler05()&#123; ModelAndView mv=new ModelAndView("success"); mv.addObject("msg","handler05"); return mv;&#125; 测试结果： 使用@SessionAttributes注解如果希望在多个请求之间共用某个模型属性数据，则可以在控制器类标注一个 @SessionAttributes，SpringMVC 会将模型中对应的属性暂存到 HTTPSession 中。@SessionAttributes 除了可以通过属性名指定需要放到会话中的属性外，还可以通过模型属性的对象类型指定哪些模型属性需要放到会话中。 @SessionAttributes(types=User.class)会将隐含模型中所有类型为 User 的属性添加到会话中 @SessionAttributes(value={“user1”, “user2”})将名为 user1 和 user2 的模型属性添加到会话中 @SessionAttributes(types={“User.class”, “Dept.class”})将模型中所有类型为 User 及 Dept 的属性添加到会话中 @SessionAtributes(value={“user1”, “user2”}, types={Dept.class})将名为 user1 和 user2 的模型属性添加到会话中，同时将所有类型为 Dept 的模型属性添加到会话中总之：当使用@SessionAttributes注解时就是告诉SpringMVC,当@SessionAttributes中的value值和BindingAwareModelMap的key一样时，那么在session也你也给我保存一份相同的值示例代码：1234567891011121314//使用的时候一定要注意@SessionAttributes只能用在类上@SessionAttributes(value=&#123;"id","logged"&#125;)@Controllerpublic class HelloController &#123; @RequestMapping("/handler0") public String sessionAttributesTest(Model model)&#123; model.addAttribute("msg","handler0"); //这个会在request中显示 model.addAttribute("logged",new Date()); //会在session中显示 model.addAttribute("id","001"); //会在session中显示 return "success"; &#125;&#125; 页面代码对success.jsp中的sessionScope稍作修改： 1234 &lt;tr&gt; &lt;th&gt;sessionScope&lt;/th&gt; &lt;td&gt;$&#123;sessionScope.msg&#125; | $&#123;sessionScope.id&#125; |$&#123;sessionScope.logged&#125;&lt;/td&gt;&lt;/tr&gt; 测试结果： 使用@ModelAttribute注解先来看看ModelAttribute的定义：查看 @ModelAttribute注解定义可以看到这个注解可以用在方法和参数中。 在 SpringMVC 的 Controller 中使用 @ModelAttribute 时，应用情况包括下面几种：1、应用在方法上。2、应用在方法的参数上。3、应用在方法上，并且方法也使用了@RequestMapping 示例代码：修改图书信息的页面： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SpringMVC给页面输出数据&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;!-- &lt;a href="handler01"&gt;原生API输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href="handler02"&gt;Model输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href="handler03"&gt;Map输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href="handler04"&gt;ModelMap输出数据&lt;/a&gt;&lt;br/&gt; &lt;a href="handler05"&gt;ModelAndView带回返回值&lt;/a&gt;&lt;br/&gt;--&gt; &lt;h3&gt;更新图书信息&lt;/h3&gt; &lt;form action="update" method="post"&gt; 书名：&lt;label&gt;西游记&lt;/label&gt;&lt;br/&gt; 作者：&lt;label&gt;吴承恩&lt;/label&gt;&lt;br/&gt; 价格：&lt;input type="text" name="price" placeholder="输入价格..."/&gt;&lt;br/&gt; 库存：&lt;input type="text" name="stock" placeholder="输入库存..."/&gt;&lt;br/&gt; 销量：&lt;input type="text" name="sales" placeholder="输入销量..."/&gt;&lt;br/&gt; &lt;button type="submit"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交图书修改信息后的页面： 12345678910111213141516171819202122232425262728&lt;%-- Created by IntelliJ IDEA. User: Administrator Date: 2019/8/7 Time: 10:34 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;更新图书&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style="height: 200px;width: 100%"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border="1px" width="50%"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 如果没有使用@ModelAttribute，那么要更新数据信息，必须要全字段更新，即使你不需要更新的的字段，你也要填写，这显然不和常理，因为如果你不填写这个值，值就会为null。最主要是因为SpringMVC在封装提交的信息的时候只会new一个Book对象，里面的属性的值初始就是null。你没有填写也只会以null存到数据库。不使用@ModelAttribute进行非全字段更新 12345678@Controllerpublic class BookController &#123; @RequestMapping("/update") public String update(Book book)&#123; System.out.println("更新图书的信息......页面提交过来的图书信息："+book); return "updateBook"; &#125; &#125; 测试结果:页面的显示： 看看控制台的打印信息： 可以看到果然不出预料的出问题了，更新信息后书名和作者的信息没了。这就相当于你更改了一下你的QQ密码，然后你的QQ号没了！这是很可怕的事情。使用@ModelAttribute解决问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class BookController &#123; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中查询图书数据 Book book=new Book(); book.setName("西游记"); book.setPrice(9.98); book.setAuthor("吴承恩"); book.setSales(300); book.setStock(400); System.out.println("数据库中查询到Book的信息："+book); map.put("book",book); System.out.println("ModelAttribute将查询到的图书信息保存起来.......："); &#125;&#125; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute("book")，就是告诉SpringMVC，去拿一个key为 * book的值，你不要重新new一个Book对象了，这样做的好处是可以只更改有更新的数据，没有更新的就保持原始值 * @param book * @return */ @RequestMapping("/update") public String update(@ModelAttribute("book") Book book)&#123; System.out.println("更新图书的信息......页面提交过来的图书信息："+book); return "updateBook"; &#125; 测试结果：页面展示的结果： 控制台打印的信息： 而且从控制台打印的信息来看，被@ModelAttribute标识的方法确实是在处理器方法之前执行了 @Modelattribute的原理废话不多说，直接看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xzy.Contorller;import bean.Address;import bean.Book;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;/** * @Author: HuangXin * @Date: Created in 10:33 2019/8/7 * @Description: */@Controllerpublic class BookController &#123; private Object obj1; private Object b1; /** * 可以告诉SpringMVC,你不要去new Book对象了，我已经从数据库中查询到了，你直接拿过去用就好了。 * 问题是：如何告诉SpringMVC来用这个已经处理好的Book对象呢？ * 这就是@ModelAttribute在参数位置的用法： * 下面的@ModelAttribute("book")，就是告诉SpringMVC，你去拿一个key为book的值， * 你不要重新new一个Book对象了 * @param book * @return */ @RequestMapping("/update") public String update(@ModelAttribute("book") Book book, Map&lt;String,Object&gt; model)&#123; System.out.println("处理器方法的map:"+model.getClass()); System.out.println("book==b1=&gt;"+(book==b1)); System.out.println("obj1==model=&gt;"+(obj1==model)); System.out.println("更新图书的信息......页面提交过来的图书信息："+book); return "updateBook"; &#125; /** * 用在方法上：这个方法就会优先于该类中的左右处理器方法先执行 * * @param map */ @ModelAttribute public void getBook(Map&lt;String,Object&gt; map)&#123; //模拟从数据库中拿数据 Book book=new Book(); book.setName("西游记"); book.setPrice(9.98); book.setAuthor("吴承恩"); book.setSales(300); book.setStock(400); System.out.println("数据库中查询到Book的信息："+book); obj1=map; b1=book; map.put("book",book); System.out.println("@ModelAttribute中的map:"+map.getClass()); System.out.println("ModelAttribute将查询到的图书信息保存起来.......："); &#125;&#125; 测试结果： 最后总结为一张图：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC获取请求参数]]></title>
    <url>%2F2019%2F08%2F06%2FSpringmvc%2F</url>
    <content type="text"><![CDATA[第一种方式：方法的形参上给一个和请求参数同名的参数1.获得普通类型的参数值示例代码 123456789101112131415/** * 第1种获得请求参数的方式：在方法的形参上给一个和请求参数同名的参数， * 之后SpringMVC会帮我们自动注入参数值 * @param username * @param model * @return */@RequestMapping(value = "/welcome")public String welcome(String username, Model model)&#123; System.out.println("用户名："+username); model.addAttribute("username",username); return "success";&#125; 2.获得POJO类型的值示例代码：新建Book.java以及Address.java两个POJOBook.java 12345678910111213package com.xzy.bean;public class Book &#123; private String name; private Double price; private Integer stock; //库存 private Integer sales; //销量 private String author; private Address address; //地址 //省略getter、setter方法，并且重写toString()方法&#125; Address.java 123456789package com.xzy.bean;public class Address &#123; private String province; private String county; private String city; //省略getter、setter方法，并且重写toString()方法 写一个简单的表单：index.html 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;SpringMvc获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;h3&gt;录入书籍信息&lt;/h3&gt; &lt;form action="book" method="post"&gt; 书名：&lt;input type="text" name="name" placeholder="输入书名..."/&gt;&lt;br/&gt; 作者：&lt;input type="text" name="author" placeholder="输入作者..."/&gt;&lt;br/&gt; 价格：&lt;input type="text" name="price" placeholder="输入价格..."/&gt;&lt;br/&gt; 库存：&lt;input type="text" name="stock" placeholder="输入库存..."/&gt;&lt;br/&gt; 销量：&lt;input type="text" name="sales" placeholder="输入销量..."/&gt;&lt;br/&gt; &lt;input type="text" name="address.province" /&gt;省&amp;nbsp; &lt;input type="text" name="address.city" /&gt;市&amp;nbsp; &lt;input type="text" name="address.county" /&gt;(区/县)&amp;nbsp;&lt;br/&gt; &lt;button type="submit"&gt;提交信息&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提交后的页面：book.jsp 12345678910111213141516171819202122232425&lt;%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" import="com.xzy.bean.*"%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;SpringMVC获取参数&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;div style="height: 200px;width: 100%"&gt; &lt;h3&gt;提交的书籍的信息：&lt;/h3&gt; &lt;table border="1px" width="50%"&gt; &lt;tr&gt;&lt;th&gt;书名&lt;/th&gt;&lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;作者&lt;/th&gt;&lt;td&gt;$&#123;book.author&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;价格&lt;/th&gt;&lt;td&gt;$&#123;book.price&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;库存&lt;/th&gt;&lt;td&gt;$&#123;book.stock&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;销量&lt;/th&gt;&lt;td&gt;$&#123;book.sales&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;th&gt;地区&lt;/th&gt;&lt;td&gt;$&#123;book.address&#125;&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 提供一个控制器：BookContorller.java 1234567891011121314151617181920212223242526package com.xzy.controller;import com.xzy.bean.Book;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.http.HttpServletRequest;@Controllerpublic class BookContorller &#123; /** * SprningMVC帮我们自动注入参数到POJO类型中，而且还可以级联注入 * @param book * @param request * @return */ @RequestMapping("/book") public String addbook(Book book, HttpServletRequest request)&#123; //打印得到的book信息 System.out.println(book); request.setAttribute("book",book); return "book"; &#125;&#125; 测试结果： 第二种方式：使用Spring提供的注解1. 使用@RequestParam 获取参数分析@RequestParam的源码： 123456789101112131415public @interface RequestParam &#123; //默认值就是它，表示请求参数的key @AliasFor("name") String value() default ""; //请求参数的值 @AliasFor("value") String name() default ""; //设置这个参数是否必须，required=false表示这个参数不是必须的 boolean required() default true; //参数的默认值 String defaultValue() default "\n\t\t\n\t\t\n\ue000\ue001\ue002\n\t\t\t\t\n"; &#125; 示例代码： 12345678910111213141516171819/** * RequestParam设置获取参数的key为user,required=false表示这个参数不是必须的， * defaultValue是这个参数的默认值 * @RequestParam(value = "user", required = false, defaultValue = "") String username； * 等价于以前写的： * String user=null!=request.getParameter("user")?request.getParameter("user"):""; * @param username * @param model * @return */@RequestMapping("/welcome3")public String welocme3( @RequestParam(value = "user", required = false, defaultValue = "") String username, Model model) &#123; System.out.println("用户名：" + username); model.addAttribute("username", username); return "success";&#125; 2.使用@RequestHeader获得请求的头部信息@RequestHeader和@ReuqestParma的实现方式如出一辙，使用方法也基本相同。示例代码1：使用RequestHeader注解获得浏览器的信息 123456789101112131415161718192021/** * @RequestHeader(value = "User-Agent",required = false,defaultValue = "") String userAgent * 获取请求头中的值，相当于以前写的： * String header=null!=request.getHeader("User-Agent")? request.getHeader("User-Agent"):""; * @param username * @param userAgent * @param model * @return */ @RequestMapping("/welcome4") public String welocme4( @RequestParam(value = "user", required = false, defaultValue = "") String username, @RequestHeader(value = "User-Agent",defaultValue = "") String userAgent, Model model) &#123; System.out.println("用户名：" + username); System.out.println("User-Agent"+userAgent); model.addAttribute("userAgent",userAgent); model.addAttribute("username", username); return "success"; &#125; 示例代码2：使用RequestHeader注解获取请求头部的Cookie信息 123456789101112131415161718/** * 使用RequestHeader获得请求头中的Cookie的全部信息 * @param username * @param cookie * @param model * @return */ @RequestMapping("/welcome5") public String welocome5( @RequestParam(value = "user", required = false, defaultValue = "") String username, @RequestHeader(value = "Cookie",required = false,defaultValue = "") String cookie, Model model)&#123; System.out.println("用户名：" + username); model.addAttribute("cookie",cookie); model.addAttribute("username", username); return "success"; &#125; 3.使用CookieValue获得请求头部的JSESSIONID示例代码： 123456789101112131415161718192021/** * 使用SpringMVC提供的@CookieValue注解，可以只获的JSESSIONID的值 * @param username * @param cookie * @param model * @return */ @RequestMapping("/welcome6") public String welocome6( @RequestParam(value = "user", required = false, defaultValue = "") String username, @CookieValue(value = "JSESSIONID" ,required = false,defaultValue = "") String cookie, Model model)&#123; System.out.println("用户名：" + username); model.addAttribute("cookie",cookie); model.addAttribute("username", username); System.out.println("cookie："+cookie); return "success"; &#125;]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC 对Ant风格和Rest风格支持]]></title>
    <url>%2F2019%2F08%2F04%2FSpringMVC%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%A3%8E%E6%A0%BC%E7%9A%84URL%E5%BD%A2%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Ant风格的URL形式Ant风格的URL指的是URL的路径可以写成模糊路径，然后Spring MVC会帮我们匹配， ?：匹配一个字符 *: 匹配多个字符以及一层URL路径 **:可以匹配多个字符以及多层路径 匹配的规则：以最精确的路径为准，就是说当有多个路径可以匹配的时候，以最精确的路径为目标去访问 示例代码：新建AntTestServlet.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * * Ant风格的URL指的是URL的路径可以写成模糊路径，然后Spring MVC会帮我们匹配 * ?：匹配一个字符 * *: 匹配多个字符以及一层URL路径 * **:可以匹配多个字符以及多层路径 * 匹配的规则：以最精确的路径为准，就是说当有多个路径可以匹配的时候，以最精确的路径为目标去访问 */@RequestMapping("/ant")@Controllerpublic class AntTestServlet &#123; @RequestMapping("/handler1") public String handler1()&#123; System.out.println("访问了handler1()"); return "index"; &#125; //?可以匹配一个字符（“/”除外）,0个和多个都不行 @RequestMapping("/handler?") public String handler2()&#123; System.out.println("访问了handler2()"); return "index"; &#125; //*可以匹配任意多个字符 @RequestMapping("/handler*") public String handler3()&#123; System.out.println("访问了handler3()"); return "index"; &#125; /** * 匹配一层路径 * @return */ @RequestMapping("test/*/handler*") public String handler4()&#123; System.out.println("访问了handler4()"); return "index"; &#125; /** *匹配多层路径 * @return */ @RequestMapping("test/**/handler*") public String handler5()&#123; System.out.println("访问了handler5()"); return "index"; &#125;&#125; 测试结果: @PathVariable 路径占位符使用@PathVariable 注解可以获得路径中占位符的值示例代码: 测试结果： REST风格的URL形式编写一个控制器BooKContorller，模拟业务处理，里面写上增删改查的基本方法，然后定义不同的方法只有不同的请求才可以访问。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class BookContorller &#123; /** * 增加一本书 * @param model * @param bookId * @return */ @RequestMapping(value = "book/&#123;bookId&#125;",method = RequestMethod.PUT) public String addBook(Model model,@PathVariable String bookId)&#123; model.addAttribute("msg","添加了一本书,书的Id是："+bookId); return "index"; &#125; /** * 删除一本书 * @param model * @param bookId * @return */ @RequestMapping(value = "book/&#123;bookId&#125;",method = RequestMethod.DELETE) public String deleteBook(Model model,@PathVariable String bookId)&#123; model.addAttribute("msg","删除了一本书,书的Id是："+bookId); return "index"; &#125; /** * 更新一本书 * @param model * @param bookId * @return */ @RequestMapping(value = "book/&#123;bookId&#125;",method = RequestMethod.POST) public String updateBook(Model model,@PathVariable String bookId)&#123; model.addAttribute("msg","更新了一本书,书的Id是："+bookId); return "index"; &#125; /** * 查询一本书 * @param model * @param bookId * @return */ @RequestMapping(value = "book/&#123;bookId&#125;",method = RequestMethod.GET) public String getBook(Model model,@PathVariable String bookId)&#123; model.addAttribute("msg","查询了一本书,书的Id是："+bookId); return "index"; &#125;&#125; 但是页面上只能发出GET 和POST两种请求，如何解决delete和put请求呢？对于这个问题，SpringMVC中也给予了支持，即org.springframework.web.filter.HiddenHttpMethodFilter这个过滤器，只需要我们在web.xml中配置一个关于请求方法的过滤器： 123456789&lt;!--配置Http所有method的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 然后在一个带有POST请求的表单里加入&lt;input name=&quot;_method&quot; value=&quot;请求方法名&quot;&gt;，value后面就填写需要的请求方法名即可。 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="book/1" method="get"&gt; &lt;input name="bookId"/&gt; &lt;button type="submit"&gt;查询一本书&lt;/button&gt; &lt;/form&gt; &lt;form action="book/1" method="post"&gt; &lt;input name="_method" value="delete"&gt; &lt;button type="submit"&gt;删除一本书&lt;/button&gt; &lt;/form&gt; &lt;form action="book/1" method="post"&gt; &lt;input name="_method" value="put"&gt; &lt;button type="submit"&gt;增加一本书&lt;/button&gt; &lt;/form&gt; &lt;form action="book/1" method="post"&gt; &lt;button type="submit"&gt;更新一本书&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 运行后会有一个问题：GET和POST的参数可以正常处理，但是当DELETE和PUT请求的时候，就会有下面的异常： 这是由于8.0以上的Tomcat不允许除了POST和GET以外的其他请求来访问JSP页面，解决的办法也很简单，如下： 解决这个问题后，最终的测试结果如下图：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequestMapping注解]]></title>
    <url>%2F2019%2F08%2F04%2FSpringMVC%20RequestMapping%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[@RequestMapping注解是一个十分强大的注解，Spring MVC使用@RequestMapping注解为控制器指定可以处理那些URL请求，在控制器的类上或类中的方法上均可以使用这个注解： 在类上使用可以提供初步的映射信息。相当于一个根路径 在方法上使用提供更进一步的细分映射信息。 这是一个只在方法上使用的例子： 1234567891011121314151617package com.xzy.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloServlet0 &#123; @RequestMapping("/hello") public String sayHello(Model model)&#123; System.out.println("收到请求，正在处理......."); model.addAttribute("msg","This is a Spring MVC Web"); return "success"; &#125;&#125; 这是一个在类和方法同时使用的例子： 1234567891011121314151617181920package com.xzy.controller;import com.xzy.bean.Teacher;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping("/welcome") //这个相当于是基准路径public class HelloServlet &#123; @RequestMapping("/hello") public String sayHello(Model model)&#123; System.out.println("收到请求，正在处理......"); model.addAttribute("msg","Welcome to SpringMVC!"); return "hello"; &#125;&#125; @Requestmapping的属性: 属性作用 value 默认的属性就是value,他就是一个URL路径，可以在一个方法上或类上给多个value值 method 用来定义接收浏览器发来的何种请求。在Spring中，使用枚举类RequestMethod来封装了HTTP协议的所有请求方式。最基本的有GET、POST、DELETE、PUT params 表示请求参数，也就是追加在URL上的键值对，多个请求参数以&隔开 headers 该属性表示请求头，通过 @RequestMapping 中的 headers 属性，可以限制客户端发来的请求 consumes 规定请求头的Content-Type produces 告诉浏览器返回的内容是什么，给响应头中加上Content-Type 示例代码：method:限定请求方法 12345678910111213141516171819202122232425262728HelloServlet.java /** * 指定只有GET请求才可一访问 * @param model * @return */ @RequestMapping(value="/handler1",method= RequestMethod.GET) public String handler1(Model model)&#123; System.out.println("收到请求，正在处理......"); model.addAttribute("msg","这是一个只有GET请求才可以访问页面"); return "success"; &#125; /** * 指定只有POST请求才可以来访问 * @param model * @return */ @RequestMapping(value = "/handler2",method = RequestMethod.POST) public String handler2(Model model)&#123; System.out.println("收到请求，正在处理......"); model.addAttribute("msg","这是一个只有POST请求才可以访问页面"); return "success"; &#125; 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href="hello"&gt;1.只在方法方法上用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href="home/hello"&gt;2.在类和方法上同时用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href="home/handler1"&gt;3.通过GET方法来访问&lt;/a&gt;&lt;br/&gt; &lt;form action="home/handler2" method="post"&gt; &lt;button type="submit"&gt;4.POST提交&lt;/button&gt; &lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; parmars:限定参数parmars支持简单的表达式计算，例如:eg1:params = {“username”} ,表示请求的路径中必须要有username这个关键字，如果没有就会报异常 eg2:params = {“!username”} ,表示请求的路径中不能有username这个关键字，如果有这个参数就会报异常eg2:params = {“username”,”age=20”,”pwd”} ,表示请求的路径中必须要有username、age、pwd这三个关键字，并且age必须是20，如果没有或age的值不等就会报异常 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;@RequestMapping测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href="hello"&gt;1.只在方法方法上用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href="home/hello"&gt;2.在类和方法上同时用@RequestMapping注解&lt;/a&gt;&lt;br/&gt; &lt;a href="home/handler1"&gt;3.通过GET方法来访问&lt;/a&gt;&lt;br/&gt; &lt;form action="home/handler2" method="post"&gt; &lt;button type="submit"&gt;4.POST提交&lt;/button&gt; &lt;/form&gt; &lt;a href="home/handler3?username=hx"&gt;5.限定请求参数1&lt;/a&gt;&lt;br/&gt; &lt;a href="home/handler4?username=hx&amp;age=20&amp;pwd=123456"&gt;5.限定请求参数2&lt;/a&gt;&lt;br/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; headers:限定请求头部示例一： 测试结果：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC的运行流程]]></title>
    <url>%2F2019%2F08%2F03%2FSpringMVC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring MVC体系结构：SpringMVC 是基于 Model2 实现的技术框架 一个请求在SpringMVC中经历的过程： 请求旅程的第一站是 Spring 的 DispatcherServlet。与大多数基于 Java 的 Web 框架一样，Spring MVC 所有的请求都会通过一个前端控制器（front controller）Servlet。前端控制器是常用的 Web 应用程序模式，在这里一个单实例的 Servlet 将请求委托给应用程序的其他组件来执行实际的处理。在 Spring MVC 中，DispatcherServlet 就是前端控制器。 DispatcherServlet 的任务是将请求发送给 Spring MVC 控制器（controller）。控制器是一个用于处理请求的 Spring 组件。在典型的应用程序中可能会有多个控制器，DispatcherServlet 需要知道应该将请求发送给哪个控制器。所以 DispatcherServlet 以会查询一个或多个处理器映射（handler mapping） 来确定请求的下一站在哪里。处理器映射会根据请求所携带的 URL 信息来进行决策。 一旦选择了合适的控制器，DispatcherServlet 会将请求发送给选中的控制器 。到了控制器，请求会卸下其负载（用户提交的信息）并耐心等待控制器处理这些信息。（实际上，设计良好的控制器本身只处理很少甚至不处理工作，而是将业务逻辑委托给一个或多个服务对象进行处理。） 控制器在完成逻辑处理后，通常会产生一些信息，这些信息需要返回给用户并在浏览器上显示。这些信息被称为模型（model）。不过仅仅给用户返回原始的信息是不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML。所以，信息需要发送给一个视图（view），通常会是 JSP。 控制器所做的最后一件事就是将模型数据打包，并且标示出用于渲染输出的视图名。它接下来会将请求连同模型和视图名发送回 DispatcherServlet 。 这样，控制器就不会与特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。实际上，它甚至并不能确定视图就是 JSP。相反，它仅仅传递了一个逻辑名称，个名字将会用来查找产生结果的真正视图。DispatcherServlet 将会使用视图解析器（viewResolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP。 既然 DispatcherServlet 已经知道由哪个视图渲染结果，那请求的任务基本上也就完成了。它的最后一站是视图的实现（可能是 JSP） ，在这里它交付模型数据。请求的任务就完成了。视图将使用模型数据渲染输出，这个输出会通过响应对象传递给客户端（不会像听上去那样硬编码） 。 可以看到，请求要经过很多的步骤，最终才能形成返回给客户端的响应。大多数的步骤都是在 Spring 框架内部完成的，也就是上图所示的组件中。 第一个SpringMVC程序第一步：配置环境（新建Web工程+导包+配置Tomcat）在IDEA中新建MavenWeb工程，新建好后导包，使用SpringMVC所需要的基本的Maven依赖如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110pom.xml中的依赖&lt;properties &lt;spring.version&gt;5.1.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;!--Servlet JSP依赖 --&gt;&lt;!-- https://mvnrepository.com/artifact/taglibs/standard --&gt;&lt;dependency&gt;&lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/javax.servlet.jsp/javax.servlet.jsp-api --&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-beans --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt; 第二步：配置DispatcherServlet通过DispatcherServlet这个名字可以大概了解到，这就是一个servlet,因此要想使一个sevlet起作用无非两种方法：一种是在servle类的头部加@WebServlet注解，二是在web.xml文件中配置&lt;servlet&gt;和servlet-mapping，第一种方法在这里显然不可行，人家源码肯定不能让改，那就需要在web.xml配置它，配置如下: 12345678910111213141516171819&lt;!--配置前段控制器DispatcherServlet到web.xml--&gt;&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--初始化参数：是springMVC配置文件的类路径，也可以不配这个，在笔记最后有说明--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;!--url路径表示拦截所有的请求 /和/*都是拦截所有的请求 /*的拦截范围更大，会拦截*.jsp,而/不会拦截*.jsp --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 接着在src/resources下新建springmvc.xml，配置springmvc： 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt;&lt;mvc:annotation-driven/&gt;&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;context:component-scan base-package="com.xzy.contorller"/&gt;&lt;!-- 当请求的中径没有对应的controller 那么就访问静态资源 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!--配置一个视图解析器：会帮我们拼接页面地址--&gt;&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;/beans&gt; 第三步：在webapp包下新建一个index.html以及hello.jsp，随便写点啥123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt; &lt;a href="hello"&gt;hello&lt;/a&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align="center"&gt;第一个Spring mVC&lt;/h1&gt;&lt;center&gt; $&#123;msg&#125;&lt;br/&gt; $&#123;teacher.name&#125; &lt;hr/&gt; &lt;img src="img/a1.jpg"/&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 第四步：新建一个Controller，比如就叫HelloController1234567891011121314151617181920212223package com.xzy.controller;import com.xzy.bean.Teacher;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String sayHello(Model model)&#123; System.out.println("收到请求，正在处理......"); model.addAttribute("msg","Welcome to SpringMVC!"); /* &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; 在xml配置的视图解析器会自动帮我们拼接页面地址：prefix+返回值+suffix */ return "hello"; &#125;&#125; 测试结果： 总结在做的时候的几细节1. Spring MVC 下Web项目的运行流程：1).点击http://localhost/SpringMVC_01_war_exploded/后浏览器把请求给服务器2).服务器中由于配置了SpringMVC的Dispatcherservlet，他可以拦截到所有的请求3).Dispatcherservlet拦截到请求后查看请求地址和@RequestMapping()中的那个地址(对应的方法)匹配，如果没找到，又没有配置&lt;mvc:defalut-servlet-handler/&gt;那就“炸了”!4).如果前端控制器找到目标处理器和方法后，在执行目标方法前拦截器的preHnalde方法会执行，然后利用反射调用方法5).方法执行完成会有返回值（视图名），SpringMVC认为这就是方法执行完后要去的页面，最终会把它封装成一个ModelAndView对象6).拿到ModelAndView对象后，视图解析器(ViewResolver)会根据ModelAndView解析出实际的视图(View)对象7).得到视图对象后，调用该View对象的render方法来渲染视图，视图渲染完成后前段控制器就会使用转发的方式到目标页面，之后拦截器的afterCompletion方法会被调用 2.关于springmvc.xml配置文件的配置：在web.xml配置前段控制器又这么一段配置，他的作用是告诉服务器去哪里加载对于前端控制器的配置文件： 1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 如果我们没有写他会发生什么呢？会发生异常： 12345672019-08-03 15:07:16 [INFO]-[org.springframework.web.servlet.DispatcherServlet] Initializing Servlet 'app' 2019-08-03 15:07:16 [ERROR]-[org.springframework.web.servlet.DispatcherServlet] Context initialization failed org.springframework.beans.factory.BeanDefinitionStoreException: IOException parsing XML document from ServletContext resource [/WEB-INF/app-servlet.xml]; nested exception is java.io.FileNotFoundException: Could not open ServletContext resource [/WEB-INF/app-servlet.xml] at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:344) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) 一大堆异常信息反正就是告诉中我们启动的时候没有找不到配置文件的路径，SpringMVC默认会在/WEB-INF目录下默认加载一个文件叫app-servlet.xml的文件，然而也没有找到，从而无法完成初始化。从这里我们知道，在web.xml中配置前端控制器的时候也可以不写初始化参数，但是我们必须将springmvc配置文件放在WEB-INF目录下，并且文件的必须名字是：在web.xml中前端控制器的&lt;servlet-name&gt;+-servlet.xml,这是规定，不可随便来，你想节省一些操作就得按人家的要求来。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP详细配置与使用]]></title>
    <url>%2F2019%2F08%2F03%2FSpring%20AOP%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[AspectJ 通知类型 AOP 联盟定义通知类型，AOP联盟的jar都是接口，必须要有实现类。AspectJ通知类型只定义类型名称，以及方法格式，总共有6种；1.before：前置通知(应用：各种校验) 在方法执行前执行，如果通知抛出异常，将不会执行方法2.afterReturning：后置通知（应用：常规数据处理） 方法正常返回后执行，如果方法中抛出异常，通知将无法执行3. around：环绕通知（应用：十分强大，可以做任何事） 方法执行前后分别执行，可阻止方法执行4.afterThrowing：抛出异常通知（应用：包装异常信息） 方法抛出异常后执行，如果方法没有抛出异常，无法执行5.after：最终通知（应用：清理现场） 方法执行完毕后执行，无论方法中是否出现异常都会执行（类似于finally代码块） 基于XML配置AOP在上一篇笔记Spring AOP两种配置方式(半自动vs全自动)中讲了如何使用xml的方式配置和使用Spring的AOP，这里我们再回顾一下： 首先编写一个service接口,模拟要处理的业务 123456789101112131415161718192021package com.xzy.service;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public int deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 实现service接口： 12345678910111213141516171819package com.xzy.service;public class UserSeviceImpl implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println("增加了1个用户"); &#125; @Override public int deleteUser(int id) &#123; System.out.println("删除了id为"+id+"的用户"); return id; &#125; @Override public void updateUser(int id) &#123; System.out.println("id为"+id+"的用户更新了"); &#125;&#125; 编写切面类：写一个方法before()，他是在目标方法执行需要增强的功能 1234567891011121314package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;public class MyAspect2 &#123; /* *前置通知 *JoinPoint：连接点 */ public void before(JoinPoint jp)&#123; System.out.println("前置通知........"+jp.getSignature().getName()); //得到方法的名字 &#125;&#125; applicationContext2.xml中的配置如下： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--配置bean--&gt; &lt;bean id="userService" class="com.xzy.service.UserSeviceImpl"&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id="aspect" class="com.xzy.Aspect.MyAspect2"&gt;&lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref="aspect"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id="poincut1" expression="execution(* com.xzy.service.*.*(..))"/&gt; &lt;!--前置通知--&gt; &lt;aop:before method="before" pointcut-ref="poincut1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 测试： 12345678910111213141516171819package com.xzy;import com.xzy.service.UserSeviceBase;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AppTest &#123; @Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext("ApplicationContext2.xml"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean("userService"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125;&#125; 测试结果：如下图所示，前置通知确实起作用了，在目标方法执行之前就执行了 下面我们在来测测&lt;aop:advisor&gt;中的其他通知方式 &lt;aop:after-returning&gt;&nbsp;&nbsp;&nbsp;&nbsp;在切面类中增加方法：afterReturning(JoinPoint jp,Object obj),其中第一个参数是连接点，第二个参数是目标方法运行后的返回值。要获得返回返回值需要在配置中设置returning=”obj”，就是把这个第二个参数的名字放进去，Spring就会把返回值注入。 1234567891011121314151617181920212223package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;public class MyAspect2 &#123; /* *方法执行前的通知 */ public void before(JoinPoint jp)&#123; System.out.println("前置通知........"+jp.getSignature().getName()); //得到方法的名字 &#125; /* *方法返回后的通知 */ public void afterReturning(JoinPoint jp,Object obj)&#123; System.out.println("后置通知........"+jp.getSignature().getName()); //得到方法的名字 System.out.println("方法的返回值是："+obj); System.out.println("----------------------------------"); &#125;&#125; 配置新增的切面类方法： 1234567891011121314151617181920&lt;!--配置bean--&gt; &lt;bean id="userService" class="com.xzy.service.UserSeviceImpl"&gt;&lt;/bean&gt; &lt;!--配置切面类--&gt; &lt;bean id="aspect" class="com.xzy.Aspect.MyAspect2"&gt;&lt;/bean&gt; &lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref="aspect"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id="poincut1" expression="execution(* com.xzy.service.UserServiceImpl.*(..))"/&gt; &lt;!--前置通知--&gt; &lt;aop:before method="before" pointcut-ref="poincut1"/&gt; &lt;!--后置通知--&gt; &lt;aop:after-returning method="afterReturning" pointcut-ref="poincut1" returning="obj"&gt;&lt;/aop:after-returning&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试代码不变，测试结果如下： &lt;aop: around&gt;around具有before和after-returning两者的功能，这里就不在重复测试了。所以一般使用了around就不在使用brfore和after-returning &lt;aop: after-throwing&gt;、&lt;aop: after&gt;切面类中增加方法afterThrowing和after 1234567891011121314/** * 抛出异常后通知 * @param jp 连接点 * @param e 异常 */public void afterThrowing(JoinPoint jp,Throwable e)&#123; System.out.println("抛出异常通知....."+jp.getSignature().getName()+e.getMessage());&#125;public void after(JoinPoint jp)&#123; System.out.println("最终通知......"+jp.getSignature().getName());&#125; 配置xml 12345678910111213141516&lt;!--配置aop--&gt; &lt;aop:config&gt; &lt;!--指定切面--&gt; &lt;aop:aspect ref="aspect"&gt; &lt;!--指定切入点--&gt; &lt;aop:pointcut id="poincut1" expression="execution(* com.xzy.service.UserSeviceImpl.*(..))"/&gt; &lt;!--环绕通知--&gt; &lt;aop:around method="around" pointcut-ref="poincut1"&gt;&lt;/aop:around&gt; &lt;!--异常通知:当目标方法发生异常后会执行 --&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="poincut1" throwing="e"/&gt; &lt;!--最终通知:无论方法有没有发生异常，都会执行--&gt; &lt;aop:after method="after" pointcut-ref="poincut1"/&gt; &lt;/aop:config&gt; 并在deleteUser方法中主动抛出异常： 12345@Overridepublic int deleteUser(int id) &#123; System.out.println("删除了id为" + id + "的用户"); throw new RuntimeException(new Exception("自定义异常...."));&#125; 测试结果如下： 如果去掉异常的测试结果如下： 基于Annotation配置AOP既然使用注解配置，那就全部用注解，包括配置文件都用注解+Java类来实现 编写配置类ApplicationConfig.java替代xml文件12345678910111213package com.xzy;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;@Configuration //告诉spring这是配置文件@EnableAspectJAutoProxy //开启aop自动代理@ComponentScan(basePackages = &#123;"com.xzy"&#125;) //告诉spring去哪里扫描注解public class AppConfig &#123; //这里头以后可以写各种配置，这个类的作用就和XML文件的作用一样&#125; 当然这段java代码可以用下面这段XML配置文件替代 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!--开启注解功能--&gt; &lt;context:annotation-config/&gt; &lt;!--告诉Spring去哪里扫描注解--&gt; &lt;context:component-scan base-package="com.xzy"/&gt; &lt;!--配置aop自动代理--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 编写一个日志记录的切面类LoggerApsect.java在切面类中可以使用如下几个注解来定制一个切面： @Aspect：告诉Spring这是切面类 @Brfore：前置通知 @AfterRuning：返回后通知 @Around：环绕通知，是@Brfore和@AfterRuning的结合，功能十分强大 @After-Throwing：抛出异常后的通知，没有异常不会执行 @After：最终通知，无论有没有异常一定会执行的 @PointCut：定义切点 具体用法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xzy.Aspect;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Date;/** * 一个记录各种操作的日志切面类 */@Component //告诉Spring你要把这个类给我实例化了@Aspect //告诉Spring这是一个切面类public class LoggerAspect &#123; //声明一个公共的切点：将com.xzy.service包下的所有以Impl结尾的方法作为切入点，切入点中可以没有任何代码实现，只是让他在形式上存在即可 @Pointcut("execution(* com.xzy.service.*Impl.*(..))") public void pointcut() &#123; &#125; @Before("execution(* com.xzy.service.*Impl.*(..))") public void before(JoinPoint joinPoint) &#123; System.out.println("before给" + joinPoint.getSignature().getName() + "方法作前日志.........." + new Date()); &#125; @AfterReturning(pointcut = "pointcut()", returning = "retValue") public void afterReturning(JoinPoint joinPoint, Object retValue) &#123; System.out.println("afterReturning给" + joinPoint.getSignature().getName() + "方法作后日志.........." + new Date()); System.out.println("方法的返回值是：" + retValue); &#125; @Around("pointcut()") public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println("around给" + joinPoint.getSignature().getName() + "方法作前日志.........." + new Date()); Object retValue = joinPoint.proceed(); System.out.println("around给" + joinPoint.getSignature().getName() + "方法作前后志.........." + new Date()); return retValue; &#125; @AfterThrowing(pointcut = "pointcut()", throwing = "e") public void afterThrowing(JoinPoint joinPoint, Throwable e) &#123; System.out.println("给" + joinPoint.getSignature().getName() + "方法作异常日志：" + new Date() + "抛出" + e.getMessage()); &#125; @After("pointcut()") public void afterAll(JoinPoint joinPoint) &#123; System.out.println("给" + joinPoint.getSignature().getName() + "方法作最终日志.........." + new Date()); &#125;&#125; 测试类如下： 1234567891011121314151617181920212223242526package com.xzy;import com.xzy.service.UserSeviceBase;import org.apache.log4j.Logger;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= &#123;AppConfig.class&#125;)public class AppTest &#123; private static Logger log= Logger.getLogger(AppTest.class); @Autowired UserSeviceBase userSevice; @Test public void test3()&#123; userSevice.deleteUser(12); userSevice.updateUser(34); &#125;&#125; 测试结果: 现在去掉before、after-return以及在deleteUser中抛出一个异常：]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP两种配置方式(半自动vs全自动)]]></title>
    <url>%2F2019%2F08%2F03%2FSpringAOP%E5%8D%8A%E8%87%AA%E5%8A%A8%E5%92%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring AOP半自动编程 核心步骤：1. 创建一个接口以及它的实现类2. 编写切面类，实现MethodInterceptor接口的invoke方法3. 配置Spring的配置文件，xml文件中的配置重要是：【重要】 &nbsp;&nbsp; 1).配置目标类的bean &nbsp;&nbsp;&nbsp;2).配置切面类的bean &nbsp;&nbsp;&nbsp;3).配置代理对象，其中代理对象中主要的配置如下’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.配置接口&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.配置目标类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.配置切面类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.还可以用&lt;property name=&quot;optimize&quot; value=&quot;true&quot;/&gt;,指明使用cglib的代理对象 1.首先编写一个接口 123456789101112131415161718192021package com.xzy.service;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public void deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 接口的实现类： 123456789101112131415161718package com.xzy.service;public class UserSeviceImpl implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println("增加了1个用户"); &#125; @Override public void deleteUser(int id) &#123; System.out.println("删除了id为"+id+"的用户"); &#125; @Override public void updateUser(int id) &#123; System.out.println("id为"+id+"的用户更新了"); &#125;&#125; 编写一个切面类：让这个切面类实现MethodInvocation接口的invoke方法 1234567891011121314151617181920package com.xzy.Aspect;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import java.util.Date;//切面类public class MyAspect implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println("执行操作前日志......" + new Date()); Object obj = methodInvocation.proceed(); System.out.println("执行操作后日志......" + new Date()); return obj; &#125;&#125; 在Spring的配置文件Application.xml中注册代理对象 123456789101112131415&lt;!--注册目标对象UserService--&gt;&lt;bean id="userService" class="com.xzy.service.UserSeviceImpl"&gt;&lt;/bean&gt;&lt;!--注册切面类--&gt;&lt;bean id="myAspect" class="com.xzy.Aspect.MyAspect"&gt;&lt;/bean&gt;&lt;!--注册代理对象--&gt;&lt;bean id="proxyService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;!--接口--&gt; &lt;property name="interfaces" value="com.xzy.service.UserSeviceBase"/&gt; &lt;!--目标对象--&gt; &lt;property name="target" value="#&#123;userService&#125;"/&gt; &lt;!--切面类--&gt; &lt;property name="interceptorNames" value="myAspect"/&gt; &lt;!--配置使用cglib,当没有配置的时候默认是false,也就是使用JDk的Proxy--&gt; &lt;property name="optimize" value="true"/&gt;&lt;/bean&gt; 测试： 123456789101112131415161718192021222324package com.xzy;import com.xzy.service.UserSeviceBase;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Unit test for simple App. */public class AppTest &#123; @Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext("ApplicationContext.xml"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean("proxyService"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125;&#125; 测试结果： Spring AOP 全自动编程 主要步骤：1）.实现切面类2）.在bean配置文件中吧切点和切面关联起来 实现一个切面类,继承MethodInterceptor接口实现它的invoke方法 123456789101112131415161718192021package com.xzy.Aspect;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;import java.util.Date;//切面类public class MyAspect implements MethodInterceptor &#123; @Override public Object invoke(MethodInvocation methodInvocation) throws Throwable &#123; System.out.println("执行操作前日志......" + new Date()); Object obj = methodInvocation.proceed(); System.out.println("执行操作后日志......" + new Date()); return obj; &#125;&#125; 接着在Spring配置文件Application.xml中配置aop的schema文件，如下红框的配置： 接着在配置文件中添加如下内容： 123456789101112131415&lt;!--配置UserService--&gt;&lt;bean id="userService" class="com.xzy.service.UserSeviceImpl"&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id="myAspect" class="com.xzy.Aspect.MyAspect"&gt;&lt;/bean&gt;&lt;!--配置全自动AOP代理--&gt;&lt;aop:config &gt; &lt;!--配置切点expression：表达式，就是用来切入的业务类--&gt; &lt;aop:pointcut id="myPointcut" expression="execution(* com.xzy.service.*.*(..))"/&gt; &lt;!--配合通知 通知要关联切点和切面类 advice-ref:切面类 pointcut-ref:切点 --&gt; &lt;aop:advisor advice-ref="myAspect" pointcut-ref="myPointcut"&gt;&lt;/aop:advisor&gt;&lt;/aop:config&gt; 对于配置全自动AOP代理的一点说明，如下图所示&lt;aop:config&gt;标签中重要的三种元素：切点：&lt;aop:pointcut&gt;、切面：&lt;aop:aspect&gt;、通知：&lt;aop:advisor&gt; 其中通知：``又有一下5种： 测试： 1234567891011@Test public void test()&#123; ApplicationContext context=new ClassPathXmlApplicationContext("ApplicationContext.xml"); //从Spring容器中拿代理对象 UserSeviceBase userSevice= (UserSeviceBase) context.getBean("userService"); userSevice.deleteUser(23); userSevice.updateUser(3); &#125; 测试结果： 写在最后：&nbsp;&nbsp;&nbsp;&nbsp;通过实际的操作可以明显感受到第二种方式实现AOP是省事儿又简单的一种方式，然而第二种方式也是Spring中使用到AOP是常用到的一种配置方式。既然有全自动xml的配置方式，那么一定就会有对应对一套使用注解配置对方式。下一节就讲讲如何用注解配置使用Spring AOP。]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring AOP原理与手撕AOP[重要]]]></title>
    <url>%2F2019%2F08%2F03%2FSpringAOP%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[AOP概述（Spring AOP是什么?AOP有什么用？） 1） 在软件行业，AOP为Aspect Oriented programming 的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的同一维护的一种技术。2） AOP是OOP（面向对象编程）的延续，是软件开发的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生。3）利用AOP可以对业务逻辑的各个部分进行分离，从而使得业务逻辑各个部分之间的耦合度降低，Tiga程序的可重用性，同时提高了开发效率。4）AOP采用横向抽取机制，取代了传统继承体系的纵向机制。5）AOP的经典应用场景：事务管理、性能监视、安全、缓存、日志…..6）Spring AOP 使用纯Java代码实现，不需要专门的编译过程和类加载器，在运行期通过代理方式向目标类织入增强代码。7）AspectJ是一个基于Java的AOP框架，Spring2.0开始，Spring AOP引入AspectJ的支持，AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的织入。 AOP的一些术语【了解】&nbsp;&nbsp;&nbsp;&nbsp;AOP(Aspect Oriented Programming)像大多数技术一样形成了自己的术语，而且这些术语比较难理解，不论是理解还中不理解都对编程影响不太大。1）连接点（Joinpoint）&nbsp;&nbsp;&nbsp;&nbsp;程序执行的某个特定位置：如类开始初始化前、类初始化后、类某个方法调用前、调用后、方法抛出异常后。一个类或一段程序代码拥有一些具有边界性质的特定点，这些点中的特定点就称为“连接点”。Spring 仅支持方法的连接点，即仅能在方法调用前、方法调用后、方法抛出异常时以及方法调用前后这些程序执行点织入增强。2）切点（Pointcut）&nbsp;&nbsp;&nbsp;&nbsp;每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物。AOP 通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件。切点和连接点不是一对一的关系，一个切点可以匹配多个连接点。3）通知或增强（Advice）&nbsp;&nbsp;&nbsp;&nbsp;增强是织入到目标类连接点上的一段程序代码，在 Spring 中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位。结合执行点方位信息和切点信息，我们就可以找到特定的连接点。4）目标对象（Target）&nbsp;&nbsp;&nbsp;&nbsp;增强逻辑的织入目标类。如果没有 AOP，目标业务类需要自己实现所有逻辑，而在 AOP的帮助下，目标业务类只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑则可以使用 AOP 动态织入到特定的连接点上。5）引介（Introduction）&nbsp;&nbsp;&nbsp;&nbsp;引介是一种特殊的增强，它为类添加一些属性和方法。这样 ，即使一个业务类原本没有实现某个接口，通过 AOP 的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。6）织入（Weaving）&nbsp;&nbsp;&nbsp;&nbsp;织入是将增强添加对目标类具体连接点上的过程。AOP 像一台织布机，将目标类、增强或引介通过 AOP 这台织布机天衣无缝地编织到一起。根据不同的实现技术，AOP 有三种织入的方式： a、编译期织入，这要求使用特殊的 Java 编译器。b、类装载期织入，这要求使用特殊的类装载器。c、动态代理织入，在运行期为目标类添加增强生成子类的方式。Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 7）代理（Proxy）&nbsp;&nbsp;&nbsp;&nbsp;一个类被 AOP 织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以我们可以采用调用原类相同的方式调用代理类。8）切面（Aspect）&nbsp;&nbsp;&nbsp;&nbsp;切面由切点和增强（引介）组成，它既包括了横切逻辑的定义，也包括了连接点的定义，Spring AOP 就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的连接点中。 对于 Spring 中的 AOP 术语，确实不好理解，为了帮助大家理解这些术语，我们想象一 下这样的场景： 1、有 2 条高速公路可以通向北京，分别为 A,B（相当于 2 个目标个业务 Target（功能） 2、每条高速公路上有 3 个服务站（相当于每个业务上的连接点（Joinpoint）有 3 个） 3、在每条高速公路的第 2 个服务站需要测速（相当于一个切点（Pointcut），匹配了 3 个连接点） 4、在第一条(A)进入服务站之前进行测速，在第二条(b)进入服务站之后测速（通知或增强 Advice，其实也定义了调用测速功能进行测速，以及怎么测） 5、每条高速路第 2 个服务站加入测速功能，这件事情相当于切面 Aspect，它包含了测速功能的定义与切点的定义 6、将测速功能应用到服务站上，这个过程叫织入（Weaving） AOP的实现原理接下来是重点，我们来学习一下AOP的实现原理，并利用原理自己手动实现AOP。AOP底层采用代理机制进行实现，具体的实现方法有以下两种: 1）接口+实现类：采用jdk的动态代理 2）使用实现类：Spring采用了cglib字节码增强 接下来我们就用这两个原理分别自己手动实现AOP。 使用jdk的动态代理实现实现思路：使用jdk中的Proxy类的newProxyInstance方法来获得一个代理对象，在使用的时候就使用这个代理对象而不直接去new对象，关于方法的细节如下： 1234public static Object newProxyInstance( ClassLoader loader, 类加载器，写当前类的类加载器 Class&lt;?&gt;[] interfaces, 接口，就是你要增强的业务类的接口 InvocationHandler h)&#123;&#125; 处理器，可以自己实现InvocationHandler接口的invkoe方法实现一个处理器 步骤：1.写一个普通的接口以及这个接口的实现类2.写一个切面类（就是一个普通的java类，里面的方法写要增强的功能）3.上面的操作完成后，在工厂类（为了方便，当然也可以不写这个工厂类）中首先创建一个目标类对象（就是new一个业务类的对象），接着new一个切面类对象，使用动态代理把切面类中的增强功能织入到目标方法的前后，下面是示例代码：一个业务类接口：UserServiceBase.java 123456789101112131415161718192021package com.xzy.sevice;public interface UserSeviceBase &#123; /** * 增加用户 */ public void addUser(); /** * 删除用户 * @param id */ public void deleteUser(int id); /** * 更新用户 * @param id */ public void updateUser(int id);&#125; 业务类接口实现类：UserSeviceImpi.java 123456789101112131415161718package com.xzy.sevice;public class UserSeviceImpi implements UserSeviceBase &#123; @Override public void addUser() &#123; System.out.println("增加了1个用户"); &#125; @Override public void deleteUser(int id) &#123; System.out.println("删除了id为"+id+"的用户"); &#125; @Override public void updateUser(int id) &#123; System.out.println("id为"+id+"的用户更新了"); &#125;&#125; 写一个切面类：MyAspect.java 1234567891011121314151617package com.xzy.aspect;import java.util.Date;//切面类:就是一段增强功能的代码public class MyAspect &#123; public void before()&#123; System.out.println(".......执行操作前日志......."+new Date()); &#125; public void after()&#123; System.out.println(".......执行操作后日志......."+new Date()); &#125;&#125; 写一个工厂类，专门用于生产代理对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.xzy.sevice;import com.xzy.aspect.MyAspect;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ServiceFactory &#123; /** * 产生一个 UserSevice * * @return */ public static UserSeviceBase createUserService() &#123; //1.创建目标对象 final UserSeviceBase userSevice = new UserSeviceImpl(); //2.声明切面类 final MyAspect aspect = new MyAspect(); //3.使用动态代理来把切面类中的增强方法切入目标方法前后 UserSeviceBase proxyService = (UserSeviceBase) Proxy.newProxyInstance( ServiceFactory.class.getClassLoader(), userSevice.getClass().getInterfaces(), //InvocationHandler是一个接口，它里面只有一个invoke方法，这里也可以在外面单独写一个类实现InvocationHandler接口，然后在这里new这个类的对象也可以 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //目标方法开始前的增强代码 aspect.before(); //通过反射调用目标方法 Object obj = method.invoke(userSevice, args); //目标方法执行后的增强代码 aspect.after(); return obj; &#125; &#125; ); return proxyService; //返回代理对象 &#125;&#125; 测试： 1234567891011121314151617181920212223package com.xzy;import com.xzy.sevice.ServiceFactory;import com.xzy.sevice.UserSeviceBase;import org.junit.Test;/** * Unit test for simple App. */public class AppTest &#123; /** * 使用Java的动态代理机制，手动实现AOP编程 */ @Test public void test1()&#123; //直接从工厂中拿代理对象 UserSeviceBase userSevice= ServiceFactory.createUserService(); userSevice.deleteUser(10); userSevice.updateUser(3); userSevice.addUser(); &#125;&#125; 测试结果： 使用Cglib实现&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，可能需要对没有实现接口的类增强，用JDK动态代理的方式就没法实现。采用Cglib动态代理可以对没有实现接口的类产生代理，实际上是生成了目标类的子类来增强。 首先，需要导入Cglib所需的jar包，Maven依赖写法如下： 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt; 还是需要一个业务类（这次不需要接口了）以及一个切面类，前面写过，这里就跳过了。接着在刚才的工厂类中再写一个方法createUserService2()，步骤还是那几步，只不过这次是用cglib提供的api来写，具体如下： 123456789101112131415161718192021222324252627282930/* *使用cglib实现AOP * */ public static UserSeviceBase createUserService2() &#123; //1.创建目标对象 final UserSeviceImpl userSevice = new UserSeviceImpl(); //2.声明切面类 final MyAspect aspect = new MyAspect(); //3.cglib核心类Enhancer Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(userSevice.getClass()); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; aspect.before(); /* *proxy代理是目标类的子类 */ Object obj = methodProxy.invoke(userSevice, args); aspect.after(); return obj; &#125; &#125;); UserSeviceImpl proxy = (UserSeviceImpl) enhancer.create(); return proxy; //返回代理对象 &#125; 测试： 1234567891011121314151617181920212223package com.xzy;import com.xzy.sevice.ServiceFactory;import com.xzy.sevice.UserSeviceBase;import org.junit.Test;/** * Unit test for simple App. */public class AppTest &#123; /** * 使用cglib手动实现AOP编程 */ @Test public void test2()&#123; UserSeviceBase userSevice= ServiceFactory.createUserService2(); userSevice.deleteUser(10); userSevice.updateUser(3); userSevice.addUser(); &#125;&#125; 测试结果： 可以看到结果和刚才用JDK动态代理的结果一样，但是这里要特别注意： jdk代理只能动态代理接口+实现类的形式； Cglib代理的优势是可以直接代理普通的类，但同时接口也可以]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC高级依赖注入]]></title>
    <url>%2F2019%2F08%2F02%2FSpringIOC%E9%AB%98%E7%BA%A7%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[环境与 Profile&nbsp;&nbsp;&nbsp;&nbsp;在开发中我们测试用一套数据库，开发用一套数据库，而且要将应用程序从一个环境迁移到 另一个环境，Spring 允许我们定义多套配置，可以配置声明应用哪套配置的 Bean 1 Profile Spring中的Profile是什么？ &nbsp;&nbsp;&nbsp;&nbsp;Spring中的Profile功能其实早在Spring 3.1的版本就已经出来，它可以理解为我们在Spring容器中所定义的Bean的逻辑组名称，只有当这些Profile被激活的时候，才会将Profile中所对应的Bean注册到Spring容器中。举个更具体的例子，我们以前所定义的Bean，当Spring容器一启动的时候，就会一股脑的全部加载这些信息完成对Bean的创建；而使用了Profile之后，它会将Bean的定义进行更细粒度的划分，将这些定义的Bean划分为几个不同的组，当Spring容器加载配置信息的时候，首先查找激活的Profile，然后只会去加载被激活的组中所定义的Bean信息，而不被激活的Profile中所定义的Bean定义信息是不会加载用于创建Bean的。 Profile有什么用？ &nbsp;&nbsp;&nbsp;&nbsp;由于我们平时在开发中，通常会出现在开发的时候使用一个开发数据库，测试的时候使用一个测试的数据库，而实际部署的时候需要一个数据库。以前的做法是将这些信息写在一个配置文件中，当我把代码部署到测试的环境中，将配置文件改成测试环境；当测试完成，项目需要部署到现网了，又要将配置信息改成现网的，真的好烦。。。而使用了Profile之后，我们就可以分别定义3个配置文件，一个用于开发、一个用户测试、一个用户生产，其分别对应于3个Profile。当在实际运行的时候，只需给定一个参数来激活对应的Profile即可，那么容器就会只加载激活后的配置文件，这样就可以大大省去我们修改配置信息而带来的烦恼。 方式一：用xml配置profile 123456789101112131415161718192021222324252627Application.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:jee="http://www.springframework.org/schema/jee" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation=" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:dev-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jdbc:embedded-database id="dataSource" type="H2"&gt; &lt;jdbc:script location="classpath:schema.sql" /&gt; &lt;jdbc:script location="classpath:prod-data.sql" /&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt;&lt;/beans&gt; 方式二：用Annotation配置profile，这种方式配置和用xml配置是等价的 12345678910111213141516171819202122232425@Configurationpublic class DataSourceConfig &#123; //Spring 引入@Profile 制定某个bean属于哪个profile //在方法级别上使用@Profile注解 @Bean @Profile("dev") public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:dev-data.sql") .build(); &#125; @Bean @Profile("prod") public DataSource embeddedDataSourceDev() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:prod-data.sql") .build(); &#125;&#125; 在同一个类的不同方法上使用@Profile注解与@Bean一起使用激活profileSpring在确定哪个profile处于激活状态时，需要依赖两个独立属性：sping.profiles.active和spring.profiles.default。Spring提供了@ActiveProfiles用来指定运行测试时要激活哪个profile,如果没有指定sping.profiles.active，会采用spring.profiles.default的默认值。 测试代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.xzy;import static org.junit.Assert.*;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import javax.sql.DataSource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.myapp.DataSourceConfig;public class DataSourceConfigTest &#123; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(classes=DataSourceConfig.class) @ActiveProfiles("dev") public static class DevDataSourceTest &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1, results.size()); assertEquals("1:A", results.get(0)); &#125; &#125; @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration("classpath:datasource-config.xml") @ActiveProfiles("prod") public static class ProductionDataSourceTest_XMLConfig &#123; @Autowired private DataSource dataSource; @Test public void shouldBeEmbeddedDatasource() &#123; assertNotNull(dataSource); JdbcTemplate jdbc = new JdbcTemplate(dataSource); List&lt;String&gt; results = jdbc.query("select id, name from Things", new RowMapper&lt;String&gt;() &#123; @Override public String mapRow(ResultSet rs, int rowNum) throws SQLException &#123; return rs.getLong("id") + ":" + rs.getString("name"); &#125; &#125;); assertEquals(1, results.size()); assertEquals("1:B", results.get(0)); &#125; &#125;&#125; 条件化Bean&nbsp;&nbsp;&nbsp;&nbsp;Spring 4 引入了一个新的@Conditional 注解，它可以用到带@Bean 注解的方法上，如果条件计算结果为 true，就会创建个 Bean设置给@Conditional 的类可以是任意实现了 Condition 接口的类型,如果matches()方法返回true，那么就会创建带有@Conditional注解的bean。若返回false，将不会创建这些bean。其中: ConditionContext ： getRegistry()：返回的 BeanDefinitionRegistry 检查 Bean 定义： getBeanFactory()：返回 ConfigurableListableBeanFactory 检查 Bean 是否存在 getEnvironments()：返回 Environment 检查环境变量是否存在以及它的值是什么 getResourceLoader()：返回 ResourceLoader 所加载的瓷源 getClassLoader()：返回 ClassLoder 加载并检查是否存在 AnnotatedTypeMetadata ：可以让我们检查带@Bean 注解的方法上还有什么其它注解，它也是一个接口 举个栗子：写个条件类，实现Condition接口的matches方法，简单的判断一下当前的系统是不是Windows 7的，如果是返回true,否则返回false 12345678910111213141516171819package com.xzy.utils;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class StudentCondition implements Condition &#123; @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env = context.getEnvironment(); System.out.println(env.toString()); if("Windows 7".equals(env.getProperty("os.name")))&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 测试代码： 123456789101112131415161718192021package com.xzy.utils;import com.xzy.bean.Student;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Conditional;import org.springframework.context.annotation.Configuration;@Configurationpublic class ConditionTest &#123; //只用这个条件为true才能产生Student,否则spring压根就不会理他 @Bean @Conditional(StudentCondition.class) public Student appConfig()&#123; Student student=new Student(); student.setName("晓明"); student.setAge(34); return student; &#125;&#125; 测试代码： 程序运行结果： 如果把“Windows 7”改成“Windows 10”就是条件Bean就会返回false,由于无法正常的注入就会出现以下的异常： 1org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.xzy.AppTest': Unsatisfied dependency expressed through field 'student'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.xzy.bean.Student' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true), @org.springframework.beans.factory.annotation.Qualifier(value=appConfig)&#125;]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC Container]]></title>
    <url>%2F2019%2F08%2F02%2FSpringIOC%2F</url>
    <content type="text"><![CDATA[什么是Spring IOC 和DI 控制反转（Inversion of Control，IoC） 所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的。这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。 依赖注入（Dependency Injection，DI） 在运行期，由外部容器动态地将依赖对象注入到组件中。换句话说，就是在运行时能 Bean对象设置属性值 bean标签 一个bean标签代表一个spring容器中的java对象，可以在bean中经常使用的属性如下:1. id 属性 ：起名称 不能包含特殊符号 根据id 获得配置对象 2. class属性：创建对象所在全路径 3. name属性：功能和id一样 ，id不能包含特殊符号，name可以（基本不用，为了满足struts1遗留问题） 4. scope属性：Bean的作用范围，scope常用的值有：-singleton 和 -prototype，分别表示单例和多例,如果没写默认就是单例 Bean的3种实例化方式 1.直接使用bean标签来实例化pojo，这中方法Spring默认调用的是这个pojo的无参构造器来实例化bean对象的 首先创建一个EmailDaoImpl.java 12345678910package com.xzy.dao.Impl;import com.xzy.dao.EmailDao;public class EmailDaoImpl implements EmailDao &#123; @Override public void sent() &#123; System.out.println("发送email&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); &#125;&#125; 在ApplicationContext.xml文件中使用&lt;bean id=“” class=”” /&amp;gt标签配置bean: 12 &lt;!--1.直接使用bean class来实例化--&gt;&lt;bean id="email" class="com.xzy.dao.Impl.EmailDaoImpl"/&gt; 经过这两步就配置好了一个bean,测试代码简单，就是调用了一下sent方法，下面是执行的结果： 2.使用静态工厂实例化pojo 首先新建一个静态工厂DaoFactory.java 12345678910111213package com.xzy.dao;import com.xzy.dao.Impl.EmailDaoImpl;public class DaoStaticFactory &#123; /** * 静态工厂实例化bean * @return */ public static EmailDao createInstance()&#123; return new EmailDaoImpl(); &#125;&#125; 接着在xml中配置如下： 1&lt;bean id="email1" class="com.xzy.dao.DaoStaticFactory" factory-method="createInstance"/&gt; 执行结果和上面的的一样，这里不再展示了。 3.使用实例化工厂实例化pojo 首先新建一个实例化工厂： 123456789101112package com.xzy.dao;import com.xzy.dao.Impl.EmailDaoImpl;/** * 实例工厂实例化bean */public class DaoInstanceFactory &#123; public EmailDao createInstance()&#123; return new EmailDaoImpl(); &#125;&#125; 在xml文件中配置如下： 123&lt;!--3.通过实例工厂实例化bean--&gt;&lt;bean id="factory" class="com.xzy.dao.DaoInstanceFactory"/&gt;&lt;bean id="email2" factory-bean="factory" factory-method="createInstance"/&gt; 依赖注入的2种常用方式 1. 构造方法注入2. setter方法注入 首先，新建学生实体类Student: 123456789101112131415161718192021222324252627package com.xzy.bean;import org.springframework.stereotype.Component;import java.util.Properties;public class Student &#123; private int age; private String name; private Teacher tea; private Properties info=null; public Student()&#123; System.out.println("默认调用无参构造方法实例化bean"); &#125; public Student(int age, String name) &#123; this.age = age; this.name = name; &#125; public Student(String name, Teacher tea) &#123; this.name = name; this.tea = tea; &#125; //省略getter,setter...... 1. 使用构造方法注入在xml中配置如下，正常情况下只用指定参数的名字和参数的值：&lt;constructor-arg name=”” value=”” /&gt;,name就是构造方法中的参数名，value即使这个参数的值 12345 &lt;!--1.构造方法注入--&gt;&lt;bean id="student" class="com.xzy.bean.Student"&gt; &lt;constructor-arg name="age" value="20" /&gt; &lt;constructor-arg name="name" value="小明" /&gt;&lt;/bean&gt; 程寻运行的结果： 当构造方法出现命名冲突的时候，可以使用type属性指定参数对java类型： 12345 &lt;!--当构造方法中出现命名冲突的时候，还可以使用type属性指定参数的类型--&gt;&lt;bean id="student" class="com.xzy.bean.Student"&gt; &lt;constructor-arg value="20" type="int"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value="小红" type="java.lang.String"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 程寻运行的结果： 2. settrt方法注入,这种方法和实例化bean相同，都是用了property属性 1234567891011&lt;bean id="student" class="com.xzy.bean.Student"&gt; &lt;property name="age" value="#&#123;25*7-20*7&#125;"&gt;&lt;/property&gt; &lt;property name="name" value="#&#123;'aaaaaaa'.toUpperCase()&#125;"&gt;&lt;/property&gt; &lt;property name="tea" value="#&#123;teacher&#125;"&gt;&lt;/property&gt; &lt;property name="info"&gt; &lt;value&gt; jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mydb &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 程寻运行的结果： SpEL（Spring表达式）&nbsp;&nbsp;&nbsp;&nbsp;SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言。为什么要总结SpEL，因为它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构。个人认为很有用。&nbsp;&nbsp;&nbsp;&nbsp;SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。下面说一下它最基础最重要的一种用法：xml配置法。（使用注解的方式的语法和xml方式的语法一样的，只是使用注解会更方便）SpEL的基本语法有以下几条 语法格式`` #{123}、#{'字符串'} ：数字、字符串 #{beanId}：对另一个bean的引用，类似ref属性 #{beanId.propName}:：操作数据 #{beanId.toString()}：执行方法 #{T(类).字段|方法}：静态方法或字段 Spring表达式支持大多数的数学操作符、逻辑操作符、关系操作符。1.关系操作符包括：等于 (==, eq)，不等于 (!=, ne)，小于 (&lt;, lt),，小于等于(&lt;= ,le)，大于(&gt;, gt)，大于等于 (&gt;=, ge)2.逻辑操作符包括：and，or，and not(!)3.数学操作符包括：加 (+)，减 (-)，乘 (*)，除 (/)，取模 (%)，幂指数 (^)。 新建一个实体Customer 12345678910111213141516171819202122package com.xzy.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Customer &#123; private String name; private String sex="男"; private double pi;@Override public String toString() &#123; return "Customer&#123;" + "name='" + name + '\'' + ", sex='" + sex + '\'' + ", pi=" + pi '&#125;'; &#125; 在配置文件中如下配置： 1234567&lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;!--操作字段：#&#123;ref.Field&#125;--&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;!--静态字段：#&#123;T.(TYPE).staticField&#125;--&gt; &lt;property name="pi" value="#&#123;T(Math).PI&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; 程序的执行结果如下： 剩下的各种运算就不在这里试了，有兴趣的话可以自己尝试。 集合类型注入&nbsp;&nbsp;&nbsp;&nbsp;官方的一句话:In the &lt;list/&gt;, &lt;set/&gt;, &lt;map/&gt;, and &lt;props/&gt; elements, you set the properties and arguments of the Java Collection types List, Set, Map, and Properties, respectively.就是说，你可以用&lt;list&gt;、set、map、props来配置对应的Java集合类型：List、Set、Map、以及Array(数组),以及Properties也可以配置。举个栗子： 在上例Customer实体类的基础上修改，分别增加List属性、Set属性、Map属性和数组属性一个，具体代码如下： 1234567891011121314151617181920212223242526272829package com.xzy.bean;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Set;public class Customer &#123; private String name; private String sex="男"; private List&lt;String&gt; shopCar; //购物车 private Set&lt;String&gt; price; //价格 private Map&lt;String,Double&gt; goods; //物品 private String[] address; //地址 //省略getter、setter.... @Override public String toString() &#123; return "Customer&#123;" + "name='" + name + '\'' + ", sex='" + sex + '\'' + ", shopCar=" + shopCar + ", price=" + price + ", goods=" + goods + ", address=" + Arrays.toString(address) + '&#125;'; &#125;&#125; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--List注入使用&lt;list&gt;元素 --&gt; &lt;property name="shopCar"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;set&gt;标签给Set类型注入初始值： 123456789101112131415&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--Set注入使用&lt;set&gt;元素 --&gt; &lt;property name="price"&gt; &lt;set&gt; &lt;value&gt;"#&#123;3.5*6&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;2000*2&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;100*6&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;5000*1&#125;"&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;map&gt;标签给Map类型注入初始值： 12345678910111213141516&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--Map输注入 使用&lt;map&gt;元素，特别注意，使用&lt;entry&gt;来指定一条数据的key和value --&gt; &lt;property name="goods"&gt; &lt;map&gt; &lt;entry key="p1" value="23"&gt;&lt;/entry&gt; &lt;entry key="p2" value="24"&gt;&lt;/entry&gt; &lt;entry key="p3" value="25"&gt;&lt;/entry&gt; &lt;entry key="p4" value="26"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--List注入使用&lt;list&gt;元素 --&gt; &lt;property name="shopCar"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 使用&lt;list&gt;标签给List类型注入初始值： 1234567891011121314&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--数组注入使用&lt;array&gt;元素 --&gt; &lt;property name="address"&gt; &lt;array&gt; &lt;value&gt;西安&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;南京&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 最后，对于customer的DI配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!--bean的集合注入--&gt; &lt;bean id="customer" class="com.xzy.bean.Customer"&gt; &lt;property name="name" value="#&#123;student.name&#125;"&gt;&lt;/property&gt; &lt;property name="sex" value="#&#123;'女'&#125;"&gt;&lt;/property&gt; &lt;!--List注入 使用&lt;list&gt;元素 --&gt; &lt;property name="shopCar"&gt; &lt;list&gt; &lt;value&gt;书&lt;/value&gt; &lt;value&gt;手机&lt;/value&gt; &lt;value&gt;衣服&lt;/value&gt; &lt;value&gt;电脑&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Set注入 使用&lt;set&gt;元素 --&gt; &lt;property name="price"&gt; &lt;set&gt; &lt;value&gt;"#&#123;3.5*6&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;2000*2&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;100*6&#125;"&lt;/value&gt; &lt;value&gt;"#&#123;5000*1&#125;"&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--Map输注入 使用&lt;map&gt;元素，特别注意，使用&lt;entry&gt;来指定一条数据的key和value --&gt; &lt;property name="goods"&gt; &lt;map&gt; &lt;entry key="p1" value="23"&gt;&lt;/entry&gt; &lt;entry key="p2" value="24"&gt;&lt;/entry&gt; &lt;entry key="p3" value="25"&gt;&lt;/entry&gt; &lt;entry key="p4" value="26"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--数组注入 使用&lt;array&gt;元素 --&gt; &lt;property name="address"&gt; &lt;array&gt; &lt;value&gt;西安&lt;/value&gt; &lt;value&gt;北京&lt;/value&gt; &lt;value&gt;南京&lt;/value&gt; &lt;value&gt;广州&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 程序执行结果： 使用Annotation自动装配扫描要使用Anntation配置spring容器，首先需要在ApplicationContext.xml文件中配置如下信息： 1234&lt;!--开启注解--&gt;&lt;context:annotation-config/&gt;&lt;!--告诉Spring去扫描哪里--&gt;&lt;context:component-scan base-package="com.xzy"&gt;&lt;/context:component-scan&gt; 设置组件与bean命名 1.@Repository, @Service, and @Controller,@Component 这 四 个 Annotation 功 能 相 同都是声明一个bean组件，不同的是 @Repository 用于持久层，也就是Dao层。 @Service 用于服务层（业务层）。 @controller 用于控制器层。 @Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。例如对pojo实体可以使用他 都是用在类上的 Annotation，说明让Spring 实例化此类的对像，并放入 spring 容器中 2.@componet(“id”)其中 id 声明 bean 对像的名字 举个栗子：新建Student.java 12345678910111213141516171819202122232425package com.xzy.bean;import org.springframework.stereotype.Component;@Component //这一句就是告诉Spring这是个普通的组件public class Student &#123; private int age; private String name; public Student() &#123; System.out.println("1.实例化了bean。。。。。"); &#125; //省略getter、setter @Override public String toString() &#123; return "Student&#123;" + "age=" + age + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 测试代码： 12345678910111213141516171819202122232425262728package com.xzy;import com.xzy.bean.Student;import org.apache.log4j.Logger;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * Unit test for simple App. */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(value=&#123;"/ApplicationContext.xml"&#125;)public class AppTest &#123; private static Logger log=Logger.getLogger(AppTest.class); @Autowired //自动注入，Spring会为我们自动从容器中找到student的对象然后注入这里的变量 private Student student; @Test public void test01()&#123; System.out.println(student); &#125;&#125; 程序运行结果： @Repository, @Service, and @Controller新建StudentDao以及StudentDaoImpl 1234567891011121314StudentDaopackage com.xzy.Dao;import com.xzy.bean.Student;public interface StudentDao &#123; /** * 增加一个学生 * @param stu * @return */ public void addStudent(Student stu);&#125; 写一个StudentDaoImpi，模拟DAO层，并使用@Respositiry告诉Spring这是DAO层的组件 1234567891011121314151617181920212223StudentDaoImplpackage com.xzy.Dao.DaoImpi;import com.xzy.Dao.StudentDao;import com.xzy.bean.Student;import org.springframework.stereotype.Repository;@Repositorypublic class StudentDaoImpi implements StudentDao &#123; public StudentDaoImpl() &#123; System.out.println("Repository层实例化"); &#125; @Override public void addStudent(Student stu) &#123; System.out.print("3.Dao层处理数据："); System.out.println("向数据库发一条insert语句添加一个学生:"+stu.getName()); &#125;&#125; 新建StudentService.java，模拟Service层，使用@Service注解告诉Spring这是一个Service的组件 1234567891011121314151617181920212223StudentService.javapackage com.xzy.Service;import com.xzy.Dao.StudentDao;import com.xzy.bean.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class StudentService &#123; public StudentService() &#123; System.out.println("Service层实例化"); &#125; @Autowired private StudentDao stuImp; public void add(Student stu)&#123; System.out.println("2.service层收到控制层的数据后发给Dao层"); stuImp.addStudent(stu); &#125;&#125; 新建StudentServlet.java，模拟控制器层，并使用@Controller注解告诉Spring这是控制器。 123456789101112131415161718192021222324252627StudentServlet.javapackage com.xzy.Servlet;import com.xzy.Service.StudentService;import com.xzy.bean.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class StudentServlet &#123; public StudentServlet() &#123; System.out.println("Controller层实例化"); &#125; @Autowired private StudentService stuService; @Autowired private Student stu; public void addAction() &#123; System.out.println("1.控制层发数据给sevice层"); stu.setAge(23); stu.setName("狗子"); stuService.add(stu); &#125;&#125; 最终的执行结果： 注意注入的顺序：把DAO实现类注入到service实现类中，把service的接口(注意不要是service的实现类)注入到controller中 设置组件扫描的base-packages @Configuration@ComponentScan(“基包名”)Public class AppConfig{} @Configuration@ComponentScan(basepackages=“基包名”)Public class AppConfig{} @Configuration@ComponentScan(basepackages={“基包名”,”…”})Public class AppConfig{} @Configuration@ComponentScan(basePackageClasses={App1Config.class,App2Config.class})Public class AppConfig{}以上 App1Config 与 App2Config 所在的包作为组件扫描的基础包 Annotation 自动装配 1.@Autowired 自动装配和 JSR 330’s @Inject 对应，可用在构造方法、属性 setter 方法，有属性@Autowired(required=false)@Primary 用于声明 bean 的首先，用在多个 bean，无法选择装配谁的情况可以指明使用哪个 2.@Required 声明依赖必须提供 用在 setter 方法@Requiredpublic void setMovieFinder(MovieFinder movieFinder) {this.movieFinder = movieFinder;} 3.@Qualifiers 注明要装配 bean 的标识，用于多个 bean 无法确定装配哪个的情况 处理自动装配的歧义Spring提供的自动装配是非常好用，可是用这么个问题：比如，一个接口有三个实现类，当要将接口类型自动装配置时，就出现不唯一的问题，Spring 会抛出 NoUniqueBeanDefinitionException。正如下面这种情况：写一个接口： 123456789package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic interface ReadData &#123; public void read();&#125; 接口的三个实现类： 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class USBRead implements ReadData &#123; @Override public void read() &#123; System.out.println("USB读取数据....."); &#125;&#125; 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class SSDRead implements ReadData &#123; @Override public void read() &#123; System.out.println("SSD读取数据......"); &#125;&#125; 1234567891011package com.xzy.utils;import org.springframework.stereotype.Component;@Componentpublic class BlueRead implements ReadData &#123; @Override public void read() &#123; System.out.println("蓝牙读取数据......."); &#125;&#125; 这时如果让Spring给我们自动装配，他都懵逼了，因为这个接口有3个实现类，都可以装配，他不知道装配那个，如下图所示： 此时如果直接运行就会发生如下异常： 122019-08-01 21:49:51 [ERROR]-[org.springframework.test.context.TestContextManager] Caught exception while allowing TestExecutionListener [org.springframework.test.context.support.DependencyInjectionTestExecutionListener@685cb137] to prepare test instance [com.xzy.AppTest@50a638b5] org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'com.xzy.AppTest': Unsatisfied dependency expressed through field 'read'; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.xzy.utils.ReadData' available: expected single matching bean but found 3: blueRead,SSDRead,USBRead 解决办法解决方法1：在实现类的头上使用@Primary注解告诉Spring首选哪个装配，比如在USBRead类的头上加上@Primary： 解决方法2：使用@Qualifier 注解限定自动装配的 Bean]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识Spring框架]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%AE%A4%E8%AF%86Spring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring 框架是 Java 应用最广的框架，它的成功来源于理念，而不是技术本身，它的理念包括 IoC (Inversion of Control，控制反转) 和 AOP(Aspect Oriented Programming，面向切面编程)。 什么是 Spring?1). Spring 是一个轻量级的 DI / IoC 和 AOP 容器的开源框架，来源于 Rod Johnson 在其著作《Expert one on one J2EE design and development》中阐述的部分理念和原型衍生而来。2).Spring 提倡以“最少侵入”的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring3).适用范围：任何 Java 应用4).Spring 的根本使命：简化 Java 开发 Spring 中常用术语：框架：是能完成一定功能的半成品。框架能够帮助我们完成的是：项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。 非侵入式设计： 从框架的角度可以理解为：无需继承框架提供的任何类这样我们在更换框架时，之前写过的代码几乎可以继续使用。 轻量级和重量级： 轻量级是相对于重量级而言的，轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等，其实就是比较容易使用，而重量级正好相反。 JavaBean： 即符合 JavaBean 规范的 Java 类 POJO：即 Plain Old Java Objects，简单老式 Java 对象它可以包含业务逻辑或持久化逻辑，但不担当任何特殊角色且不继承或不实现任何其它Java框架的类或接口。 > 注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。 容器： 在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是装对象的的对象，因为存在放入、拿出等操作，所以容器还要管理对象的生命周期。 Spring 的优势低侵入 / 低耦合 （降低组件之间的耦合度，实现软件各层之间的解耦） 声明式事务管理（基于切面和惯例） 方便集成其他框架（如MyBatis、Hibernate） 降低 Java 开发难度 Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式） Spring能帮我们做什么?①.Spring 能帮我们根据配置文件创建及组装对象之间的依赖关系。②.Spring 面向切面编程能帮助我们无耦合的实现日志记录，性能统计，安全控制。③.Spring 能非常简单的帮我们管理数据库事务。④.Spring 还提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成，而且自己也提供了一套JDBC访问模板来方便数据库访问。⑤.Spring 还提供与第三方Web（如Struts1/2、JSF）框架无缝集成，而且自己也提供了一套Spring MVC框架，来方便web层搭建。⑥.Spring 能方便的与Java EE（如Java Mail、任务调度）整合，与更多技术整合（比如缓存框架）。 Spring的框架体系结构： Data Access/Integration层包含有JDBC、ORM、OXM、JMS和Transaction模块。 Web层包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。 AOP模块提供了一个符合AOP联盟标准的面向切面编程的实现。 Core Container(核心容器)：包含有Beans、Core、Context和SpEL模块。 Test模块支持使用JUnit和TestNG对Spring组件进行测试。 下面介绍这5个部分的jar以及依赖关系 Core core部分包含4个模块: spring-core：这个jar 文件包含Spring 框架基本的核心工具类。Spring 其它组件要都要使用到这个包里的类，是其它组件的基本核心。外部依赖Commons Logging， (Log4J)。 spring-beans：这个jar 文件是所有应用都要用到的，它包含访问配置文件、创建和管理bean 以及进行Inversion ofControl / Dependency Injection（IoC/DI）操作相关的所有类。如果应用只需基本的IoC/DI 支持，引入spring-core.jar 及spring-beans.jar 文件就可以了。 spring-context：spring的context上下文即IoC容器 spring-expression：一个强大的表达式语言，用于在运行时查询和处理对象图。该语言支持设置和获取属性值；属性赋值，方法调用，访问数组的内容，收集和索引器，逻辑和算术运算，命名变量，并从Spring的IOC容器的名字对象检索，它也支持列表选择和投影以及常见的列表聚合。 它们的依赖关系 Maven依赖写法如下： 12345678910111213141516171819202122232425262728293031&lt;!--Core：spring-core、spring-beans、spring-content、spring-expression--&gt;&lt;!--Spring核心--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--Spring IOC容器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--Spring Bean工厂--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpEL(Spring表达式)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; AOP aop部分包含4个模块: spring-aop：这个jar 文件包含在应用中使用Spring 的AOP 特性时所需的类和源码级元数据支持。使用基于AOP 的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes) spring-aspects：提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中，比如Eclipse AJDT。 spring-instrument：提供一些类级的工具支持和ClassLoader级的实现，用于服务器 spring-instrument-tomcat：针对tomcat的instrument实现 它们的依赖关系 Maven依赖写法如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!--AOP：spring-aop、spring-aspectj、spring-instrument、spring-instrument-tomcat--&gt;&lt;!--spring aop：外部依赖spring-core， (spring-beans，AOP Alliance， CGLIB，Commons Attributes)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--提供对AspectJ的支持，以便可以方便的将面向切面的功能集成进IDE中--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectj的runtime包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--aspectjweaver是aspectj的织入包(必须)--&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Data Accessdata access部分包含5个模块 spring-jdbc：这个jar 文件包含对Spring 对JDBC 数据访问进行封装的所有类。 spring-tx：为JDBC、Hibernate、JDO、JPA、Beans等提供的一致的声明式和编程式事务管理支持。 spring-orm：包含Spring对DAO特性集进行了扩展，使其支持iBatis(MyBatis)、JDO、OJB、TopLink， 因为Hibernate已经独立成包了，现在不包含在这个包里了。这个jar文件里大部分的类都要依赖spring-dao.jar里的类，用这个包时你需要同时包含spring-dao.jar包。 spring-oxm：Spring 对Object/XMl的映射支持,可以让Java与XML之间来回切换。 spring-jms：这个jar包提供了对JMX 1.0/1.2的支持类。java消息服务与Spring-massaging对应。外部依赖spring-beans，spring-aop， JMXAPI。 它们的依赖关系 Maven依赖写法如下： 12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Webweb部分包含4个模块 spring-web：这个jar 文件包含Web 应用开发时，用到Spring 框架时所需的核心基础类，包括自动载入Web ApplicationContext 特性的类、Struts 与JSF 集成类、文件上传的支持类、Filter 类和大量工具辅助类。 spring-webmvc：这个jar 文件包含Spring MVC 框架相关的所有类。包括框架的Servlets，Web MVC框架，控制器和视图支持。当然，如果你的应用使用了独立的MVC 框架，则无需这个JAR 文件里的任何类。外部依赖spring-web, (spring-support，Tiles，iText，POI)。 spring-webmvc-portlet：基于portlet的mvc实现 spring-websocket：Spring4以后为web应用提供的高效通信工具 spring-messaging：Spring4以后提供用于构建基于消息的应用程序 spring-struts：与struts的集成，不推荐，spring4不再提供 它们的依赖关系 Maven依赖写法如下： 1234567891011&lt;!--Spring Web：spring-web、spring-webmvc、spring-webmvc-portlet--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; Testtest部分只有一个模块，我将spring-context-support也放在这吧 spring-test：Spring-test支持spring组建junit或TestNG的集成测试和单元测试。它提供了一致spring ApplicationContext的加载和上下文的缓存。他还提供了可以用来测试代码隔离的模拟对象。 spring-context-support：包含支持缓存Cache（ehcache）、JCA、JMX、 邮件服务（Java Mail、COS Mail）、任务计划Scheduling（Timer、Quartz）方面的类。 它们的依赖关系 Maven依赖写法如下： 1234567891011&lt;!--Spring Test：spring-test--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis分页插件PageHelper]]></title>
    <url>%2F2019%2F07%2F29%2FMybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%2F</url>
    <content type="text"><![CDATA[PageHelper简介这是一个基于MyBatis开源的分页插件，使用非常方便，支持各种复杂的单表、多表分页查询，让你在写sql时无需考虑分页问题，PageHelper帮你搞定。项目托管在github上https://github.com/pagehelper/Mybatis-PageHelper。 在项目中引入PageHelperPageHelper是一个通用的MyBatis分页插件,在使用的时候除了要导入MyBatis和数据库驱动的jar包外，还要导入PageHelper的jar包。 123456789101112&lt;!--MyBatis通用分页插件pageHelper--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页插件依赖的包--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.5&lt;/version&gt;&lt;/dependency&gt; 分页插件的配置配置PageHepler拦截器插件对方法有很多种，可以在mybatis-config.xml全局配置文件来配置。也可以在Spring配置文件中配置，配置都很简单，具体如下： 在 MyBatis 配置 xml 中配置拦截器插件123456789101112&lt;!--配置拦截器插件--&gt;&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="dialect" value="com.github.pagehelper.PageHelper"/&gt; &lt;property name="offsetAsPageNum" value="false"/&gt; &lt;property name="rowBoundsWithCount" value="false"/&gt; &lt;property name="pageSizeZero" value="false"/&gt; &lt;property name="reasonable" value="false"/&gt; &lt;property name="supportMethodsArguments" value="false"/&gt; &lt;property name="returnPageInfo" value="none"/&gt; &lt;/plugin&gt;&lt;/pligins&gt; 在 Spring 配置文件中配置拦截器插件1234567891011121314151617&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptior"&gt; &lt;property name="properties"&gt; &lt;value&gt; &lt;!--一行一个参数，可以写多个--&gt; pageSizeZero=false helperDialect=mysql reasonable=true &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--其他配置--&gt;&lt;/bean&gt; 分页插件参数介绍&nbsp;&nbsp;&nbsp;&nbsp;dialect：默认情况下会使用PageHelper类进行分页，如果想要实现自己的分页逻辑，可以实现Dialect接口,然后配置这个属性未实现类的全限定名。下面的参数都是在默认dialect情况下的参数。使用自定义dialect实现时下面的参数没有任何作用。&nbsp;helpDialect：配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby。一般情况下，分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。&nbsp;offsetAspageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。&nbsp;rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。&nbsp;pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果&nbsp;reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。&nbsp;params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。&nbsp;supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页&nbsp;autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页&nbsp;closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭 在代码中使用PageHelper完成上面的操作后对分页插件的配置就完成了，使用方法也很简单：使用PageHelper.statPage静态方法来分页，使用PageInfo来获取分页信息 123456789101112131415161718@RequestMapping("/showAll") public String showAllBook(@RequestParam(value = "pageNo",defaultValue = "1") Integer pageNo,Model model) &#123; //官方推荐的两种使用方式 //1.使用PageHelper.startPage(pageNo,10)进行分页，第一个参数是页码，第二个参数是每页的大小,startPage有几个重载的方法，具体下面有说道 PageHelper.startPage(pageNo,20); List&lt;Book&gt; lists = bookService.getAll(); /**2.使用PageHelper.offsetPage(pageNo,20) *PageHelper.offsetPage(pageNo,20); *List&lt;Book&gt; lists = bookService.getAll(); */ //可以有两个参数，第一个参数是查询到的结果、第二个参数是连续显示的页码数 PageInfo&lt;Book&gt; info=new PageInfo&lt;Book&gt;(lists,10); model.addAttribute("info", info); return "bookInfo"; &#125; 使用的时应注意：&nbsp;&nbsp;&nbsp;&nbsp;1.只有紧跟在PageHelper.startPage方法后的第一个Mybatis的查询（Select）方法会被分页。&nbsp;&nbsp;&nbsp;&nbsp;2.请不要在系统中配置多个分页插件(使用Spring时,mybatis-config.xml和Spring配置方式，请选择其中一种，不要同时配置多个分页插件)！&nbsp;&nbsp;&nbsp;&nbsp;3.对于带有for update的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。&nbsp;&nbsp;&nbsp;&nbsp;4.由于分页插件是通过拦截器，在原有SQL上进行追加约束条件，所以使用分页插件时，应保证原有SQL不会 受后面追加的条件的影响。给出一个反例:原有SQL中使用变量计算排名时,如果在后面追加了LIMIT的话，那么排名就会受到影响，因为SELECT的优先级在LIMIT之后。&nbsp;&nbsp;&nbsp;&nbsp;5.PageInfo是比Page信息更丰富的一个类;我们可以直接返回Page,也可以使用PageInfo包装一下返回PageInfo，甚至也可以自定义一个类来存放结果信息(只需将返回的Page中的信息取出来,再setter放入我们自己的类即可)。 PageHelper常用的APIPageMethod的APIPageHelper类继承了PageMethod抽象类，而使用PageHelper类进行分页操作的方法实际用的是PageMethod中的方法，具体如下： 1234567891011121314151617/**startPage方法都有下面几个内存pageNum int类型，当前页码pageSize int类型，每页的大小count boolean类型，是否在分页的时候统计记录数 reasonable boolean类型， isReasonable分页合理化,null时用默认配置pageSizeZero boolean类型，isPageSizeZero是否支持PageSize为0，true且pageSize=0时返回全部结果，false时分页,null时用默认配置*/public static &lt;E&gt; Page&lt;E&gt; startPage(Object params)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, String orderBy)public static &lt;E&gt; Page&lt;E&gt; startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero)//offsetPage方法和startPage一样都是用来分页的，参数中offset相当于pageNum,limit相当于PageSizepublic static &lt;E&gt; Page&lt;E&gt; offsetPage(int offset, int limit)public static &lt;E&gt; Page&lt;E&gt; offsetPage(int offset, int limit, boolean count)//设置排序规则public static void orderBy(String orderBy) PageInfo类中的成员变量每一个成员变量都有对应的get和set方法，使用这些方法可以获得分页的任何信息，这个类十分强大 1234567891011121314151617181920212223242526272829303132333435//两个重要的构造方法，list是查询到的结果，navigatePages是下方显示的导航页码个数public PageInfo(List&lt;T&gt; list)public PageInfo(List&lt;T&gt; list, int navigatePages)//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//第一页private int firstPage;//前一页private int prePage;//是否为第一页private boolean isFirstPage;//是否为最后一页private boolean isLastPage;//是否有前一页private boolean hasPreviousPage;//是否有下一页private boolean hasNextPage;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums;]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis集成EhCache缓存]]></title>
    <url>%2F2019%2F07%2F29%2FMyBatis%E9%9B%86%E6%88%90EhCache%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;Encache是一个纯粹的Java进程内的缓存框架，具有快速、精干等特点。具体来说，Encache主要特点如下。 快速 简单 多种缓存策略 缓存数据有内存和磁盘两级，无需担心容量问题 缓存数据会在虚拟机重启的过程写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存接口的侦听接口 &nbsp;因为以上诸多优点，MyBatis项目开发者最早提供了EnCache的MyBatis二级缓存实现，该项目名encache-cache，EhCache官方网址是http://www.mybatis.org/ehcache-cache/。下面，按照如下步骤集成EhCache框架。 添加项目依赖除了基本的MyBatis依赖、数据库驱动以外还需要在pom.xml中添加如下依赖： 123456789101112&lt;!--EnCache缓存核心包--&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-core&lt;/artifactId&gt; &lt;version&gt;2.6.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--mybatis-ehcache整合包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt;&lt;/dependency&gt; 配置encache.xml和MyBatis一样，EnCache也需要外部的配置文件，而且要求这个文件的名字必须是encache.xml，并且必须放在类路径的根目录下，即src/main/resources目录下 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path="E:\ehcache"/&gt; &lt;defaultCache maxElementsInMemory="1" maxElementsOnDisk="10000000" eternal="false" overflowToDisk="true" copyOnRead="true" copyOnWrite="true" timeToIdleSeconds="120" timeToLiveSeconds="120" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt; 如果想增加一个针对某个Mapper映射文件的缓存配置，可以在ehcache.xml文件中添加一个和映射文件命名空间一致的缓存配置，例如针对UserMapper,可以进行如下配置： 12345678910&lt;cache name="com.xust.iot.mapper.UserMapper" maxElementsInMemory="3000" maxElementsOnDisk="1000000" eternal="false" overflowToDisk="true" copyOnWrite="true" copyOnRead="true" timeToIdleSeconds="3600" timeToLiveSeconds="3600" diskPersistent="true"/&gt; EhCache的配置信息 nameCache的名称，必须是唯一的(ehcache会把这个cache放到HashMap里)。 maxElementsInMemory在内存中缓存的element的最大数目 maxElementsOnDisk在磁盘上缓存的element的最大数目，默认值为0，表示不限制。 eternal设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断。 overflowToDisk 如果内存中数据超过内存限制，是否要缓存到磁盘上。 copyOnRead判断从缓存中读取数据是否是返回对象的引用还是赋值一个对象返回。默认是false，即返回数据的引用，这种情况和MyBatis默认的缓存中只读对象是相同的。如果为true，那就是可读写缓存，每次读取缓存是都赋值一个新的实例。 copyOnWrite判断写入缓存时直接缓存对象的引用还是赋值一个对象后缓存，默认值也是false。如果想使用可读写缓存，就需要将这两个属性配置为true，如果使用只读缓存，可以不配置这两个属性。 timeToIdleSeconds 对象空闲时间，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问。 timeToLiveSeconds 对象存活时间，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问。 diskPersistent 是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false。 diskExpiryThreadIntervalSeconds 对象检测线程运行时间间隔。标识对象状态的线程多长时间运行一次。 diskSpoolBufferSizeMB DiskStore使用的磁盘大小，默认值30MB。每个cache使用各自的DiskStore。 memoryStoreEvictionPolicy 如果内存中数据超过内存限制，向磁盘缓存时的策略。默认值LRU，可选FIFO、LFU。 缓存清空策略 : １、FIFO ，first in first out (先进先出). ２、LFU ， Less Frequently Used (最少使用).意思是一直以来最少被使用的。缓存的元素有一个hit 属性，hit 值最小的将会被清出缓存。 ３、LRU ，Least Recently Used(最近最少使用). (ehcache 默认值).缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 修改Mapper映射文件chcache-cache提供了如下两个可选的缓存实现： org.mybatis.caches.ehcache.EhcacheCache org.mybatis.caches.ehcache.LoggingEhcache 这两个缓存中，第二个是带日志的缓存，由于MyBatis初始化时，如果Cache不是继承自LoggingEhcache，MyBatis便会使用LoggingEhcache装饰代理缓存，所以上面两个缓存使用时并没有区别，都会输出命中率的日志。修改后的UserMapper.xml配置如下： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xust.iot.mapper.UserMapper"&gt; &lt;!--在UserMapper中开启二级缓存,MyBatis支持集成第三方缓存,方法是使用type属性指定--&gt; &lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt; &lt;select id="getUserByName" parameterType="string" resultType="user"&gt; select * from user &lt;where&gt; name=#&#123;username&#125; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 在src/main/test目录下新建测试类AppTest.java测试是否用上了EhCache： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.UserMapper;import net.sf.ehcache.CacheEntry;import net.sf.ehcache.Element;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import org.mybatis.caches.ehcache.EhcacheCache;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123; private static SqlSessionFactory sqlSessionFactory; private static Logger log = Logger.getLogger(AppTest.class); @Before public void init() &#123; String resource = "mybatis-config.xml"; try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test02() &#123; //第一个会话 SqlSession session = sqlSessionFactory.openSession(true); UserMapper sm = session.getMapper(UserMapper.class); List&lt;User&gt; user1 = sm.getUserByName("小明"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; session.close(); //第二个会话 System.out.println("开启新的会话......"); SqlSession session2 = sqlSessionFactory.openSession(true); UserMapper sm2 = session2.getMapper(UserMapper.class); List&lt;User&gt; user2 = sm2.getUserByName("小明"); if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125; &#125; session2.close(); &#125;&#125; 测试结果： 在配置的磁盘路径下确实有缓存文件：]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解MyBatis高级结果映射]]></title>
    <url>%2F2019%2F07%2F28%2F%E6%B7%B1%E7%90%86%E8%A7%A3MyBatis%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[搭建实验环境 1).新建数据库mybatis6 2). 新建表：sys_user、sys_role、sys_user_role,sys_privilege、sys_role_privilege sql脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657create table sys_user( id bigint not null primary key auto_increment, user_name varchar(255) , user_password varchar(255), user_email varchar(255), user_info text comment '用户简介', head_img blob comment '头像', create_time datetime);create table sys_role( id bigint not null primary key auto_increment, role_name varchar(255) , enable int comment '有效标志', create_by bigint comment '创建人', create_time datetime);create table sys_privilege( id bigint not null primary key auto_increment, privilege_name varchar(50) comment '权限名称', privilege_url varchar(255));create table sys_user_role( user_id bigint , role_id bigint);create table sys_role_privilege( role_id bigint, privilege bigint);insert into sys_user values('1','admin','123456','adimin@mybatis.tk','管理员',null,'2019-7-30 10:05:56');insert into sys_user values('1002','testuser','123456','test@mybatis.tk','测试用户',null,'2019-7-30 10:05:56');insert into sys_role values('1','管理员','1','1','2019-7-30 10:05:56');insert into sys_role values('2','普通用户','1','1','2019-7-30 10:05:56');insert into sys_user_role values ('1','1');insert into sys_user_role values ('1','2');insert into sys_user_role values ('1001','2');insert into sys_privilege values('1','用户管理','/user');insert into sys_privilege values('2','角色管理','/roles');insert into sys_privilege values('3','系统管理','/system');insert into sys_privilege values('4','系统维护','/system-a');insert into sys_privilege values('5','单位管理','/company');insert into sys_role_privilege values('1','1');insert into sys_role_privilege values('1','2');insert into sys_role_privilege values('1','3');insert into sys_role_privilege values('2','4');insert into sys_role_privilege values('2','5'); 3).新建每个 表对应的实体JavaBean SysUser.java 1234567891011121314151617package com.orecal.bean;import java.util.Date;import java.util.List;public class SysUser &#123; private Long id; private String userName; private String userPassword; private String userEmail; private String userInfo; private String headImg; private Date createTime; private SysRole role; //用户的角色 private List&lt;SysRole&gt; roleList; //用户角色结合和 //省略getter、setter.... SysRole.java 1234567891011121314package com.orecal.bean;import java.util.Date;import java.util.List;public class SysRole &#123; private Long id; private String roleName; private int enable; private int createBy; private Date createTime; private List&lt;SysPrivilege&gt; privilegeList; //省略getter、setter.... SysUserRole.java 12345678package com.orecal.bean;public class SysUserRole &#123; private Long userId; private Long roleId; //省略getter、setter.... SysPrivilege.java 123456789package com.orecal.bean;public class SysPrivilege &#123; private Long id; private String privilegeName; private String privilegeUrl; //省略getter、setter.... SysRolePrivilege.java 12345678package com.orecal.bean;public class SysRolePrivilege &#123; private Long roleId; private Long privilegeId; //省略getter、setter.... 4).新建SysUserMapper接口 5). 新建mybaits配置文件 一对一映射Mybatis中的映射方式有两种，一种是通过resultType自动映射，另一种是通过resultMap自己设置映射规则。resultMap又有两种映射方式：嵌套结果映射和嵌套查询映射。 嵌套结果映射:给数据库发一条复杂的sql语句把查询到的结果根据映射规则映射到不同的对象中 嵌套查询映射：会发多条sql简单的语句，Mybatis会把多条sql语句的查询据结果封装到一个对象中。如果在mybatis全局配置中设置了延迟加载：` ` 那么还可以按需给数据库发sql语句，即当没有用到这个表中的数据的时候，Mybatis压根就不会给数据库法sql语句，即使已在xml文件中已经配置了sql语句，这是MyBatis中非常强大的一个功能。 配置xml文件：通过resultMap一对一映射，在SysUser实体类中新增一个属性private SysRole role 标识用户的角色，然后在SysUserMapper.xml中写如下映射userRoleMap： 123456789101112131415161718192021222324252627SysUserMapper.xml&lt;resultMap type="com.orecla.bean.SysUser" id="userRoleMap"&gt; &lt;!--sys_user表中原有的属性--&gt; &lt;!-- id:id元素是一个很特殊的元素，如果设置了它，MyBayis会比较每次返回来的数据的id,如果id相同，MyBatis就会认为这是同一条数据，然后就会把这两条数据合并；如果没有设置id,MyBatis会比较resultMap下所有的字段属性，只要有一个不同就不会合并。 --&gt; &lt;id property="id" column="id"/&gt; &lt;result property="userName" column="user_name"/&gt; &lt;result property="userPassword" column="user_password"/&gt; &lt;result property="userEmail" column="user_email"/&gt; &lt;result property="userInfo" column="user_info"/&gt; &lt;result property="headImg" column="head_img"/&gt; &lt;result property="createTime" column="create_time"/&gt; &lt;!--role字段在sys_user表中没有，而且role他是一个复杂的类型，没法直接映射，最简单的可以通过如下这种方式来映射--&gt; &lt;result property="role.roleName" column="role_name"/&gt; &lt;result property="role.enable" column="enable"/&gt; &lt;result property="role.createTime" column="create_time"/&gt; &lt;result property="role.createBy" column="create_by"/&gt; &lt;/resultMap&gt; &lt;select id="selectUserAndRoleById" resultMap="userRoleMap"&gt; select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=#&#123;id&#125; and sys_role.role_name=sys_user.user_info&lt;/select&gt; 在SysUserMapper接口中增加方法：public SysUser selectUserAndRoleById(Long id);测试方法： 1234567891011121314@Test public void test1() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); SysUser user = sum.selectUserAndRoleById(1002L); System.out.println(user); //log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 这是日志的打印结果： 123456 2019-07-31 10:16:52 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] ==&gt; Preparing: select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=? and sys_role.role_name=sys_user.user_info 2019-07-31 10:16:52 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] ==&gt; Parameters: 1002(Long) 2019-07-31 10:16:53 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=null, roleName=&apos;普通用户&apos;, enable=0, createBy=0, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 10:16:53 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 10:16:53 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. &nbsp;&nbsp;&nbsp;&nbsp;改进上面的映射方法：上面的映射方法虽然可以使用，但是耦合性太高，而且最大的问题是配置文件不能复用，啥意思?就是说，如果我现在需要一个单独查用户的方法，那我还得专门为查用户写一个sql配置，这样做非常的糟糕，当项目非常大的时候，配置文件的重复配置代码将会非常的多，那么如何解决这个问题呢?我们接着往下看:在SysUserMapper.xml中增加一个专门为查用户的映射userMap： 12345678910111213SysUserMapper.xml&lt;resultMap type="com.orecal.bean.SysUser" id="userMap"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="userName" column="user_name"/&gt; &lt;result property="userPassword" column="user_password"/&gt; &lt;result property="userEmail" column="user_email"/&gt; &lt;result property="userInfo" column="user_info"/&gt; &lt;result property="headImg" column="head_img"/&gt; &lt;result property="createTime" column="create_time"/&gt; &lt;/resultMap&gt; &lt;select id="selectUser" resultMap="userMap"&gt; select * from sys_user where id=#&#123;id&#125;; &lt;/select&gt; 然后刚才的上面的userRoleMap就可以修改成下面的样子： 123456789101112131415161718192021SysUserMapper.xml &lt;!-- 使用resultMap可以自定义结果集的映射关系 type:这个样映射到那个pojo id：给这个映射关系起的一个唯一的标识 extends:resultMap可以继承别的map已经定义好的关系，比如下面的userMap在上门已经定义了，在下面可以继承后直接使用 --&gt; &lt;resultMap type="com.orecal.bean.SysUser" id="userRoleMap" extends="userMap"&gt; &lt;result property="role.roleName" column="role_name"/&gt; &lt;result property="role.enable" column="enable"/&gt; &lt;result property="role.createTime" column="create_time"/&gt; &lt;result property="role.createBy" column="create_by"/&gt; &lt;/resultMap&gt; &lt;select id="selectUserAndRoleById" resultMap="userRoleMap"&gt; select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=#&#123;id&#125; and sys_role.role_name=sys_user.user_info &lt;/select&gt; 使用association元素替代上面的role.XXX: 1234567891011121314151617SysUserMapper.xml &lt;!--使用association和一个复杂的类型进行关联 property:pojo中对应的属性名，必填 javaType:这个属性对应的pojo类型 resultMap:可以使用这个属性配置已有的map， 如果要引用当前mapper中的resultMap，直接引用 如果引用别的mapper中的resultMap，要指定namespace以及引用的那个map的id --&gt;&lt;resultMap id="userRoleMap2" type="com.orecal.bean.SysUser" extends="userMap"&gt; &lt;association property="role" javaType="com.orecal.bean.SysRole"&gt; &lt;result property="id" column="id"/&gt; &lt;result property="roleName" column="role_name"/&gt; &lt;result property="enable" column="enable"/&gt; &lt;result property="createTime" column="create_time"/&gt; &lt;result property="createBy" column="create_by"/&gt; &lt;/association&gt;&lt;/resultMap&gt; 可是这样还是不行，实际的开发中，肯定会有关于单独查询sys_role的需求，而且人家sys_role肯定也会有单独的mapper,这样就又会存在重复配置的问题，解决这个问题需要用到association元素的另一个功能,具体看代码：新建SysRoleMapper.xml,并配置roleMap如下： 123456789101112SysRoleMapper.xml&lt;!--根据id查询角色--&gt;&lt;resultMap type="com.orecal.bean.SysRole" id="roleMap"&gt; &lt;result property="id" column="id"/&gt; &lt;result property="roleName" column="role_name"/&gt; &lt;result property="enable" column="enable"/&gt; &lt;result property="createTime" column="create_time"/&gt; &lt;result property="createBy" column="create_by"/&gt;&lt;/resultMap&gt;&lt;select id="selectRoleById" resultMap="roleMap"&gt; select * from sys_role where id=#&#123;id&#125;;&lt;/select&gt; 这样我们在SysUserMapper.xml就可以把刚才的配置彻底抽取了出来： 1234567SysUserMapper.xml&lt;resultMap id="userRoleMap" type="com.orecal.bean.SysUser" extends="userMap"&gt; &lt;!--在association中使用resultMap属性指定要关联的Map resultMap=目标map的namespace.目标map的id 在同一个mapper中也可以这么使用，但是只用指定id就够了 --&gt; &lt;association property="role" resultMap="com.orecal.mapper.SysRoleMapper.roleMap"/&gt;&lt;/resultMap&gt; 这样就彻底把模块与模块分开了,当然我们也可以顺便实现以下selectRoleById,下面是配置后的运行时打印的日志的部分： 12345678 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] ==&gt; Preparing: select sys_user.*,sys_role.role_name from sys_user,sys_role where sys_user.id=? and sys_role.role_name=sys_user.user_info 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] ==&gt; Parameters: 1002(Long) 2019-07-31 10:57:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById2] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=1002, roleName=&apos;普通用户&apos;, enable=0, createBy=0, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 10:57:08 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 10:57:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，日志的打印结果相同，但是修改后的方式肯定比一开始的方法要好，因为这样就把各个查询模块化了，就像搭积木，一个个简单的“积木块”最后通过合理的组织，就可以实现不同的复杂查询。一对一的嵌套查询映射上面这种方法是嵌套结果映射，就是直接给数据库发一条sql语句，数据库返回数据后Mybatis根据映射规则，把数据映射到不同的对象中。而嵌套查询映射则是多次给数据库发简单的sql语句，然后把不同的数据映射到一个对象中。 1.association元素的嵌套查询： &nbsp; &nbsp; select :另一个映射查询map的id &nbsp; &nbsp; column：将主查询的那个列的结果作为嵌套查询的参数传给嵌套查询方法 &nbsp; &nbsp; fetchType:数据加载的方式[lazy或eager],即延迟加载或积极加载, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 配置这个属性会覆盖全局配置中飞lazyLoadingEnabled 2.MyBatis的嵌套查询可以实现懒加载，简单点的说就是不用的时候就不给你加载，等用的时候才去给你加载,这样做的好处是可以降低数据库的压力，做到按需响应。那么要用懒加载必须在全局配置文件中设置如下：&lt;settings&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;!--vallue=false时按需加载-，否者全部加载-&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!--是否开启懒加载，true表示开启--&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt; &lt;!--懒加载模式下如果调用value后的方法将全部加载--&gt; &lt;/settings&gt; 在SysUserMapper.xml中写一个id为userRoleMapSelecct的新的映射关系，并写SQL查询语句如下： 123456789101112131415161718192021222324252627SysUserMapper.xml&lt;resultMap id="userRoleMapSelect" extends="userMap" type="com.orecal.bean.SysUser"&gt; &lt;!-- association的select元素中指定另一个嵌套的子查询 select=子查询Mapper接口中对应方法的全类名 --&gt; &lt;association property="role" select="com.orecal.mapper.SysRoleMapper.selectRoleById" column="&#123;id=role_id&#125;"/&gt;&lt;/resultMap&gt;&lt;select id="selectUserAndRoleById3" resultMap="userRoleMapSelect"&gt;SELECT sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id FROM sys_user, sys_user_role WHERE sys_user.id = sys_user_role.user_id AND sys_user.id = #&#123;id&#125;&lt;/select&gt; 配置好后我们在SysUserMapper接口中增加selectUserAndRoleById3方法,然后写测试： 1234567891011121314151617 @Testpublic void test4() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectUserAndRoleById3(1002L); for (SysUser u : user) &#123; System.out.println(u); //System.out.println(u.getUserName() + "," + u.getUserEmail() + "," + u.getCreateTime()); &#125; log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125;&#125; 日志的打印结果： 123456789101112131415 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Opening JDBC Connection 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 785447854. 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Preparing: select sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id from sys_user,sys_user_role where sys_user.id=sys_user_role.user_id and sys_user.id=? 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Parameters: 1002(Long) 2019-07-31 11:29:54 [WARN]-[org.apache.ibatis.session.AutoMappingUnknownColumnBehavior] Unknown column is detected on &apos;com.orecal.mapper.SysUserMapper.selectUserAndRoleById3&apos; auto-mapping. Mapping parameters are [columnName=role_id,propertyName=role_id,propertyType=null] 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] &lt;== Total: 1 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] ==&gt; Preparing: select * from sys_role where id=?; 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] ==&gt; Parameters: 2(Long) 2019-07-31 11:29:54 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleById] &lt;== Total: 1 SysUser&#123;id=1002, userName=&apos;testuser&apos;, userPassword=&apos;123456&apos;, userEmail=&apos;test@mybatis.tk&apos;, userInfo=&apos;普通用户&apos;, headImg=&apos;null&apos;, createTime=Tue Jul 30 10:05:56 CST 2019, role=SysRole&#123;id=2, roleName=&apos;普通用户&apos;, enable=1, createBy=1, createTime=Tue Jul 30 10:05:56 CST 2019, privilegeList=null&#125;, roleList=null&#125;2019-07-31 11:29:54 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@6580cfdd 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 11:29:54 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，MyBatis分别给数据库发了两条sql语句，这是因为直接打印，在配置文件的setting中有一个元素lazyLoadTriggerMethods 默认值value=&quot;equals,clone,hashCode,toString&quot;，当程序中调用这些方法的时就会全部加载。但是如果我们在程序中只是用到User的一些属性，那么Mybatis就只发查user的sql语句,把测试代码中的System.out.println(u);改成System.out.println(u.getUserName() + &quot;,&quot; + u.getUserEmail() + &quot;,&quot; + u.getCreateTime()); 再次运行打印的日志部分如下： 12345678910 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Preparing: select sys_user.id, sys_user.user_name, sys_user.user_password, sys_user.user_email, sys_user.user_info, sys_user.head_img, sys_user.create_time, sys_user_role.role_id from sys_user,sys_user_role where sys_user.id=sys_user_role.user_id and sys_user.id=? 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] ==&gt; Parameters: 1002(Long) 2019-07-31 11:27:13 [WARN]-[org.apache.ibatis.session.AutoMappingUnknownColumnBehavior] Unknown column is detected on &apos;com.orecal.mapper.SysUserMapper.selectUserAndRoleById3&apos; auto-mapping. Mapping parameters are [columnName=role_id,propertyName=role_id,propertyType=null] 2019-07-31 11:27:13 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectUserAndRoleById3] &lt;== Total: 1 testuser,test@mybatis.tk,Tue Jul 30 10:05:56 CST 20192019-07-31 11:27:13 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@6a400542 2019-07-31 11:27:13 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 11:27:13 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，只发了一条sql语句。这就是MyBatis的延迟加载（懒加载），也就是说，当你没用到的时候，MyBatis压根不会帮你去查这个数据。这样一来的好处是会减轻数据库的压力。 一对多映射使用collection实现一对多映射,collection的属性和用法与association基本是一样的，只是collection是专门用来映射数据库中一对多的多方元素的一个集合。比如现在有这样的需求：查询所有用户以及每个用户在本系统中所拥有的角色。这是一个很典型的一对多的例子，一个用户在系统中有多个角色。举个栗子：在SysUser.java中增加属性List&lt;SysRole&gt; roleList 12345678910//其他的属性不变private List&lt;SysRole&gt; roleList; //用户角色结合public List&lt;SysRole&gt; getRoleList() &#123; return roleList;&#125;public void setRoleList(List&lt;SysRole&gt; roleList) &#123; this.roleList = roleList;&#125; 在SysUserMapper.xml中增加reultMapuserRoleListMap,由于roleMap在前面已经定义过了，这里就可以直接使用 12345678910111213141516SysUserMapper.xml&lt;resultMap id="userRoleListMap" extends="userMap" type="com.orecal.bean.SysUser"&gt; &lt;collection property="roleList" resultMap="com.orecal.mapper.SysRoleMapper.roleMap"/&gt;&lt;/resultMap&gt;&lt;select id="selectAllUserAndRole" resultMap="userRoleListMap"&gt;SELECT sys_user.*, sys_role.* FROM sys_user, sys_role, sys_user_role WHERE sys_user_role.user_id = sys_user.id AND sys_user_role.role_id = sys_role.id;&lt;/select&gt; 测试代码： 1234567891011121314151617181920@Testpublic void test5() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectAllUserAndRole(); System.out.println("用户数：" + user.size()); for (SysUser u : user) &#123; System.out.println("用户名：" + u.getUserName()); for (SysRole role : u.getRoleList()) &#123; System.out.println("角色名：" + role.getRoleName()); &#125; &#125; log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125;&#125; 程序运行打印的日志： 12345678910111213141516 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Opening JDBC Connection 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 741669172. 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Preparing: select sys_user.*,sys_role.*,sys_privilege.* from sys_user, sys_role,sys_user_role,sys_privilege,sys_role_privilege where sys_user_role.user_id=sys_user.id and sys_user_role.role_id=sys_role.id and sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Parameters: 2019-07-31 14:47:06 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] &lt;== Total: 7 用户数：2用户名：admin角色名：管理员角色名：普通用户用户名：testuser角色名：普通用户2019-07-31 14:47:06 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@38c5cc4c 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2c34f934] 2019-07-31 14:47:06 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 741669172 to pool. Process finished with exit code 0 前面这个实现了一层嵌套，就是一个主查询下面只有一个层子查询然后就结束了，下面我们尝试来实现一个两层嵌套：比如现在有这样的需求：查询所有的用户的角色，以及每个角色拥有的权限。很好想，就是一个用户可以有多个角色，每个角色又有不同的权限。 实现： 首先在SysRole中增加一个属性private List&lt;SysPrivilege&gt; privilegeList 12345678910//其他的属性不变private List&lt;SysPrivilege&gt; privilegeList;public List&lt;SysPrivilege&gt; getPrivilegeList() &#123; return privilegeList;&#125;public void setPrivilegeList(List&lt;SysPrivilege&gt; privilegeList) &#123; this.privilegeList = privilegeList;&#125; 新建SysPrivilegeMapper.xml文件，增加一个resultMapprivilegeMap 12345678910111213 &lt;resultMap type="com.orecal.bean.SysPrivilege" id="privilegeMap"&gt; &lt;result property="privilegeName" column="privilege_name"/&gt; &lt;result property="privilegeUrl" column="privilege_url"/&gt; &lt;/resultMap&gt; SELECT sys_privilege.* FROM sys_privilege, sys_role_privilege WHERE sys_role_privilege.privilege_id = sys_privilege.id AND sys_role_privilege.role_id = #&#123;roleId&#125; &lt;/select&gt; 在SysRoleMapper.xml中增加一个resultMaprolePrivilegeListMap，由于roleMap在上面已经定义过了，，用extends继承他就可以直接使用了。 123456789101112131415SysRoleMapper.xml&lt;resultMap id="rolePrivilegeListMap" extends="roleMap" type="com.orecal.bean.SysRole"&gt; &lt;collection property="privilegeList" resultMap="com.orecal.mapper.SysPrivilegeMapper.privilegeMap"/&gt;&lt;/resultMap&gt;&lt;select id="selectAllRoleAndPrivilege" resultMap="rolePrivilegeListMap"&gt; select sys_role.*, sys_privilege.* from sys_role, sys_privilege, sys_role_privilege where sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; &lt;/select&gt; 在SysUserMapper.xml中增加reusltMap:userRoleListMapSelect 12345678910111213141516171819202122SysUserMapper.xml&lt;resultMap id="userRoleListMapSelect" extends="userMap" type="com.orecal.bean.SysUser"&gt; &lt;collection property="roleList" resultMap="com.orecal.mapper.SysRoleMapper.rolePrivilegeListMap"/&gt; &lt;/resultMap&gt; &lt;select id="selectAllUserAndRole2" resultMap="userRoleListMap"&gt; SELECT sys_user.*, sys_role.*, sys_privilege.* FROM sys_user, sys_role, sys_user_role, sys_privilege, sys_role_privilege WHERE sys_user_role.user_id = sys_user.id AND sys_user_role.role_id = sys_role.id AND sys_role_privilege.role_id = sys_role.id AND sys_privilege.id = sys_role_privilege.privilege_id; &lt;/select&gt; 在SysUserMapper接口中增加方法selectAllUserAndRole2，并且编写测试代码： 1234567891011121314151617181920212223@Test public void test6() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); List&lt;SysUser&gt; user = sum.selectAllUserAndRole(); System.out.println("用户数：" + user.size()); for (SysUser u : user) &#123; System.out.println("用户名：" + u.getUserName()); for (SysRole role : u.getRoleList()) &#123; System.out.println("角色名：" + role.getRoleName()); for (SysPrivilege privilege : role.getPrivilegeList()) &#123; System.out.println("权限：" + privilege.getPrivilegeName()); &#125; &#125; System.out.println("--------------------------------------------------------"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 程寻运行打印的日志的一部分： 1234567891011121314151617181920212223242019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 741669172. 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Preparing: select sys_user.*,sys_role.*,sys_privilege.* from sys_user, sys_role,sys_user_role,sys_privilege,sys_role_privilege where sys_user_role.user_id=sys_user.id and sys_user_role.role_id=sys_role.id and sys_role_privilege.role_id=sys_role.id and sys_privilege.id=sys_role_privilege.privilege_id; 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] ==&gt; Parameters: 2019-07-31 15:11:27 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole] &lt;== Total: 7 用户数：2用户名：admin角色名：管理员权限：用户管理权限：角色管理权限：系统管理角色名：普通用户权限：系统维护权限：单位管理--------------------------------------------------------用户名：testuser角色名：普通用户权限：系统维护权限：单位管理--------------------------------------------------------2019-07-31 15:11:27 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@38c5cc4c 2019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2c34f934] 2019-07-31 15:11:27 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 741669172 to pool. Process finished with exit code 0 这样，我们就算是实现了一对多的两层嵌套结果映射的一个查询，这种方式在日常非常常见，也是MyBatis中非常强大的地方。最后我们看一下一对多的嵌套查询映射，和一对一的实现方法是类似的：前面我们写过一个resultMaprolePrivilegeListMap，但是还没有为他写接口方法，这里我们首先来实现这个： 123456789public interface SysPrivilegeMapper &#123; /** * 通过角色ID获得它的权限 * @return */ public List&lt;SysPrivilege&gt; selectPrivilegeByRoleId(Long id);&#125; 在SysRoleMapper.xml增加一个resultMap:rolePrivilegeListMap2 123456789101112131415&lt;resultMap id="rolePrivilegeListMap2" extends="roleMap" type="com.orecal.bean.SysRole"&gt; &lt;collection property="privilegeList" select="com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId" column="&#123;roleId=id&#125;"&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="selectRoleByUserId" resultMap="rolePrivilegeListMap2"&gt; SELECT sys_role.* FROM sys_role, sys_user_role WHERE sys_user_role.user_id = sys_role.id AND sys_user_role.user_id = 1; &lt;/select&gt; 在SysRoleMapper接口中增加一个方法selectRoleByUserId 123456/** * 根据用户id查他的权限 * @param userId * @return */public List&lt;SysRole&gt; selectRoleByUserId(Long userId); 最后在SysUserMapper.xml中增加一个resultMap:userRoleListMap2 12345678 &lt;resultMap id="userRoleListMap2" extends="userMap" type="com.orecal.bean.SysUser"&gt; &lt;collection property="roleList" select="com.orecal.mapper.SysRoleMapper.selectRoleByUserId" column="&#123;userId=id&#125;"/&gt;&lt;/resultMap&gt;&lt;select id="selectAllUserAndRole2" resultMap="userRoleListMap2"&gt; select sys_user.* from sys_user where sys_user.id=#&#123;id&#125;&lt;/select&gt; 在SysUserMapper接口中增加一个方法selectAllUserAndRole2: 1234567 /** * 根据用户的Id查询他拥有的角色和对应的权限 * @param id * @return */public SysUser selectAllUserAndRole2(Long id); 测试代码： 1234567891011121314151617181920212223@Test public void test10() &#123; SqlSession session = sqlSessionFactory.openSession(true); try &#123; SysUserMapper sum = session.getMapper(SysUserMapper.class); SysUser user = sum.selectAllUserAndRole2(1002L); System.out.println("-------------------------------------------"); System.out.println("用户名：" + user.getUserName()); for (SysRole role : user.getRoleList()) &#123; System.out.println("角色名：" + role.getRoleName()); for (SysPrivilege privilege : role.getPrivilegeList()) &#123; System.out.println("权限：" + privilege.getPrivilegeName()); &#125; System.out.println("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"); &#125; System.out.println("-------------------------------------------"); log.info(sum); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; 程寻运行打印的日志: 123456789101112131415161718192021222324252627282019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Created connection 785447854. 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] ==&gt; Preparing: select sys_user.* from sys_user where sys_user.id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysUserMapper.selectAllUserAndRole2] &lt;== Total: 1 -------------------------------------------用户名：admin2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] ==&gt; Preparing: select sys_role.* from sys_role,sys_user_role where sys_user_role.user_id=sys_role.id and sys_user_role.user_id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysRoleMapper.selectRoleByUserId] &lt;== Total: 2 角色名：管理员2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] ==&gt; Preparing: select sys_privilege.* from sys_privilege,sys_role_privilege where sys_role_privilege.privilege_id=sys_privilege.id and sys_role_privilege.role_id=? 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] ==&gt; Parameters: 1(Long) 2019-07-31 15:40:08 [DEBUG]-[com.orecal.mapper.SysPrivilegeMapper.selectPrivilegeByRoleId] &lt;== Total: 3 权限：用户管理权限：角色管理权限：系统管理$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$角色名：管理员权限：用户管理权限：角色管理权限：系统管理$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$-------------------------------------------2019-07-31 15:40:08 [INFO]-[com.orecal.AppTest] org.apache.ibatis.binding.MapperProxy@63355449 2019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.transaction.jdbc.JdbcTransaction] Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@2ed0fbae] 2019-07-31 15:40:08 [DEBUG]-[org.apache.ibatis.datasource.pooled.PooledDataSource] Returned connection 785447854 to pool. Process finished with exit code 0 可以看到，程寻运行时，MyBatis给数据库发了多条sql语句，最终通过预定的映射集合，把这些查出来的数据放进去，之后打包组合成一个List&lt;SysRole&gt;对象返回。]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis缓存配置]]></title>
    <url>%2F2019%2F07%2F28%2FMyBatis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;使用缓存可以是应用更快的获取数据，避免频繁的数据库交互，尤其是在查询越多、缓存命中率越高的情况下，使用缓存的作用就越明显。MyBatis作为持久层框架，提供了强大的查询缓存特性，可非常方便的配置和使用。&nbsp;&nbsp;&nbsp;&nbsp;MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存。&nbsp;&nbsp;&nbsp;&nbsp;1、默认情况下，一级缓存（SqlSession级别的缓存，也称为本地缓存）是开启的，但是不能控制。&nbsp;&nbsp;&nbsp;&nbsp;2、二级缓存需要手动开启和配置，他是和命名空间绑定的，即二级缓存需要配置在Mepper,xml文件中获配置在Mapper..java接口中&nbsp;&nbsp;&nbsp;&nbsp;3、为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存（或者使用第三方缓存） 一级缓存先通过一个简单的演示看看MyBati一级缓存是如何起作用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = "mybatis-config.xml";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;/*** 测试MyBatis一级缓存的特性*/@Testpublic void test01() &#123;SqlSession session = sqlSessionFactory.openSession(true);try &#123; StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;User&gt; user1 = sm.getUserByName("小明"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; System.out.println("第二次查询\"小明\"............"); List&lt;User&gt; user2 = sm.getUserByName("小明"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; System.out.println("user1==user?==&gt;" + (user1 == user2));&#125; catch (Exception e) &#123; log.error(e + "---" + new Date());&#125; finally &#123; session.close();&#125;&#125;&#125; 测试结果如下： &nbsp;&nbsp;&nbsp;&nbsp;可以看到，两次查询值MyBatis只给数据库发送了一次SQL语句，但是两次查询的结果都是一样的，而且再往下发现两个List&lt;User&gt;对象竟然是同一个对象，之所以这样就是MyBatis的一级缓存在起作用。&nbsp;&nbsp;&nbsp;&nbsp;在同一个SqlSession中查询是MyBatis会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入PerpetualCache 的 HashMap本地缓存对象中。如果同一个SqlSession中执行的方法和参数完全一致，闹通过算法就会生成相同的键值，当Map缓存对象中已经存在该键值时，就会返回缓存中的对象，而不会再给数据库发sql语句了。&nbsp;&nbsp;&nbsp;&nbsp;但是要注意，下面几种情况发生会使一级缓存会失效： 1. 不同的SqlSession用不同的一级缓存，他们之间的数据不能共享 2. 就算是同一个SqlSession对象，但是如果执行的方法和参数不同也不行 3. 默认情况下，在SqlSession期间执行任何一次增删改操作，一级缓存会被清空 4. 手动清空一级缓存，一级缓存也会失效 下面分别举例说明： 由于MyBatis的一级缓存存在于SqlSession生命周期中，一次不同的SqlSession当然会有不同的一级缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = "mybatis-config.xml";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;/*** MyBatis的一级缓存存在于SqlSession生命周期中，在同一个SqlSession中查询是MyBatis会把* 执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map中。*/@Testpublic void test02() &#123;//第一个会话SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName("小明");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//第二个会话System.out.println("开启新的会话......");SqlSession session2 = sqlSessionFactory.openSession(true);StudentMapper sm2 = session2.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName("小明");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();session2.close();&#125;&#125; 测试结果如下： MyBatis的&lt;insert&gt;、&lt;delete&gt;、&lt;update&gt;和&lt;select&gt;标签都中有一个属性：flushCache,在默认情况下，对于增删改操作这个标签默认值是true,也就是每次操作后要清空缓存，而对于&lt;select&gt;操作这个属性默认值是false，也即不刷新缓冲。也就是下面这段代码要说明的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = "mybatis-config.xml";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;@Testpublic void test03() &#123;SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName("小明");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//执行任意一次增删改操作，当前SqlSession的一级缓存立即被清空System.out.println("删除一个用户......");sm.deleteUserById(14);System.out.println("删除完成.......");//由于缓存被清了，因此还得给数据库发sql语句查询StudentMapper sm2 = session.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName("小明");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();&#125;&#125; 测试结果如下： 下面的这种情况就更直观了，但本质上和上面那种情况是一样的——都是一级缓存被清空了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123;private static SqlSessionFactory sqlSessionFactory;private static Logger log = Logger.getLogger(AppTest.class);@Beforepublic void init() &#123;String resource = "mybatis-config.xml";try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;@Testpublic void test03() &#123;SqlSession session = sqlSessionFactory.openSession(true);StudentMapper sm = session.getMapper(StudentMapper.class);List&lt;User&gt; user1 = sm.getUserByName("小明");if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125;&#125;//清除缓存System.out.println("手动清除缓存......");session.clearCache();StudentMapper sm2 = session.getMapper(StudentMapper.class);List&lt;User&gt; user2 = sm2.getUserByName("小明");if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125;&#125;session.close();&#125;&#125; 测试结果如下： 二级缓存 二级缓存默认也是采用 PerpetualCache，HashMap存储； 二级缓存的存储作用域为 Mapper(确切说是namespace)，即一个Mapper执行了insert、update或delete操作，不影响另外一个Mapper（不同namespace）； 二级缓存可自定义存储实现，如 Ehcache、redis； 二级缓存开启后，需要对应的java Bean实现，并且这个java Bean要实现Serializable接口进行序列化 配置二级缓存&nbsp;&nbsp;&nbsp;&nbsp;二级缓存有两种配置方法，一种是基于Mapper.xml文件来配置；另一种就是基于Mapper.java接口来配置。下面分别来看看如何配置使用MyBatis的二级缓存：&nbsp;&nbsp;&nbsp;&nbsp;首先，无论是通过Mapper.xml文件来配置，还是通过Mapper.java接口来配置，都需要在mybatis-config.xml文件中通过settings设置显式地开启二级缓存： 123456&lt;!--一些有关于mybatis运行行为的设置--&gt;&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!--其他的设置--&gt;&lt;/settings&gt; 在Mapper.xml中配置二级缓存在xml文件中配置的方法很简单，在保证二级缓存的全局配置开启的情况下，在UserMapper.xml中只需要添加&lt;cache&gt;&lt;/cache&gt;即可。 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xust.iot.mapper.StudentMapper"&gt;&lt;!--在UserMapper中开启二级缓存--&gt;&lt;cache&gt;&lt;/cache&gt;&lt;select id="getUserByName" parameterType="string" resultType="user"&gt;select * from user&lt;where&gt; name=#&#123;username&#125;&lt;/where&gt;&lt;/select&gt;&lt;delete id="deleteUserById" parameterType="integer" &gt;delete from user&lt;where&gt; id=#&#123;userId&#125;&lt;/where&gt;&lt;/delete&gt;&lt;/mapper&gt; &lt;cacha&gt;标签的属性： eviction：缓存回收策略：flushInterval：缓存多长时间清空一次，默认不清空，单位毫秒 ms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LRU——最少使用的，移除最长时间不适用的对象；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FIFO——先进先出&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WEAK——弱引用，更积极的移除基于垃圾回收器状态和弱引用规则的对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SOFT——软引用，更积极的移除基于垃圾回收器状态和弱引用规则的对象 flushInterval：缓存多久清空一次，默认不清空，时间毫秒 ms readOnly：缓存是否只读 size：缓存觉存放元素个数，默认1024 type：自定义缓存的全类名 在Mapper接口中配置二级缓存在接口中配置主要是借助@CacheNamespace这个注解，但是要注意：配置文件和接口注释是不能够配合使用的。只能通过全注解的方式或者全部通过xml配置文件的方式使用。也就是说你用了配置文件就不要用这种方式，用了接口配置的方式就别用xml配置文件的方式。如下： 1234567891011121314151617181920212223242526package com.xust.iot.mapper;import com.xust.iot.beans.User;import org.apache.ibatis.annotations.*;import java.util.List;@CacheNamespacepublic interface StudentMapper &#123; /** * 查询所有姓名为name的用户 * @param name * @return */ @Select("select * from user where name=#&#123;username&#125;") @Options(useCache = true) public List&lt;User&gt; getUserByName(@Param("username") String name); /** * 删除id=userId的用户 * @param id */ @Delete("delete from user where id=#&#123;userId&#125;") public void deleteUserById(@Param("userId") Integer id);&#125; 并在mybatis-config.xml中重新配置Mapper映射文件： 1234&lt;mappers&gt; &lt;!-- &lt;mapper resource="mapper/StudentMapper.xml"&gt;&lt;/mapper&gt;--&gt; &lt;mapper class="com.xust.iot.mapper.StudentMapper"/&gt; &lt;/mappers&gt; 使用二级缓存：&nbsp;&nbsp;&nbsp;&nbsp;配置Mybatis二级缓存的方法有两种，只要配置好,二级缓存就可以工作了。但是在使用前需要注意的是，由于MyBatis使用SerializedCache序列化缓存来实现可读写缓存类，并通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例。因此，如果配置了只读缓存，MyBatis就会使用Map来存储缓存值。而这个缓存类要求所有被序列化的对象必须实现Serializable接口 。因此我们的java Bean需要实现Serializable接口。 12345678910package com.xust.iot.beans;import java.io.Serializable;public class User implements Serializable &#123; private static final long serialVersionUID = -8963153814502574628L; //其他属性&#125; 做好所有准备后，编写一个测试类来看看二级缓存的效果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package test;import com.xust.iot.beans.User;import com.xust.iot.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class AppTest &#123; private static SqlSessionFactory sqlSessionFactory; private static Logger log = Logger.getLogger(AppTest.class); @Before public void init() &#123; String resource = "mybatis-config.xml"; try &#123; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testL2Cache() &#123; //第一个会话 SqlSession session = sqlSessionFactory.openSession(true); StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;User&gt; user1 = sm.getUserByName("小明"); if (null != user1 &amp;&amp; user1.size() &gt; 0) &#123; for (User u : user1) &#123; System.out.println(u.toString()); &#125; &#125; session.close(); //第二个会话 System.out.println("开启新的会话......"); SqlSession session2 = sqlSessionFactory.openSession(true); StudentMapper sm2 = session2.getMapper(StudentMapper.class); List&lt;User&gt; user2 = sm2.getUserByName("小明"); if (null != user2 &amp;&amp; user2.size() &gt; 0) &#123; for (User u : user2) &#123; System.out.println(u.toString()); &#125; &#125; session2.close(); &#125;&#125; 测试结果： MyBatis缓存的执行逻辑&nbsp;&nbsp;&nbsp;&nbsp;1.当一个SqlSession第一次执行一次select后，查到数据后会首先把查询到的结果保存到一级缓存中&nbsp;&nbsp;&nbsp;&nbsp;2.当该SqlSession被关闭或者提交后，保存在一级缓存中的数据会转移到二级缓存中（前提是正确开启并配置了二级缓存）&nbsp;&nbsp;&nbsp;&nbsp;3.当另一个SqlSession第一次执行同样select时，首先会在二级缓存中找，如果没找到，就去自己的一级缓存中找，找到了就返回，如果没找到就去数据库查，MyBatis就是通过这样的机制从而减少了数据库压力提高了性能。MyBatis的执行流程总结起来就是：二级缓存–&gt;一级缓存–&gt;数据库 注意事项：&nbsp;&nbsp;&nbsp;&nbsp;1.如果SqlSession执行了DML操作（insert、update、delete），并commit了，那么mybatis就会清空当前mapper缓存中的所有缓存数据，这样可以保证缓存中的存的数据永远和数据库中一致，避免出现脏读&nbsp;&nbsp;&nbsp;&nbsp;2.mybatis的缓存是基于[namespace:sql语句:参数]来进行缓存的，意思就是，SqlSession的HashMap存储缓存数据时，是使用[namespace:sql:参数]作为key，查询返回的语句作为value保存的。]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis XML映射文件的配置]]></title>
    <url>%2F2019%2F07%2F27%2FMybatis%20XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[MyBatis中的SQL 映射文件只有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。cache-ref – 其他命名空间缓存配置的引用。resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。sql – 可被其他语句引用的可重用语句块。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句 select元素select元素就是用来查询的，在select里嵌入SQL select查询语句,就象下边这样： 123&lt;select id="get" resultType="Employee" parameterType="int"&gt; select * from employee where id=#&#123;id&#125;;&lt;/select&gt; 其中 select元素中的id属性是必须的，它的值是对应Mapper接口中的一个方法，当调用这个接口就是调用这个sql。关于select元素常用的属性具体如下： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。这个是必须的属性 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 resultType 返回的期望类型的类的完全限定名或别名。这个属性是可选的 resultMap 返回值类型是是个map集合，可用于多表联查后的结果MyBatis会封装成一个map返回，这个属性是可选的 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：false。这个属性是可选的 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对 select 元素为 true。这个属性是可选的 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。这个属性是可选的 insert update delete&nbsp;&nbsp;&nbsp;&nbsp;insert update delete元素分别对应SQL语句中的insert、update、delete，分别实现对数据库记录的插入、更新和删除。他们可以有的属性值如下： 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。这个是必须的属性 parameterType 将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。 useGeneratedKeys （仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键，默认值为false，这个属性是可选的。 keyProperty （仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，他和useGeneratedKeys配合起来才能工作 flushCache 将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true。这个属性是可选的 useCache 将其设置为 true，将会导致本条语句的结果被二级缓存，默认值：对增删改元素为false。这个属性是可选的 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。这个属性是可选的 keyColumn （仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。 Result MapsresultMap 元素是 MyBatis 中最重要最强大的元素。 ResultMap 的设计就是简单语句不需要明确的结果映射,而很多复杂语句确实需要描述它们的关系。 简单映射例如下面这个例子：： 123&lt;select id="getById" resultType="Employee" paramaterType="int"&gt; select * from employee where id=#&#123;id&#125;&lt;/select&gt; JavaBean是这样的： 1234567891011121314151617181920212223242526package com.xzy.bean;public class Employee &#123; /** * JavaBean基本类型最好使用他的包装类型！！！ */ private Long id; private String empId; private String empName; private Integer empAge; private String empSex; //省略getter、setter.... @Override public String toString() &#123; return "Employee&#123;" + "id=" + id + ", empId='" + empId + '\'' + ", empName='" + empName + '\'' + ", empAge=" + empAge + ", empSex='" + empSex + '\'' + '&#125;'; &#125;&#125; Mybatis会将基于 JavaBean 的规范,这些 在 select 语句中会精确匹配到列名。这样一个语句简单作用于所有列被自动映射到 HashMap 的键上,这由 resultType 属性 指定。也就是说，对于resultType MyBatis会结果封装一个map返回。 高级映射有时候我们避免不了多表联查，这样带来的问题是返回的结果类型中的一个字段在resultType中的不存在，这就会造成问题。MyBatis中使用resultMap来解决这个问题。resultMap 元素有很多子元素和一个值得讨论的结构。 下面是 resultMap 标签中可以使用的属性如下： resultMap:constructor - 类在实例化时,用来注入结果到构造方法中idArg - ID 参数;标记结果作为 ID 可以帮助提高整体效能arg - 注入到构造方法的一个普通结果id – 一个 ID 结果;标记结果作为 ID 可以帮助提高整体效能result – 注入到字段或 JavaBean 属性的普通结果association – 一个复杂的类型关联;许多结果将包成这种类型嵌入结果映射 – 结果映射自身的关联,或者参考一个collection – 复杂类型的集嵌入结果映射 – 结果映射自身的集,或者参考一个discriminator – 使用结果值来决定使用哪个结果映射case – 基于某些值的结果映射嵌入结果映射 – 这种情形结果也映射它本身,因此可以包含很多相 同的元素,或者它可以参照一个外部的结果映射。 描述描述 id 当前命名空间中的一个唯一标识，用于标识一个result map. type 类的全限定名, 或者一个类型别名 autoMapping 如果设置这个属性，MyBatis将会为这个ResultMap开启或者关闭自动映射。这个属性会覆盖全局的属性autoMappingBehavior。默认值为：unset。 下面是一个例子： 12345678910111213141516171819202122&lt;!--StudentMapper.xml--&gt;&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xzy.mapper.StudentMapper"&gt; &lt;!--第一种多表联查的映射方式--&gt; &lt;resultMap type="student" id="queryCName"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="sid" column="sid"/&gt; &lt;result property="sname" column="sname"/&gt; &lt;result property="majorIn" column="major_in"/&gt; &lt;result property="sclass" column="sclass"/&gt; &lt;result property="course.cname" column="cname"/&gt; &lt;/resultMap&gt; &lt;!--查询某个同学所选的课程--&gt; &lt;select id="getAll" parameterType="string" resultMap="queryCName"&gt; select student.*,course.cname from student,course where student.cid=course.cid and student.sname=#&#123;sname&#125; &lt;/select&gt;&lt;/mapper&gt; 学生实体：Student.java 123456789101112131415161718192021222324252627//JavaBean Studentpackage com.xzy.bean;public class Student &#123; private Long id; private String sid; private String sname; private String majorIn; private String sclass; private Course course; //getter、setter... @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", sid='" + sid + '\'' + ", sname='" + sname + '\'' + ", majorIn='" + majorIn + '\'' + ", sclass='" + sclass + '\'' + ", cname=" + course.getCname() + '&#125;'; &#125;&#125; 课程实体:Course.java 1234567891011121314151617181920//JavaBean Coursepackage com.xzy.bean;public class Course &#123; private Long id; private String cid; private String cname; private Student student; //省略getter、setter..... @Override public String toString() &#123; return "Course&#123;" + "id=" + id + ", cid='" + cid + '\'' + ", cname='" + cname + '\'' + '&#125;'; &#125;&#125; 测试类AppTest.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.xzy;import com.xzy.bean.Course;import com.xzy.bean.Student;import com.xzy.mapper.CourseMapper;import com.xzy.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;import java.util.Scanner;/** * Unit test for simple App. */public class AppTest &#123; private static Logger log = Logger.getLogger(AppTest.class); private static SqlSessionFactory sqlSessionFactory; @Before public void initLoad() throws IOException &#123; String resource = "mybatis-config.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void selectAll() &#123; SqlSession session = sqlSessionFactory.openSession(true); try&#123; StudentMapper sm=session.getMapper(StudentMapper.class); List&lt;Student&gt; lists= sm.getAll("OKOK2"); if(null!=lists&amp;&amp;lists.size()&gt;0) &#123; System.out.println("OKOK2同学选的课："); for (Student list : lists) &#123; System.out.println(list.toString()); &#125; System.out.println("OK..."); &#125;else&#123; System.out.println("没有这个人或该同学没有选课...."); &#125; &#125;catch (Exception e)&#123; System.out.println("查询失败。。。。"); &#125;finally&#123; session.close(); &#125; &#125;&#125; 运行结果： cache 和cache-ref 的用法参考另一篇笔记MyBatis缓存配置]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 动态SQL]]></title>
    <url>%2F2019%2F07%2F26%2FMybatis%E5%8A%A8%E6%80%81SQL%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;MyBatis 的强大特性之一便是它的动态 SQL。动态 SQL 元素和使用 JSTL 或其他类似基于 XML 的文本处理器相似。在 MyBatis 之前的版本中,有很多的元素需要来了解。MyBatis 3 大大提升了它们,现在用不到原先一半的元素就可以了。MyBatis 采用功能强大的基于 OGNL 的表达式来消除其他元素。主要的有以下几个： if choose (when, otherwise) trim (where, set) liforeach if使用if可以用条件的筛选SQL语句分支，只有条件满足的时候才会执行。实例： 12345678&lt;select id="get" resultType="Employee"&gt; select * from employee &lt;where&gt; &lt;if test="empSex!=null"&gt;and emp_sex=#&#123;empSex&#125; &lt;/if&gt; &lt;if test="empAge!=null"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test="empName!=null"&gt;or emp_name=#&#123;empName&#125;&lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 这条sql语句就会动态的根据传入的参数值来查询，比如当只传了empAge=23，其他都为空，那么生成的sql语句就是：select * from employee where emp_age=23，where元素是很强大的，他会自动帮我们把sql中多余的and或or去掉 choose、when、otherwiseMyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。实例; 12345678910&lt;!--下面的条件分支中只会有一条被执行--&gt;&lt;select id="getBycondition" resultType="Employee"&gt;select * from employee where&lt;choose&gt; &lt;when test="empId!=null"&gt;emp_id=#&#123;empId&#125;&lt;/when&gt; &lt;when test="empAge!=null"&gt;emp_age=#&#123;empAge&#125;&lt;/when&gt; &lt;when test="empName!=null"&gt;emp_name=#&#123;empName&#125;&lt;/when&gt; &lt;otherwise&gt;emp_sex='女'&lt;/otherwise&gt;&lt;/choose&gt;&lt;/select&gt; java代码这么写： 123456789101112131415161718192021222324252627282930313233public class AppTest&#123;SqlSessionFactory sqlSessionFactory;private static final Logger log=Logger.getLogger(AppTest.class);@Beforepublic void createSqlSession() throws IOException &#123;String resource="mybatis-config.xml";try (InputStream inputStream = Resources.getResourceAsStream(resource)) &#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);&#125;&#125;@Testpublic void get2()&#123;SqlSession session=sqlSessionFactory.openSession(true);try&#123; Employee employee=new Employee(); employee.setEmpAge(34); employee.setEmpId("3343"); EmployeeMapper mapper=session.getMapper(EmployeeMapper.class); List&lt;Employee&gt;lists=mapper.getBycondition(employee); for(Employee list:lists)&#123; System.out.println(list.toString()); &#125; log.info(mapper);&#125;catch (Exception e)&#123; System.out.println("查询数据异常..."+e); session.rollback();&#125;finally &#123; session.close();&#125;&#125;&#125; 可以看到，即使在条件中给了两个不为空的，但是由于EmpId在最前面，因此首先匹配上后就不在往下找了，和switch很像。最终的运行结果： trim, where看看下面的这条这种情况： 123456&lt;select id="getEmp" resultType="Employee"&gt; select * from employee where &lt;if test="empAge!=null"&gt;emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test="empAge!=null"&gt; and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test="empAge!=null"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt;&lt;/selsct&gt; 如果三个分之没有一条分支匹配上，那么最终的sql语句会变成： 1select * from employee where 这显然是会导致查询失败的。如果仅仅第二条或第三条匹配，那么sql语句会变成这样: 123select * from employee where and emp_age=#&#123;empAge&#125;/*或者是下面的样子*/select * from employee where and emp_age=#&#123;empAge&#125; 不论是那种情况，都会导致由于sql语句错误而查询失败。MyBatis 有一个简单的处理，这在90%的情况下都会有用。那就是使用where元素，where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。例如： 12345678&lt;select id="getEmp" resultType="Employee"&gt; select * from employee &lt;where&gt; &lt;if test="empAge!=null"&gt;emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test="empAge!=null"&gt; and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;if test="empAge!=null"&gt;and emp_age=#&#123;empAge&#125;&lt;/if&gt; &lt;/where&gt;&lt;/selsct&gt; &nbsp;&nbsp;&nbsp;&nbsp;这样即使三条语句都不满足条件，那么最终的sql语句是：select * from employee，也不会影响正常的查询。 &nbsp;&nbsp;&nbsp;&nbsp;如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为： 123&lt;trim prefix="WHERE" prefixOverrides="AND |OR "&gt; ... &lt;/trim&gt; &nbsp;&nbsp;&nbsp;&nbsp;prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的. set&nbsp;&nbsp;&nbsp;&nbsp;set用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的.示例： 123456789101112131415161718&lt;update id="updateByConditon"&gt;update employee&lt;set&gt; &lt;if test="param1.empId!=null"&gt; emp_id=#&#123;param1.empId&#125;, &lt;/if&gt; &lt;if test="param1.empName!=null"&gt; emp_name=#&#123;param1.empName&#125;, &lt;/if&gt; &lt;if test="param1.empSex!=null"&gt; emp_sex=#&#123;param1.empSex&#125;, &lt;/if&gt; &lt;if test="param1.empAge!=null"&gt; emp_age=#&#123;param1.empAge&#125; &lt;/if&gt;&lt;/set&gt;where emp_age=#&#123;param2&#125;&lt;/update&gt; java代码： 123456789101112131415 @Testpublic void updateByConditon()&#123; SqlSession session=sqlSessionFactory.openSession(true); try&#123; EmployeeMapper em=session.getMapper(EmployeeMapper.class); List&lt;Employee&gt; lists=em.getAll(); for(Employee list:lists)&#123; list.setEmpName("蔡徐坤"); em.updateByConditon(list,22); &#125; log.info(em); &#125;finally &#123; session.close(); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号 foreach&nbsp;&nbsp;&nbsp;&nbsp;动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 in 条件语句的时候: 1234567&lt;select id="selectPostIn" resultType="Employee"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach collection="lists" item="list" open="(" separator="," close=")"&gt; #&#123;list&#125; &lt;/foreach&gt;&lt;/select&gt; foreach标签中可以使用的属性如下：1. collection ：collection属性的值有三个分别是list、array、map三种，分别对应的java类型为：List、数组、map集合2. item ： 表示在迭代过程中每一个元素的别名3. index ：遍历过程的索引值4. open ：前缀5. close ：后缀6. separator ：分隔符，表示迭代时每个元素之间以什么分隔7. foreach标签主要用于构建in条件，他可以在sql中对集合进行迭代。]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 全局XML文件的配置]]></title>
    <url>%2F2019%2F07%2F26%2FMybatis%E5%85%A8%E5%B1%80XML%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[properties properties提供了一个通过外部配置文件(例如数据库配置文件)来动态配置环境的方法。以动态配置数据库为例： 数据库配置文件jdbc.properties的详细配置如下： 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/xust?autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;set global time_zone=&apos;+8:00&apos; username=rootpassword=95162437 那么我们可以在mybatis-config.xml中这么写： 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置外部数据库文件的位置，把它加载进来--&gt; &lt;properties resource="jdbc.properties"&gt; &lt;/properties&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!--通过在外部动态配置的方式来配置--&gt; &lt;!--需要注意的是value后面的值如果没有自定义，必须和外部配置文件中的名字一致--&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/StudentMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; settingssetting可以调整MyBatis的一些分长重要的配置，它们会改变 MyBatis 的运行时的行为，具体都有哪些配置可以设置可以参考官网，这里不再赘述，这里说几个常用的： 设置参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关。 true | false true lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。 true | false false mapUnderscoreToCamelCase 是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 true | false false logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING Not set logPrefix 指定 MyBatis 增加到日志名称的前缀。 Any String Not set L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});!function(e){var r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function t(){for(var c=0;c]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识MyBatis]]></title>
    <url>%2F2019%2F07%2F25%2F%E8%AE%A4%E8%AF%86Mybatis%2F</url>
    <content type="text"><![CDATA[什么是MyBatis?MyBatis 是一款优秀的java持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis的历史原是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation 迁移到了Google Code，随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis ，代码于2013年11月迁移到Github（下载地址见后）。iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO） 为什么要使用MyBatis? MyBatis是一个半自动化的持久化层框架。 JDBC的不足： -SQL夹在Java代码块里，耦合度高导致硬编码内伤 -维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 Hibernate和JPA -长难复杂SQL，对于Hibernate而言处理也不容易 -内部自动生产的SQL，不容易做特殊优化。 -基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。导致数据库性能下降。 对开发人员而言，核心sql还是需要自己优化 sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。 去哪里找MyBatis?MyBatis：https://github.com/mybatis/mybatis-3 简单的配置让MyBatis跑起来创建Maven项目在IDEA中打开【File】->【New】->【New Project】,然后选择【Maven】，创建一个【webapp】工程，如图所示 填写【GroupId】和【ArtifactId】,填好后点击【Next】 完成上面的操作后，等待片刻，一个基于Maven的基本结构就创建完成了，得到的Maven项目的目录结构如下图： 打开Mavne项目的pom.xml配置文件，向文件中添加MyBatis依赖、数据库JDBC驱动和Log4j等依赖 1234567891011121314151617181920212223242526272829&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;!--mybatis的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;!--数据库驱动的依赖包--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.11&lt;/version&gt; &lt;/dependency&gt;&lt;!--日志记录--&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 完成以上操作后，MyBatis的基本开发环境就已经搭建好了，接下来我们开始实现衣蛾简单的查询功能。 准备数据库创建Student表 123456create table student( sid varchar(255) primary key not null, sname varchar(255) not null, major_in varchar(255), sclass varchar(255) ); 创建实体类和Mapper文件在【main】下新建一个文件夹【java】,并标记为【Source Root】，然后在src/main/java下新建一个基础包com.xzy,在这个包下在创建一个beans包，在这个包中创建一个实体类Student,代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.xzy.beans;import java.io.Serializable;public class Student implements Serializable &#123; private String sid; private String sname; private String majorIn; private String sclass; public Student()&#123; &#125; public String getSid() &#123; return sid; &#125; public void setSid(String sid) &#123; this.sid = sid; &#125; public String getSname() &#123; return sname; &#125; public void setSname(String sname) &#123; this.sname = sname; &#125; public String getMajorIn() &#123; return majorIn; &#125; public void setMajorIn(String majorIn) &#123; this.majorIn = majorIn; &#125; public String getSclass() &#123; return sclass; &#125; public void setSclass(String sclass) &#123; this.sclass = sclass; &#125; @Override public String toString() &#123; return "Student&#123;" + "sid='" + sid + '\'' + ", sname='" + sname + '\'' + ", major_in='" + majorIn + '\'' + ", sclass='" + sclass + '\'' + '&#125;'; &#125;&#125; 再在【com.xzy】包下新建一个包【dao.mapper】,在里面新建一个接口StudentMapper 1234567891011package com.xzy.dao.mapper;import com.xzy.beans.Student;import java.util.List;public interface StudentMapper &#123; public List&lt;Student&gt; getAll();&#125; 在【main】下新建一个文件夹【resoources】,并标记为【Resources Root】,然后在src/main/resources下创建目录【mapper】,在mapper目录中创建StudentMapper.xml文件，添加如下内容： 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xzy.dao.mapper.StudentMapper"&gt; &lt;!--查询学生表中的所有学生--&gt; &lt;select id="getAll" resultType="com.xzy.beans.Student"&gt; select * from student &lt;/select&gt;&lt;/mapper&gt; 配置MyBatisMyBatis有多种配置方式，这里使用最基础最常用的XML配置方式。首先在【src/main/resources】下创建【MyBatis-config.xml】文件，输入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="jdbc.properties"&gt; &lt;/properties&gt; &lt;!--一些有关于mybatis运行是行为的设置--&gt; &lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="25"/&gt; &lt;setting name="defaultFetchSize" value="100"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!--设置数据库字段的下换线自动映射到java的驼峰模式--&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt; &lt;/settings&gt; &lt;!--配置数据库连接，可以配置多个数据库--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;!--通过在外部动态配置的方式来配置--&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="mapper/StudentMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 上面的配置文件中需要一个jdbbc.properties的配置文件，同样在【src/main/resources】下新建jdbc,properties文件 ，然后输入如下内容： 1234driver=com.mysql.cj.jdbc.Driverurl=jdbc:mysql://localhost:3306/xust?autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;set global time_zone='+8:00' username=rootpassword=123456 配置Log4j一遍查看MyBatis操作数据库的过程在src/main/resources中添加log4j.properties配置文件，输入一下内容： 123456789101112131415161718192021222324### set log levels ### log4j.rootLogger = DEBUG , console , debug , error ### console ### log4j.appender.console = org.apache.log4j.ConsoleAppender log4j.appender.console.Target = System.out log4j.appender.console.layout = org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n ### log file ### log4j.appender.debug = org.apache.log4j.DailyRollingFileAppender log4j.appender.debug.File = redcmsv6.log log4j.appender.debug.Append = true log4j.appender.debug.Threshold = INFO log4j.appender.debug.layout = org.apache.log4j.PatternLayout log4j.appender.debug.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n ### exception ### log4j.appender.error = org.apache.log4j.DailyRollingFileAppender log4j.appender.error.File = redcms.log log4j.appender.error.Append = true log4j.appender.error.Threshold = ERROR log4j.appender.error.layout = org.apache.log4j.PatternLayout log4j.appender.error.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%p]-[%c] %m%n 编写测试代码然MyBatis跑起来12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package test;import java.io.IOException;import java.io.InputStream;import java.util.List;import com.xzy.beans.Student;import com.xzy.dao.mapper.StudentMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;/** * Unit test for simple App. */public class AppTest&#123; SqlSessionFactory sqlSessionFactory; @Before public void before() &#123; try &#123; String resource = "MyBatis-CONFIG.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testselectAll()&#123; SqlSession session=sqlSessionFactory.openSession(); //接口 try &#123; StudentMapper sm = session.getMapper(StudentMapper.class); List&lt;Student&gt; stus = sm.getAll(); for (Student stu : stus) System.out.println(stu.toString()); System.out.println("Ok"); &#125;finally &#123; session.close(); &#125; &#125;&#125; 测试结果：]]></content>
      <categories>
        <category>MyBatis框架</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置实例—反向代理]]></title>
    <url>%2F2019%2F01%2F29%2FNginx%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%E2%80%94%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、配置示例1：： 要求：在浏览器地址栏中输入www.123.com，跳转到Linux服务器中的tomcat主页面 声明：本次实验在我电脑的Linux虚拟机上进行的，Linux系统信息如下： 图1 实验系统信息 1.1 准备工作（1）安装nginx(参考：Nginx快速入门—基本概念以及在Linux上安装Nginx（2）启动一个tomcat（注意：在启动之前一定要配置好Java环境变量，参考：记一次在云服务器上部署项目的实践经历)（3）tomcat启动后在本地host文件中配置域名映射： 1192.168.92.128 www.123.com 配置完成后在浏览器中输入www.123.com:8080 如果能看到tomcat的页面，就说明配置的没有问题。 图2 host配置测试 1.2 nginx配置反向代理接下来我们来配置nginx，nginx一入门我们都知道在nginx的安装目录下的conf/nginx.conf是nginx的默认配置文件，因此打开它默认配置文件并简单配置如下内容（当然，你也可以使用nginx -c指定配置文件），简单配置如下： 123456789101112server &#123; listen 80; server_name 192.168.92.128; #server 代理域名 charset utf-8; location / &#123; #location / 通配所有请求路径 root html; proxy_pass http://127.0.0.1:8080; #请求会转发到Linux系统的127.0.0.1：8080端口 index index.html index.htm; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 测试结果：配置完成后重新加载配置文件后，直接访问www.123.com，如果可以看到tomcat的首页那就大功告成啦！ 图2 nginx反向代理配置示例1测试 2、配置示例2：： 要求：在浏览器地址栏中输入www.123.com/login，请求跳转到127.0.0.1:8080在浏览器地址栏中输入www.123.com/user，请求跳转到127.0.0.1:8081 2.1 准备工作启动两个tomcat，并在监听8080端口的tomcat的webapps目录下新建文件夹login以及文件index.html;在监听8081端口的tomcat的webapps目录下新建文件夹user以及文件index.html; 2.2 配置nginx按照要求，nginx服务器要根据不同的请求路径把不同的请求转发到不同的tomcat中处理，这里就需要用到正则表达式来匹配路径，具体的配置如下： 123456789101112131415161718192021server &#123; listen 80; server_name 192.168.92.128; charset utf-8; location ~ /login &#123; #正则表达式匹配login请求 root html; proxy_pass http://127.0.0.1:8080; #forward to tomcat 8080 index index.html index.htm; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; location ~ /user&#123; #正则表达式匹配user请求 root html; proxy_pass http://127.0.0.1:8081; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; error_page 404 /404.html;&#125; 测试结果： 图3 nginx反向代理配置示例2测试 3、location匹配规则详解在上面的配置中使用到了正则匹配，nginx官方文档给出location语法如下： location语法：location [=||*|^~] /uri/ { … } 其中，方括号中的四种标识符是可选项，用来改变请求字符串和uri的匹配方式。uri是待匹配的请求字符串，可以是不包含正则的字符串，这种模式被称为“标准的uri”；也可以包含正则，这种模式被称为”正则uri”，具体可用的标识符如下： *= * ：必须与指定的模式严格匹配，如果匹配成功就停止向下搜索，并立即处理代理逻辑 ~：必须以指定模式开始，并且区分大小写 ~* ：必须以指定模式开始，并且不区分大小写 *^~ *：前缀匹配，不支持正则，如果模式匹配，那么就停止搜索其他模式了。 无：普通匹配（最长字符匹配）；与location顺序无关，是按照匹配的长短来取匹配结果。若完全匹配，就停止匹配。 备注：1、如果uri里面包含正则表达式，就必须使用或标识符；2、针对和*匹配标识符，可以在前面加上!来取反，如下：&lt;span style=”color=”rgb(192, 0, 0)”&gt;!~ 表示正则不匹配，区分大小写。&lt;span style=”color=”rgb(192, 0, 0)”&gt;!~ 表示正则不匹配，不区分大小写。 3.1 精确匹配（=）示例123location = /login&#123; #严格匹配 /login（多一个字母少一个字母或多一级少一级路径都不行） ，匹配成功后，立即结束&#125; 3.2 区分大小写正则匹配（~）示例123location ~ /login/&#123; #正则匹配，区分大小写（/LOGIN/、、/Login/都是不可以的），匹配成功后，立即结束&#125; 3.3 不区分大小写正则匹配（~*）示例123location ~* /login/&#123;#正则匹配，不区分大小写（/LOGIN/、/Login/都是可以的），匹配成功后，立即结束&#125; 3.4 标准匹配（^~）示例123location ^~ /login/&#123; # 匹配任何以 /login/ 开头的地址，匹配符合以后，停止往下搜索正则&#125; 3.5 普通匹配（最长字符匹配）示例1234location /login/&#123; # 与location顺序无关 # 若完全匹配成功，就不在继续匹配，否则还会进行正则匹配&#125; 4、location匹配优先级1、如果有精确匹配，会先进行精确匹配，匹配成功，立刻返回结果。2、普通匹配与顺序无关，因为按照匹配的长短来取匹配结果。3、正则匹配与顺序有关，因为是从上往下匹配。(首先匹配，就结束解析过程)。4、在location中，location /可以匹配所有的请求，但是他的优先级是最低的。 总结匹配规则如下：&lt;span style=”color=”rgb(192, 0, 0)”&gt; (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) &gt; (location /)即&lt;span style=”color=”rgb(192, 0, 0)”&gt;（精确匹配）&gt; (最长字符串匹配，但完全匹配) &gt;（非正则匹配）&gt;（正则匹配）&gt;（最长字符串匹配，不完全匹配）&gt;（location通配）]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx配置文件详解（配置文件结构）]]></title>
    <url>%2F2019%2F01%2F27%2FNginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%88%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Nginx配置文件结构在nginx的安装目录下的conf目录下有一个nginx.conf,这个就是nginx默认的配置文件，默认的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#user nobody;worker_processes 1;error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; Nginx配置文件结构： 123456789101112131415161718192021222324.... #全局块events&#123; #events块 &#125;http&#123; #http块 ..... #http全局块 server&#123; #server块 ..... #server全局块 location [PATTERN]&#123; #location块 &#125; location [PATTERN]&#123; &#125; &#125; server&#123; .... &#125;&#125; 1、main：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。可配置的参数如下： （1）user：来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行（2）worker_processes：指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了。如果是多核CPU，建议指定和CPU的数量一样的进程数即可。（3）error_log：用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。（4）pid：用来指定进程id的存储文件位置。（5）worker_rlimit_nofile：用于指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。配置示例： 1234567&gt; user nobody;worker_processes 1;error_log logs/error.log;error_log logs/error.log notice;error_log logs/error.log info;pid logs/nginx.pid;&gt; 2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 （1）use：用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中,对于Linux系统，epoll工作模式是首选。（2）worker_connections：用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processesworker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes * worker_connections/4。进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。*配置示例**： 12345&gt; events&#123;&gt; use poll;&gt; worker_connections 1024; &gt;&#125;&gt; 3、http块：可以嵌套多个server，http模块负责HTTP服务器相关属性的配置，有server和upstream两个子模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。 （1）include ：设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。（2）default_type：设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp的locate环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。（3）log_format：用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。配置示例： 123456789101112&gt; include mime.types;&gt; default_type application/octet-stream;&gt; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; &gt; access_log logs/access.log main; &gt; sendfile on;&gt; tcp_nopush on; keepalive_timeout 0; keepalive_timeout 65;gzip on;&gt; 4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。 （1）listen：用于指定虚拟主机监听的服务端口。（2）server_name：用来指定IP地址或者域名，多个域名之间用空格分开。（3）root ：表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。（4）index ：全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。（5）charset：用于设置网页的默认编码格式。（6）access_log：用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。配置示例： 12345678910&gt; server &#123; listen 80; server_name localhost; root /Users/hk/www; index index.php index.html index.htm; charset utf-8; access_log logs/host.access.log main; aerror_log logs/host.error.log main;&gt;&#125;&gt; 5、location块：location模块 负载均衡,反向代理,虚拟域名等配置。是来定位的，定位URL，解析URL，它也提供了强大的正则匹配功能，也支持条件判断匹配，可以通过location指令实现Nginx对动,静态网页进行过滤处理。 （1）location / 表示匹配访问根目录。（2）root：用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。（3）proxy_pass：代理转发，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。（4）proxy_set_header：允许重新定义或者添加发往后端服务器的请求头。（5）include：加载配置文件，后面介绍nginx多个配置文件时候会提到。（6）index：定义页面显示html，一般和alias配合使用。（7）root：定位localtion匹配的url资源路径。配置示例： 12345&gt; location / &#123; root html; index index.html index.htm;&#125;&gt; 6、upstream：模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。 Nginx的负载均衡模块目前支持4种调度算法:（1）weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。（2）ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。（3） fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。（4）url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。 在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：down，表示当前的server暂时不参与负载均衡。backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java获取请求URL以及服务器根路径的方法]]></title>
    <url>%2F2019%2F01%2F02%2FJava%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82URL%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A0%B9%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、 获取此次请求的URL123456String requestUrl = request.getScheme() //当前链接使用的协议 +"://" + request.getServerName()//服务器地址 + ":" + request.getServerPort() //端口号 + request.getContextPath() //应用名称，如果应用名称为 + request.getServletPath() //请求的相对url + "?" + request.getQueryString(); //请求参数 举例：http://127.0.0.1:8080/world/index.jsp?name=lilei&amp;sex=1 123456789101112131415161718&lt;Context path=&quot;world&quot; docBase=&quot;/home/webapps&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;/&gt; request.getScheme() = &quot;http&quot;;request.getServerName() = &quot;127.0.0.1&quot;;request.getServerPort() = &quot;8080&quot;;request.getContextPath() = &quot;world&quot;;request.getServletPath() = &quot;index.jsp&quot;;request.getQueryString() = &quot;name=lilei&amp;sex=1&quot;; http://127.0.0.1:8080/world/index.jsp?name=lilei&amp;sex=1&lt;Context path=&quot;&quot; docBase=&quot;/home/webapps&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;/&gt; request.getScheme() = &quot;http&quot;;request.getServerName() = &quot;127.0.0.1&quot;;request.getServerPort() = &quot;8080&quot;;request.getContextPath() = &quot;&quot;;request.getServletPath() = &quot;world/index.jsp&quot;;request.getQueryString() = &quot;name=lilei&amp;sex=1&quot;; 二、获取服务器根路径1234&lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; 在JSP中使用方法如下： 123456789&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="&lt;%=basePath%&gt;static/css/framework/themes/default/easyui.css"&gt;&lt;link rel="stylesheet" type="text/css" href="&lt;%=basePath%&gt;static/css/framework/themes/icon.css"&gt;&lt;link rel="stylesheet" type="text/css" href="&lt;%=basePath%&gt;static/css/base.css"&gt;&lt;script src="&lt;%=basePath%&gt;static/javascript/framework/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="&lt;%=basePath%&gt;static/javascript/framework/jquery.easyui.min.js"&gt;&lt;/script&gt;&lt;script src="&lt;%=basePath%&gt;static/javascript/framework/easyui-lang-zh_CN.js"&gt;&lt;/script&gt;&lt;script src="&lt;%=basePath%&gt;static/javascript/framework/easyui-util.js"&gt;&lt;/script&gt;&lt;/head&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
